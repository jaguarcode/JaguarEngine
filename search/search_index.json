{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"JaguarEngine DocumentationJaguarEngine","text":"<p>Next-Generation Multi-Domain Physics Simulation Platform</p>"},{"location":"#overview","title":"Overview","text":"<p>JaguarEngine is a high-performance physics simulation framework designed for defense modeling and simulation (M&amp;S) applications. It supports Air, Land, Sea, and Space domains within a unified architecture, inspired by JSBSim's proven design patterns while leveraging modern C++20 capabilities.</p>   ### Multi-Domain Physics Unified framework supporting aircraft, ground vehicles, surface vessels, and spacecraft in a single simulation.  ### High Performance Data-oriented design with Structure-of-Arrays (SoA) memory layout, SIMD optimization, and GPU compute acceleration (CUDA, OpenCL, Metal) for real-time execution.  ### Accurate Models 6-DOF rigid body dynamics, US Standard Atmosphere 1976, Bekker-Wong terramechanics, MMG ship maneuvering, SGP4/SDP4 orbital propagation.  ### Distributed Simulation Complete IEEE 1278.1-2012 DIS and IEEE 1516-2010 HLA RTI federation support for Live-Virtual-Constructive (LVC) integration.  ### Machine Learning Neural autopilot systems, ONNX model inference, reinforcement learning environments with Gym-compatible API, and model repository management.  ### Cloud Native Auto-scaling cloud burst capability with distributed state synchronization, Raft consensus, and spatial partitioning for massively concurrent simulations.  ### XR Ready Full OpenXR integration with spatial audio, haptic feedback, and training scenario management for immersive simulation experiences.  ### Digital Thread Complete lifecycle tracking with history store, predictive degradation models, and physics-based failure prediction for digital twin applications.  ### Scriptable Python and Lua bindings for rapid prototyping and integration with data science workflows."},{"location":"#quick-links","title":"Quick Links","text":"Getting Started Reference Advanced Installation Guide API Reference Architecture Quick Start Tutorial Configuration Custom Models First Simulation Python API Network Integration Phase 7 Modules Cloud Burst Digital Thread Machine Learning Federation GPU Compute Sensors"},{"location":"#domain-overview","title":"Domain Overview","text":""},{"location":"#air-domain","title":"Air Domain","text":"<ul> <li>Coefficient-based aerodynamics with N-dimensional interpolation tables</li> <li>Turbofan/turbojet propulsion with altitude-Mach corrections</li> <li>Flight control system with rate limiting and autopilot</li> </ul> <p>Learn more about Air Domain \u2192</p>"},{"location":"#land-domain","title":"Land Domain","text":"<ul> <li>Bekker-Wong terramechanics for soil-vehicle interaction</li> <li>Spring-damper suspension with bump stops</li> <li>Tracked and wheeled vehicle dynamics</li> </ul> <p>Learn more about Land Domain \u2192</p>"},{"location":"#sea-domain","title":"Sea Domain","text":"<ul> <li>Buoyancy with metacentric height stability</li> <li>MMG (Maneuvering Mathematical Group) hydrodynamics</li> <li>Pierson-Moskowitz and JONSWAP wave spectra</li> <li>RAO-based ship motion response</li> </ul> <p>Learn more about Sea Domain \u2192</p>"},{"location":"#space-domain","title":"Space Domain","text":"<ul> <li>SGP4/SDP4 orbital propagation</li> <li>High-fidelity gravity models (J2, J4, EGM96)</li> <li>Atmospheric drag (JBH08 model)</li> </ul> <p>Learn more about Space Domain \u2192</p>"},{"location":"#installation","title":"Installation","text":"<pre><code># Clone the repository\ngit clone https://github.com/jaguarcode/JaguarEngine.git\ncd JaguarEngine\n\n# Build\nmkdir build &amp;&amp; cd build\ncmake ..\nmake -j$(nproc)\n\n# Run tests\n./jaguar_unit_tests\n</code></pre> <p>Complete installation guide \u2192</p>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>#include &lt;jaguar/jaguar.h&gt;\n\nint main() {\n    using namespace jaguar;\n\n    // Create and initialize engine\n    interface::Engine engine;\n    engine.initialize();\n\n    // Create an aircraft entity\n    EntityId aircraft = engine.create_entity(\"F16\", Domain::Air);\n\n    // Set initial state\n    physics::EntityState state;\n    state.position = Vec3{0.0, 0.0, -10000.0};  // 10 km altitude\n    state.velocity = Vec3{250.0, 0.0, 0.0};     // 250 m/s forward\n    state.mass = 12000.0;\n    engine.set_entity_state(aircraft, state);\n\n    // Run simulation\n    for (int i = 0; i &lt; 1000; ++i) {\n        engine.step(0.01);  // 100 Hz\n    }\n\n    engine.shutdown();\n    return 0;\n}\n</code></pre> <p>View more examples \u2192</p>"},{"location":"#project-status","title":"Project Status","text":"Component Status Version Core Engine Stable 0.5.0 Air Domain Stable Complete Land Domain Stable Complete Sea Domain Stable Complete Space Domain Stable Complete XR Integration Stable Complete Cloud Burst Stable Complete Digital Thread Stable Complete Machine Learning Stable Complete GPU Compute Stable Complete Sensors Stable Complete DIS Protocol Stable Complete HLA Protocol Stable Complete Python Bindings Stable 0.5.0 Lua Bindings Stable 0.5.0 <p>Test Coverage: 1150+ unit tests across all modules</p>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>GitHub Issues: Report bugs and request features</li> <li>Discussions: Ask questions and share ideas</li> <li>Contributing: Development guidelines</li> </ul>"},{"location":"#license","title":"License","text":"<p>Copyright \u00a9 2024 JaguarEngine Contributors. All rights reserved.</p> <p>See LICENSE for details.</p>"},{"location":"contributing/","title":"Contributing to JaguarEngine","text":"<p>Thank you for your interest in contributing to JaguarEngine! This guide will help you get started.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>C++20 compatible compiler (GCC 11+, Clang 14+, MSVC 2022)</li> <li>CMake 3.25+</li> <li>Git</li> </ul>"},{"location":"contributing/#setting-up-development-environment","title":"Setting Up Development Environment","text":"<pre><code># Fork and clone the repository\ngit clone https://github.com/jaguarcode/JaguarEngine.git\ncd JaguarEngine\n\n# Create a development branch\ngit checkout -b feature/your-feature-name\n\n# Build with tests enabled\nmkdir build &amp;&amp; cd build\ncmake .. -DJAGUAR_BUILD_TESTS=ON\nmake -j$(nproc)\n\n# Run tests\n./jaguar_unit_tests\n</code></pre>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#1-create-an-issue","title":"1. Create an Issue","text":"<p>Before starting work, create or find an issue describing the change:</p> <ul> <li>Bug reports should include reproduction steps</li> <li>Feature requests should explain the use case</li> <li>Check existing issues to avoid duplicates</li> </ul>"},{"location":"contributing/#2-make-changes","title":"2. Make Changes","text":"<p>Follow these guidelines:</p> <ul> <li>Code Style: Match existing code formatting</li> <li>Naming: Use descriptive names (<code>calculate_drag_force</code>, not <code>calcDF</code>)</li> <li>Comments: Add comments for complex logic</li> <li>Tests: Add tests for new functionality</li> </ul>"},{"location":"contributing/#3-test-your-changes","title":"3. Test Your Changes","text":"<pre><code># Run all tests\n./jaguar_unit_tests\n\n# Run specific test suite\n./jaguar_unit_tests --gtest_filter=TestAir*\n\n# Run benchmarks (optional)\n./jaguar_benchmarks\n</code></pre>"},{"location":"contributing/#4-submit-a-pull-request","title":"4. Submit a Pull Request","text":"<pre><code># Push your branch\ngit push origin feature/your-feature-name\n</code></pre> <p>Then create a pull request on GitHub with:</p> <ul> <li>Clear description of changes</li> <li>Link to related issue</li> <li>Test results</li> </ul>"},{"location":"contributing/#code-style-guidelines","title":"Code Style Guidelines","text":""},{"location":"contributing/#c-conventions","title":"C++ Conventions","text":"<pre><code>// Namespaces: lowercase\nnamespace jaguar::domain::air {\n\n// Classes: PascalCase\nclass AerodynamicsModel {\npublic:\n    // Methods: snake_case\n    void compute_forces(const EntityState&amp; state);\n\n    // Getters: get_prefix\n    Real get_cl() const;\n\n    // Setters: set_prefix\n    void set_reference_area(Real area);\n\nprivate:\n    // Members: trailing underscore\n    Real reference_area_;\n    Real cl_;\n};\n\n// Constants: UPPER_CASE\nconstexpr Real MAX_MACH = 3.0;\n\n// Type aliases: PascalCase\nusing EntityId = uint64_t;\n\n} // namespace jaguar::domain::air\n</code></pre>"},{"location":"contributing/#header-organization","title":"Header Organization","text":"<pre><code>#pragma once\n\n// Standard library\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n// Third-party\n#include &lt;Eigen/Dense&gt;\n\n// Project headers\n#include \"jaguar/core/types.h\"\n#include \"jaguar/physics/entity.h\"\n\nnamespace jaguar {\n// ...\n}\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<pre><code>/// @brief Computes aerodynamic forces and moments\n/// @param state Current entity state (position, velocity, orientation)\n/// @param env Environmental conditions (atmosphere, terrain)\n/// @param dt Time step in seconds\n/// @param[out] forces Accumulated forces and torques\n/// @throws std::runtime_error if state is invalid\nvoid compute_forces(\n    const EntityState&amp; state,\n    const Environment&amp; env,\n    Real dt,\n    EntityForces&amp; forces);\n</code></pre>"},{"location":"contributing/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"contributing/#writing-tests","title":"Writing Tests","text":"<pre><code>#include &lt;gtest/gtest.h&gt;\n#include \"jaguar/domain/air.h\"\n\nclass TestAerodynamics : public ::testing::Test {\nprotected:\n    void SetUp() override {\n        aero_.set_reference_area(30.0);\n        aero_.set_reference_chord(3.0);\n    }\n\n    jaguar::domain::air::AerodynamicsModel aero_;\n};\n\nTEST_F(TestAerodynamics, ComputeLiftCoefficient) {\n    // Arrange\n    jaguar::physics::EntityState state;\n    state.velocity = {100, 0, 5};  // 5\u00b0 angle of attack\n\n    // Act\n    jaguar::physics::EntityForces forces;\n    aero_.compute_forces(state, env_, 0.01, forces);\n\n    // Assert\n    EXPECT_NEAR(aero_.get_cl(), 0.5, 0.01);\n}\n</code></pre>"},{"location":"contributing/#test-categories","title":"Test Categories","text":"Category Location Purpose Unit <code>tests/unit/</code> Individual component testing Integration <code>tests/integration/</code> Component interaction Validation <code>tests/validation/</code> Physics accuracy Benchmark <code>tests/benchmarks/</code> Performance measurement"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":""},{"location":"contributing/#pr-checklist","title":"PR Checklist","text":"<ul> <li> Code follows project style guidelines</li> <li> All existing tests pass</li> <li> New tests added for new functionality</li> <li> Documentation updated if needed</li> <li> No compiler warnings</li> <li> Commit messages are clear</li> </ul>"},{"location":"contributing/#commit-messages","title":"Commit Messages","text":"<pre><code>component: Short description (50 chars max)\n\nLonger explanation if needed. Wrap at 72 characters.\nExplain what and why, not how.\n\nFixes #123\n</code></pre> <p>Examples:</p> <pre><code>air: Add stall model to aerodynamics\n\nImplements post-stall aerodynamic behavior based on\nflat plate theory for angles of attack &gt; 25 degrees.\n\nFixes #42\n</code></pre> <pre><code>tests: Add sea domain buoyancy validation\n\nValidates buoyancy calculation against analytical\nsolution for simple hull shapes.\n</code></pre>"},{"location":"contributing/#architecture-guidelines","title":"Architecture Guidelines","text":""},{"location":"contributing/#adding-a-new-domain","title":"Adding a New Domain","text":"<ol> <li>Create header in <code>include/jaguar/domain/</code></li> <li>Implement in <code>src/domain/</code></li> <li>Add force generators</li> <li>Create unit tests</li> <li>Add example</li> <li>Update documentation</li> </ol>"},{"location":"contributing/#adding-a-force-generator","title":"Adding a Force Generator","text":"<pre><code>// 1. Inherit from IForceGenerator\nclass MyForceModel : public physics::IForceGenerator {\npublic:\n    void compute_forces(\n        const EntityState&amp; state,\n        const Environment&amp; env,\n        Real dt,\n        EntityForces&amp; forces) override;\n};\n\n// 2. Add to appropriate domain\n// 3. Write tests\n// 4. Document parameters\n</code></pre>"},{"location":"contributing/#documentation_1","title":"Documentation","text":""},{"location":"contributing/#updating-docs","title":"Updating Docs","text":"<p>Documentation lives in <code>docs/web/</code>. To preview changes:</p> <pre><code># Install MkDocs\npip install mkdocs-material\n\n# Serve locally\nmkdocs serve\n\n# View at http://localhost:8000\n</code></pre>"},{"location":"contributing/#api-documentation","title":"API Documentation","text":"<p>Use Doxygen comments in headers. Generate with:</p> <pre><code>doxygen docs/Doxyfile\n</code></pre>"},{"location":"contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Questions: Open a Discussion</li> <li>Bugs: Open an Issue</li> <li>Security: Email behonz@gmail.com</li> </ul>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the project's license.</p>"},{"location":"publishing/","title":"Publishing Documentation to the Web","text":"<p>This guide explains how to build and publish the JaguarEngine documentation website.</p>"},{"location":"publishing/#overview","title":"Overview","text":"<p>JaguarEngine documentation can be published using several static site generators:</p> Generator Best For Complexity MkDocs + Material Simple, beautiful docs Easy Docusaurus React-based, feature-rich Medium VitePress Vue-based, fast Medium Doxygen API reference from code Medium <p>This guide focuses on MkDocs with Material theme, the recommended approach.</p>"},{"location":"publishing/#method-1-mkdocs-recommended","title":"Method 1: MkDocs (Recommended)","text":""},{"location":"publishing/#prerequisites","title":"Prerequisites","text":"<pre><code># Install MkDocs and Material theme\npip install mkdocs mkdocs-material\n\n# Optional: Install useful plugins\npip install mkdocs-minify-plugin\npip install mkdocs-git-revision-date-localized-plugin\npip install mkdocs-awesome-pages-plugin\n</code></pre>"},{"location":"publishing/#configuration","title":"Configuration","text":"<p>Create <code>mkdocs.yml</code> in the project root:</p> <pre><code># Project information\nsite_name: JaguarEngine Documentation\nsite_url: https://jaguarcode.github.io/JaguarEngine/\nsite_author: JaguarEngine Contributors\nsite_description: &gt;-\n  Next-generation multi-domain physics simulation platform\n  for defense modeling and simulation applications.\n\n# Repository\nrepo_name: jaguarcode/JaguarEngine\nrepo_url: https://github.com/jaguarcode/JaguarEngine\nedit_uri: edit/main/docs/web/\n\n# Copyright\ncopyright: Copyright &amp;copy; 2024 JaguarEngine Contributors\n\n# Configuration\ntheme:\n  name: material\n  custom_dir: docs/overrides\n  features:\n    - navigation.tabs\n    - navigation.tabs.sticky\n    - navigation.sections\n    - navigation.expand\n    - navigation.path\n    - navigation.top\n    - navigation.footer\n    - search.suggest\n    - search.highlight\n    - search.share\n    - content.tabs.link\n    - content.code.copy\n    - content.code.annotate\n  palette:\n    - scheme: default\n      primary: indigo\n      accent: indigo\n      toggle:\n        icon: material/brightness-7\n        name: Switch to dark mode\n    - scheme: slate\n      primary: indigo\n      accent: indigo\n      toggle:\n        icon: material/brightness-4\n        name: Switch to light mode\n  font:\n    text: Roboto\n    code: Roboto Mono\n  icon:\n    repo: fontawesome/brands/github\n  logo: assets/logo.svg\n  favicon: assets/favicon.png\n\n# Plugins\nplugins:\n  - search:\n      separator: '[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&amp;[lg]t;|(?!\\b)(?=[A-Z][a-z])'\n  - minify:\n      minify_html: true\n\n# Extensions\nmarkdown_extensions:\n  - abbr\n  - admonition\n  - attr_list\n  - def_list\n  - footnotes\n  - md_in_html\n  - toc:\n      permalink: true\n  - pymdownx.arithmatex:\n      generic: true\n  - pymdownx.betterem:\n      smart_enable: all\n  - pymdownx.caret\n  - pymdownx.details\n  - pymdownx.emoji:\n      emoji_index: !!python/name:material.extensions.emoji.twemoji\n      emoji_generator: !!python/name:material.extensions.emoji.to_svg\n  - pymdownx.highlight:\n      anchor_linenums: true\n      line_spans: __span\n      pygments_lang_class: true\n  - pymdownx.inlinehilite\n  - pymdownx.keys\n  - pymdownx.magiclink:\n      repo_url_shorthand: true\n      user: jaguarcode\n      repo: JaguarEngine\n  - pymdownx.mark\n  - pymdownx.smartsymbols\n  - pymdownx.superfences:\n      custom_fences:\n        - name: mermaid\n          class: mermaid\n          format: !!python/name:pymdownx.superfences.fence_code_format\n  - pymdownx.tabbed:\n      alternate_style: true\n  - pymdownx.tasklist:\n      custom_checkbox: true\n  - pymdownx.tilde\n\n# Page tree\nnav:\n  - Home: index.md\n  - Getting Started:\n    - Installation: getting-started/installation.md\n    - Quick Start: getting-started/quickstart.md\n    - First Simulation: getting-started/first-simulation.md\n  - Core Concepts:\n    - Overview: concepts/overview.md\n    - Entities: concepts/entities.md\n    - Coordinate Systems: concepts/coordinates.md\n    - Force Generators: concepts/force-generators.md\n  - Domains:\n    - Air: domains/air.md\n    - Land: domains/land.md\n    - Sea: domains/sea.md\n    - Space: domains/space.md\n  - API Reference:\n    - Overview: api/overview.md\n    - Core: api/core.md\n    - Physics: api/physics.md\n    - Configuration: api/configuration.md\n    - Python: api/python.md\n    - Lua: api/lua.md\n  - Tutorials:\n    - Examples: tutorials/examples.md\n    - Multi-Entity: tutorials/multi-entity.md\n    - Terrain: tutorials/terrain.md\n  - Advanced:\n    - Architecture: advanced/architecture.md\n    - Custom Models: advanced/custom-models.md\n    - Networking: advanced/networking.md\n  - Contributing: contributing.md\n\n# Extra\nextra:\n  version:\n    provider: mike\n  social:\n    - icon: fontawesome/brands/github\n      link: https://github.com/jaguarcode/JaguarEngine\n    - icon: fontawesome/brands/twitter\n      link: https://twitter.com/jaguarengine\n  analytics:\n    provider: google\n    property: G-XXXXXXXXXX\n\nextra_css:\n  - stylesheets/extra.css\n\nextra_javascript:\n  - javascripts/mathjax.js\n  - https://polyfill.io/v3/polyfill.min.js?features=es6\n  - https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\n</code></pre>"},{"location":"publishing/#build-and-preview","title":"Build and Preview","text":"<pre><code># Preview locally (live reload)\nmkdocs serve\n\n# Build static site\nmkdocs build\n\n# Output is in site/ directory\nls site/\n</code></pre>"},{"location":"publishing/#directory-structure","title":"Directory Structure","text":"<pre><code>JaguarEngine/\n\u251c\u2500\u2500 mkdocs.yml              # MkDocs configuration\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 web/                # Documentation source\n\u2502   \u2502   \u251c\u2500\u2500 index.md\n\u2502   \u2502   \u251c\u2500\u2500 getting-started/\n\u2502   \u2502   \u251c\u2500\u2500 concepts/\n\u2502   \u2502   \u251c\u2500\u2500 domains/\n\u2502   \u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u251c\u2500\u2500 tutorials/\n\u2502   \u2502   \u2514\u2500\u2500 advanced/\n\u2502   \u251c\u2500\u2500 overrides/          # Theme customization\n\u2502   \u2502   \u2514\u2500\u2500 main.html\n\u2502   \u2514\u2500\u2500 assets/             # Images, logos\n\u2502       \u251c\u2500\u2500 logo.svg\n\u2502       \u2514\u2500\u2500 favicon.png\n\u2514\u2500\u2500 site/                   # Built output (gitignored)\n</code></pre>"},{"location":"publishing/#method-2-github-pages-deployment","title":"Method 2: GitHub Pages Deployment","text":""},{"location":"publishing/#automatic-deployment-with-github-actions","title":"Automatic Deployment with GitHub Actions","text":"<p>Create <code>.github/workflows/docs.yml</code>:</p> <pre><code>name: Documentation\n\non:\n  push:\n    branches:\n      - main\n    paths:\n      - 'docs/**'\n      - 'mkdocs.yml'\n  pull_request:\n    branches:\n      - main\n    paths:\n      - 'docs/**'\n      - 'mkdocs.yml'\n\npermissions:\n  contents: write\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n\n      - name: Configure Git Credentials\n        run: |\n          git config user.name github-actions[bot]\n          git config user.email 41898282+github-actions[bot]@users.noreply.github.com\n\n      - uses: actions/setup-python@v5\n        with:\n          python-version: 3.x\n\n      - run: echo \"cache_id=$(date --utc '+%V')\" &gt;&gt; $GITHUB_ENV\n\n      - uses: actions/cache@v4\n        with:\n          key: mkdocs-material-${{ env.cache_id }}\n          path: .cache\n          restore-keys: |\n            mkdocs-material-\n\n      - name: Install dependencies\n        run: |\n          pip install mkdocs-material\n          pip install mkdocs-minify-plugin\n\n      - name: Deploy to GitHub Pages\n        if: github.event_name != 'pull_request'\n        run: mkdocs gh-deploy --force\n\n      - name: Build (PR preview)\n        if: github.event_name == 'pull_request'\n        run: mkdocs build\n</code></pre>"},{"location":"publishing/#enable-github-pages","title":"Enable GitHub Pages","text":"<ol> <li>Go to repository Settings &gt; Pages</li> <li>Set Source to \"Deploy from a branch\"</li> <li>Set Branch to <code>gh-pages</code> / <code>/ (root)</code></li> <li>Save</li> </ol> <p>Your documentation will be available at: <code>https://jaguarcode.github.io/JaguarEngine/</code></p>"},{"location":"publishing/#method-3-vercel-deployment","title":"Method 3: Vercel Deployment","text":""},{"location":"publishing/#setup","title":"Setup","text":"<ol> <li>Connect your GitHub repository to Vercel</li> <li>Configure build settings:</li> </ol> <pre><code>{\n  \"buildCommand\": \"pip install mkdocs-material &amp;&amp; mkdocs build\",\n  \"outputDirectory\": \"site\",\n  \"installCommand\": \"pip install mkdocs mkdocs-material\"\n}\n</code></pre>"},{"location":"publishing/#verceljson","title":"vercel.json","text":"<pre><code>{\n  \"version\": 2,\n  \"builds\": [\n    {\n      \"src\": \"mkdocs.yml\",\n      \"use\": \"@vercel/static-build\",\n      \"config\": {\n        \"distDir\": \"site\"\n      }\n    }\n  ],\n  \"routes\": [\n    {\n      \"src\": \"/(.*)\",\n      \"dest\": \"/$1\"\n    }\n  ]\n}\n</code></pre>"},{"location":"publishing/#method-4-netlify-deployment","title":"Method 4: Netlify Deployment","text":""},{"location":"publishing/#netlifytoml","title":"netlify.toml","text":"<pre><code>[build]\n  command = \"pip install mkdocs-material mkdocs-minify-plugin &amp;&amp; mkdocs build\"\n  publish = \"site\"\n\n[build.environment]\n  PYTHON_VERSION = \"3.11\"\n\n[[redirects]]\n  from = \"/*\"\n  to = \"/index.html\"\n  status = 200\n</code></pre>"},{"location":"publishing/#doxygen-integration","title":"Doxygen Integration","text":"<p>Generate API documentation from code comments:</p>"},{"location":"publishing/#docsdoxyfile","title":"docs/Doxyfile","text":"<pre><code>PROJECT_NAME           = \"JaguarEngine\"\nPROJECT_NUMBER         = 0.4.0\nPROJECT_BRIEF          = \"Multi-Domain Physics Simulation\"\nOUTPUT_DIRECTORY       = docs/api-reference\nINPUT                  = include/jaguar\nRECURSIVE              = YES\nEXTRACT_ALL            = YES\nGENERATE_HTML          = YES\nGENERATE_LATEX         = NO\nHTML_OUTPUT            = html\nUSE_MDFILE_AS_MAINPAGE = docs/pages/mainpage.md\n</code></pre>"},{"location":"publishing/#generate-and-integrate","title":"Generate and Integrate","text":"<pre><code># Generate Doxygen output\ndoxygen docs/Doxyfile\n\n# Link from MkDocs\n# Add to mkdocs.yml nav:\n# - API Reference: api-reference/html/index.html\n</code></pre>"},{"location":"publishing/#custom-styling","title":"Custom Styling","text":""},{"location":"publishing/#docsstylesheetsextracss","title":"docs/stylesheets/extra.css","text":"<pre><code>/* Custom primary color */\n:root {\n  --md-primary-fg-color: #1a237e;\n  --md-primary-fg-color--light: #3949ab;\n  --md-primary-fg-color--dark: #0d1642;\n}\n\n/* Hero section styling */\n.hero {\n  text-align: center;\n  padding: 2rem;\n  background: linear-gradient(135deg, #1a237e 0%, #3949ab 100%);\n  color: white;\n  border-radius: 8px;\n  margin-bottom: 2rem;\n}\n\n.hero h1 {\n  font-size: 3rem;\n  margin-bottom: 0.5rem;\n}\n\n.tagline {\n  font-size: 1.5rem;\n  opacity: 0.9;\n}\n\n/* Feature grid */\n.features {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\n  gap: 1.5rem;\n  margin: 2rem 0;\n}\n\n.features h3 {\n  color: var(--md-primary-fg-color);\n}\n\n/* Code blocks */\n.highlight pre {\n  border-radius: 8px;\n}\n\n/* Tables */\n.md-typeset table:not([class]) {\n  border-collapse: collapse;\n  border-radius: 8px;\n  overflow: hidden;\n}\n</code></pre>"},{"location":"publishing/#version-management","title":"Version Management","text":"<p>Use <code>mike</code> for versioned documentation:</p> <pre><code># Install mike\npip install mike\n\n# Deploy version\nmike deploy --push --update-aliases 0.4.0 latest\n\n# Set default version\nmike set-default --push latest\n\n# List versions\nmike list\n</code></pre> <p>Update <code>mkdocs.yml</code>:</p> <pre><code>extra:\n  version:\n    provider: mike\n</code></pre>"},{"location":"publishing/#checklist-for-publishing","title":"Checklist for Publishing","text":"<ul> <li> Create <code>mkdocs.yml</code> configuration</li> <li> Organize documentation in <code>docs/web/</code></li> <li> Add logo and favicon to <code>docs/assets/</code></li> <li> Create custom CSS in <code>docs/stylesheets/extra.css</code></li> <li> Set up GitHub Actions for automatic deployment</li> <li> Enable GitHub Pages in repository settings</li> <li> Configure custom domain (optional)</li> <li> Add Google Analytics (optional)</li> <li> Set up versioning with <code>mike</code> (optional)</li> <li> Test build locally with <code>mkdocs serve</code></li> <li> Review all pages for broken links</li> <li> Verify code examples are correct</li> <li> Add search functionality</li> <li> Test on mobile devices</li> </ul>"},{"location":"publishing/#quick-start-commands","title":"Quick Start Commands","text":"<pre><code># Install tools\npip install mkdocs mkdocs-material\n\n# Preview locally\nmkdocs serve\n\n# Build\nmkdocs build\n\n# Deploy to GitHub Pages\nmkdocs gh-deploy\n\n# Deploy versioned docs\nmike deploy 0.4.0 latest --push\n</code></pre>"},{"location":"publishing/#troubleshooting","title":"Troubleshooting","text":""},{"location":"publishing/#build-fails","title":"Build Fails","text":"<pre><code># Check for syntax errors\nmkdocs build --strict\n\n# Verbose output\nmkdocs build -v\n</code></pre>"},{"location":"publishing/#missing-pages","title":"Missing Pages","text":"<p>Ensure all pages in <code>nav:</code> section of <code>mkdocs.yml</code> exist in <code>docs/web/</code>.</p>"},{"location":"publishing/#broken-links","title":"Broken Links","text":"<p>Use the <code>mkdocs-redirects</code> plugin:</p> <pre><code>plugins:\n  - redirects:\n      redirect_maps:\n        'old-page.md': 'new-page.md'\n</code></pre>"},{"location":"publishing/#github-pages-not-updating","title":"GitHub Pages Not Updating","text":"<ol> <li>Check GitHub Actions workflow status</li> <li>Verify <code>gh-pages</code> branch exists</li> <li>Clear browser cache</li> <li>Wait a few minutes for propagation</li> </ol>"},{"location":"publishing/#resources","title":"Resources","text":"<ul> <li>MkDocs Documentation</li> <li>Material for MkDocs</li> <li>GitHub Pages</li> <li>Doxygen Manual</li> </ul>"},{"location":"advanced/architecture/","title":"Architecture Overview","text":"<p>This document provides a comprehensive overview of JaguarEngine's system architecture, design patterns, and internal structure.</p>"},{"location":"advanced/architecture/#system-overview","title":"System Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         EXTERNAL INTERFACES                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502   Python    \u2502  \u2502    Lua      \u2502  \u2502  DIS/HLA    \u2502  \u2502     CIG     \u2502    \u2502\n\u2502  \u2502  (pybind11) \u2502  \u2502   (sol2)    \u2502  \u2502  Network    \u2502  \u2502 (UE/Unity)  \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502                \u2502                \u2502                \u2502\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         PUBLIC API LAYER                                \u2502\n\u2502                      jaguar::Engine (Facade)                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    PHYSICS ENGINE EXECUTIVE                             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502                    PhysicsEngineExec                              \u2502  \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502  \u2502\n\u2502  \u2502  \u2502  Entity    \u2502 \u2502  Physics   \u2502 \u2502  Property  \u2502 \u2502   Time     \u2502    \u2502  \u2502\n\u2502  \u2502  \u2502  Manager   \u2502 \u2502  System    \u2502 \u2502  Manager   \u2502 \u2502  Manager   \u2502    \u2502  \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        DOMAIN PHYSICS LAYER                             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n\u2502  \u2502     AIR     \u2502 \u2502    LAND     \u2502 \u2502     SEA     \u2502 \u2502    SPACE    \u2502      \u2502\n\u2502  \u2502 Aerodynamics\u2502 \u2502Terramechanics\u2502 \u2502Hydrodynamics\u2502 \u2502  Astrodynamics\u2502    \u2502\n\u2502  \u2502 Propulsion  \u2502 \u2502 Suspension  \u2502 \u2502  Buoyancy   \u2502 \u2502   Gravity   \u2502      \u2502\n\u2502  \u2502 FCS/Autopilot\u2502 \u2502   MBS      \u2502 \u2502    RAO      \u2502 \u2502  SGP4/SDP4  \u2502      \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      ENVIRONMENT SERVICES                               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u2502\n\u2502  \u2502     TERRAIN     \u2502 \u2502   ATMOSPHERE    \u2502 \u2502      OCEAN      \u2502          \u2502\n\u2502  \u2502   Digital Twin  \u2502 \u2502  US Std 1976    \u2502 \u2502 Wave Spectrum   \u2502          \u2502\n\u2502  \u2502   GDAL/GIS      \u2502 \u2502  JBH08 (Space)  \u2502 \u2502 PM/JONSWAP      \u2502          \u2502\n\u2502  \u2502   Quadtree LOD  \u2502 \u2502  MODTRAN LUT    \u2502 \u2502 Sea State       \u2502          \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         CORE SERVICES                                   \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502  Memory  \u2502 \u2502 Threading\u2502 \u2502   Math   \u2502 \u2502   I/O    \u2502 \u2502  Config  \u2502    \u2502\n\u2502  \u2502  Pools   \u2502 \u2502Work-Steal\u2502 \u2502   SIMD   \u2502 \u2502  Async   \u2502 \u2502   XML    \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"advanced/architecture/#design-principles","title":"Design Principles","text":""},{"location":"advanced/architecture/#data-oriented-design-dod","title":"Data-Oriented Design (DOD)","text":"<p>JaguarEngine uses Structure of Arrays (SoA) memory layout for optimal cache utilization:</p> <pre><code>// Traditional OOP (Array of Structures) - poor cache utilization\nstruct Entity { Vec3 pos; Vec3 vel; Quat ori; Real mass; };\nstd::vector&lt;Entity&gt; entities;\n\n// JaguarEngine (Structure of Arrays) - excellent cache utilization\nstruct EntityStorage {\n    std::vector&lt;Vec3&gt; positions;    // Contiguous\n    std::vector&lt;Vec3&gt; velocities;   // Contiguous\n    std::vector&lt;Quat&gt; orientations; // Contiguous\n    std::vector&lt;Real&gt; masses;       // Contiguous\n};\n</code></pre> <p>Performance Benefits:</p> Pattern Cache Miss Rate Relative Speed AoS (random) ~80% 1.0x AoS (sequential) ~40% 2.5x SoA ~5% 8-15x"},{"location":"advanced/architecture/#component-based-physics","title":"Component-Based Physics","text":"<p>Modular force generators are attached to entities:</p> <ul> <li>Aerodynamics: Coefficient-based lookup tables</li> <li>Propulsion: Thrust curves with altitude/Mach corrections</li> <li>Terramechanics: Bekker-Wong soil interaction</li> <li>Hydrodynamics: MMG maneuvering model</li> <li>Gravity: Point mass to EGM2008 fidelity levels</li> </ul>"},{"location":"advanced/architecture/#property-system","title":"Property System","text":"<p>Hierarchical key-value access for runtime configuration (JSBSim-inspired):</p> <pre><code>aircraft/f16/aero/cl_alpha     \u2192 Lift curve slope\nvehicle/m1a2/terra/sinkage     \u2192 Terrain sinkage (m)\nvessel/ddg51/hydro/draft       \u2192 Current draft (m)\nsatellite/gps01/orbit/altitude \u2192 Orbital altitude (km)\n</code></pre>"},{"location":"advanced/architecture/#core-subsystems","title":"Core Subsystems","text":""},{"location":"advanced/architecture/#physicsengineexec","title":"PhysicsEngineExec","text":"<p>The central coordinator responsible for simulation lifecycle management:</p> <ul> <li>Initialize and configure all subsystems</li> <li>Execute the main simulation loop</li> <li>Coordinate time advancement across all entities</li> <li>Manage module registration and discovery</li> </ul>"},{"location":"advanced/architecture/#entity-management","title":"Entity Management","text":"<p>Entities are lightweight identifiers; data lives in contiguous arrays:</p> <pre><code>struct Entity {\n    EntityId id;              // Unique identifier\n    ComponentMask components; // Bitfield of attached components\n    Domain primary_domain;    // Primary physics domain\n    PropertyNode* properties; // Property tree root\n};\n</code></pre>"},{"location":"advanced/architecture/#time-management","title":"Time Management","text":"Mode Description Use Case Real-Time 1s sim = 1s wall Training, HiL Accelerated N\u00d7s sim = 1s wall Analysis, Monte Carlo Stepped Manual advance Debugging, Scripting"},{"location":"advanced/architecture/#threading-model","title":"Threading Model","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Main Thread                               \u2502\n\u2502  \u2022 Input processing                                         \u2502\n\u2502  \u2022 Script execution                                         \u2502\n\u2502  \u2022 Network I/O dispatch                                     \u2502\n\u2502  \u2022 Frame synchronization                                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502 Job dispatch\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 Physics Thread Pool                          \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502\n\u2502  \u2502Worker 0 \u2502 \u2502Worker 1 \u2502 \u2502Worker 2 \u2502 \u2502Worker N \u2502           \u2502\n\u2502  \u2502   \u2190Work Stealing\u2192   \u2502 \u2502   \u2190Work Stealing\u2192   \u2502           \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 I/O Thread Pool                              \u2502\n\u2502  \u2022 Terrain tile loading (GDAL)                              \u2502\n\u2502  \u2022 Network PDU send/receive                                 \u2502\n\u2502  \u2022 File I/O operations                                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"advanced/architecture/#coordinate-systems","title":"Coordinate Systems","text":""},{"location":"advanced/architecture/#supported-frames","title":"Supported Frames","text":"Frame Origin Use Case ECEF Earth center Global positioning, geodetic reference ECI J2000 Earth center Orbital mechanics NED Local origin Aircraft, ground vehicles Body Entity CG Entity-specific calculations"},{"location":"advanced/architecture/#64-bit-precision","title":"64-bit Precision","text":"<p>Double-precision floating point is used throughout for geodetic accuracy, ensuring sub-meter precision for global positioning.</p>"},{"location":"advanced/architecture/#network-interfaces","title":"Network Interfaces","text":""},{"location":"advanced/architecture/#dis-protocol-ieee-1278","title":"DIS Protocol (IEEE 1278)","text":"PDU Type Direction Purpose Entity State TX/RX Position, velocity, orientation Fire TX/RX Weapon discharge Detonation TX/RX Impact/explosion"},{"location":"advanced/architecture/#hla-interface-ieee-1516","title":"HLA Interface (IEEE 1516)","text":"<p>Supports RPR FOM 2.0 with object classes:</p> <ul> <li>BaseEntity.PhysicalEntity</li> <li>Platform.Aircraft/GroundVehicle/SurfaceVessel/Spacecraft</li> <li>Munition</li> </ul>"},{"location":"advanced/architecture/#technology-stack","title":"Technology Stack","text":"Component Library Version Purpose Build CMake 3.25+ Cross-platform build Compiler C++20 - Language standard Math Eigen 3.4+ Linear algebra GIS GDAL 3.6+ Geospatial data XML pugixml 1.13+ Configuration parsing Testing GoogleTest 1.14+ Unit testing"},{"location":"advanced/architecture/#see-also","title":"See Also","text":"<ul> <li>Custom Models - Creating custom physics models</li> <li>Network Integration - DIS/HLA networking</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"advanced/custom-models/","title":"Custom Physics Models","text":"<p>This guide explains how to create custom physics models and extend JaguarEngine's capabilities.</p>"},{"location":"advanced/custom-models/#overview","title":"Overview","text":"<p>JaguarEngine's component-based architecture allows you to create custom force generators, integrators, and domain-specific models by implementing standard interfaces.</p>"},{"location":"advanced/custom-models/#force-generator-interface","title":"Force Generator Interface","text":"<p>All physics models implement the <code>IForceGenerator</code> interface:</p> <pre><code>class IForceGenerator {\npublic:\n    virtual void compute_forces(const EntityState&amp; state,\n                                const environment::Environment&amp; env,\n                                Real dt,\n                                EntityForces&amp; forces) = 0;\n};\n</code></pre>"},{"location":"advanced/custom-models/#creating-a-custom-aerodynamics-model","title":"Creating a Custom Aerodynamics Model","text":""},{"location":"advanced/custom-models/#step-1-implement-the-interface","title":"Step 1: Implement the Interface","text":"<pre><code>#include &lt;jaguar/physics/force.h&gt;\n\nclass CustomAeroModel : public physics::IAerodynamicsModel {\npublic:\n    // Configuration\n    void set_reference_area(Real area) { ref_area_ = area; }\n    void set_reference_chord(Real chord) { ref_chord_ = chord; }\n    void set_reference_span(Real span) { ref_span_ = span; }\n\n    // IForceGenerator implementation\n    void compute_forces(const physics::EntityState&amp; state,\n                        const environment::Environment&amp; env,\n                        Real dt,\n                        physics::EntityForces&amp; forces) override {\n        // Compute aerodynamic angles\n        Vec3 vel_body = transform_to_body(state.velocity, state.orientation);\n        Real V = vel_body.norm();\n\n        if (V &lt; 1.0) return;  // Minimum airspeed threshold\n\n        alpha_ = std::atan2(vel_body.z, vel_body.x);\n        beta_ = std::asin(vel_body.y / V);\n        mach_ = V / env.atmosphere.speed_of_sound;\n        qbar_ = 0.5 * env.atmosphere.density * V * V;\n\n        // Compute coefficients\n        compute_coefficients();\n\n        // Apply forces\n        Real L = qbar_ * ref_area_ * cl_;\n        Real D = qbar_ * ref_area_ * cd_;\n        Real M = qbar_ * ref_area_ * ref_chord_ * cm_;\n\n        // Transform to body frame and add to forces\n        forces.add_force(transform_aero_forces(L, D, alpha_));\n        forces.add_torque(Vec3{0, M, 0});\n    }\n\n    // IAerodynamicsModel queries\n    Real get_cl() const override { return cl_; }\n    Real get_cd() const override { return cd_; }\n    Real get_cm() const override { return cm_; }\n    Real get_alpha() const override { return alpha_; }\n    Real get_beta() const override { return beta_; }\n    Real get_mach() const override { return mach_; }\n    Real get_qbar() const override { return qbar_; }\n\nprivate:\n    void compute_coefficients() {\n        // Your custom coefficient model here\n        cl_ = 5.5 * alpha_;  // Example: linear lift curve\n        cd_ = 0.02 + cl_ * cl_ / (3.14159 * 8.0 * 0.85);  // Drag polar\n        cm_ = -0.5 * alpha_;  // Pitching moment\n    }\n\n    Real ref_area_{1.0}, ref_chord_{1.0}, ref_span_{1.0};\n    Real alpha_{0}, beta_{0}, mach_{0}, qbar_{0};\n    Real cl_{0}, cd_{0}, cm_{0};\n};\n</code></pre>"},{"location":"advanced/custom-models/#step-2-register-and-use","title":"Step 2: Register and Use","text":"<pre><code>// Create entity\nEntityId aircraft = engine.create_entity(\"CustomAircraft\", Domain::Air);\n\n// Create and configure custom model\nauto aero = std::make_unique&lt;CustomAeroModel&gt;();\naero-&gt;set_reference_area(27.87);\naero-&gt;set_reference_chord(3.45);\naero-&gt;set_reference_span(9.45);\n\n// Use in simulation loop\nphysics::EntityForces forces;\nauto state = engine.get_entity_state(aircraft);\nauto env = engine.get_environment(aircraft);\n\nforces.clear();\naero-&gt;compute_forces(state, env, dt, forces);\nengine.apply_forces(aircraft, forces);\n</code></pre>"},{"location":"advanced/custom-models/#creating-custom-terramechanics","title":"Creating Custom Terramechanics","text":"<pre><code>class CustomTerraModel : public physics::ITerramechanicsModel {\npublic:\n    void set_contact_dimensions(Real width, Real length) {\n        contact_width_ = width;\n        contact_length_ = length;\n    }\n\n    void compute_forces(const physics::EntityState&amp; state,\n                        const environment::Environment&amp; env,\n                        Real dt,\n                        physics::EntityForces&amp; forces) override {\n        // Check if on ground\n        Real height = env.altitude - env.terrain_elevation;\n        if (height &gt; 0.1) return;\n\n        // Get soil properties\n        auto soil = env.terrain.material.get_soil_properties();\n\n        // Bekker-Wong pressure-sinkage\n        Real pressure = state.mass * constants::G0 /\n                       (contact_width_ * contact_length_);\n        Real sinkage = compute_sinkage(pressure, soil);\n\n        // Motion resistance\n        Real resistance = compute_resistance(sinkage, soil);\n\n        // Traction\n        Real traction = compute_traction(soil, pressure);\n\n        // Apply forces\n        forces.add_force(Vec3{traction - resistance, 0, 0});\n\n        sinkage_ = sinkage;\n        resistance_ = resistance;\n        traction_ = traction;\n    }\n\n    Real get_sinkage() const override { return sinkage_; }\n    Real get_motion_resistance() const override { return resistance_; }\n    Real get_traction() const override { return traction_; }\n    Real get_slip_ratio() const override { return slip_; }\n\nprivate:\n    Real compute_sinkage(Real pressure, const SoilProperties&amp; soil) {\n        // p = (k_c/b + k_phi) * z^n\n        // z = (p / (k_c/b + k_phi))^(1/n)\n        Real k = soil.k_c / contact_width_ + soil.k_phi;\n        return std::pow(pressure / k, 1.0 / soil.n);\n    }\n\n    Real compute_resistance(Real sinkage, const SoilProperties&amp; soil) {\n        Real k = soil.k_c / contact_width_ + soil.k_phi;\n        return contact_width_ * contact_length_ * k *\n               std::pow(sinkage, soil.n + 1) / (soil.n + 1);\n    }\n\n    Real compute_traction(const SoilProperties&amp; soil, Real pressure) {\n        // Mohr-Coulomb: tau_max = c + sigma * tan(phi)\n        Real tau_max = soil.c + pressure * std::tan(soil.phi);\n        return tau_max * contact_width_ * contact_length_;\n    }\n\n    Real contact_width_{0.5}, contact_length_{4.0};\n    Real sinkage_{0}, resistance_{0}, traction_{0}, slip_{0};\n};\n</code></pre>"},{"location":"advanced/custom-models/#xml-configuration-for-custom-models","title":"XML Configuration for Custom Models","text":"<p>You can load custom model parameters from XML:</p> <pre><code>&lt;entity type=\"aircraft\" name=\"CustomAircraft\"&gt;\n    &lt;aerodynamics model=\"custom\"&gt;\n        &lt;reference_area unit=\"m2\"&gt;27.87&lt;/reference_area&gt;\n        &lt;reference_chord unit=\"m\"&gt;3.45&lt;/reference_chord&gt;\n        &lt;reference_span unit=\"m\"&gt;9.45&lt;/reference_span&gt;\n\n        &lt;custom_parameters&gt;\n            &lt;cl_alpha&gt;5.5&lt;/cl_alpha&gt;\n            &lt;cd_0&gt;0.02&lt;/cd_0&gt;\n            &lt;oswald_efficiency&gt;0.85&lt;/oswald_efficiency&gt;\n        &lt;/custom_parameters&gt;\n    &lt;/aerodynamics&gt;\n&lt;/entity&gt;\n</code></pre>"},{"location":"advanced/custom-models/#creating-custom-integrators","title":"Creating Custom Integrators","text":"<pre><code>class CustomIntegrator : public IStatePropagator {\npublic:\n    void propagate(EntityState&amp; state,\n                   const EntityForces&amp; forces,\n                   Real dt) override {\n        // Your custom integration scheme\n        // Example: Semi-implicit Euler\n        Vec3 accel = forces.force / state.mass;\n        state.velocity += accel * dt;\n        state.position += state.velocity * dt;\n\n        // Angular dynamics\n        Vec3 angular_accel = state.inertia.inverse() *\n                            (forces.torque - state.angular_velocity.cross(\n                             state.inertia * state.angular_velocity));\n        state.angular_velocity += angular_accel * dt;\n\n        // Quaternion integration\n        Quaternion omega_quat{0,\n            state.angular_velocity.x,\n            state.angular_velocity.y,\n            state.angular_velocity.z};\n        state.orientation = (state.orientation +\n            state.orientation * omega_quat * 0.5 * dt).normalized();\n    }\n};\n</code></pre>"},{"location":"advanced/custom-models/#best-practices","title":"Best Practices","text":""},{"location":"advanced/custom-models/#performance","title":"Performance","text":"<ol> <li>Cache intermediate results: Store computed values that are used multiple times</li> <li>Use SIMD operations: Leverage vectorized math where possible</li> <li>Minimize allocations: Pre-allocate buffers in constructors</li> </ol>"},{"location":"advanced/custom-models/#numerical-stability","title":"Numerical Stability","text":"<ol> <li>Set minimum thresholds: Avoid division by zero with velocity checks</li> <li>Clamp outputs: Limit coefficients to physical ranges</li> <li>Use appropriate precision: Double precision for geodetic calculations</li> </ol>"},{"location":"advanced/custom-models/#testing","title":"Testing","text":"<pre><code>TEST(CustomAeroModel, LiftCoefficientLinear) {\n    CustomAeroModel model;\n    model.set_reference_area(10.0);\n\n    physics::EntityState state;\n    state.velocity = Vec3{100.0, 0.0, 5.0};  // Small alpha\n\n    environment::Environment env;\n    env.atmosphere.density = 1.225;\n    env.atmosphere.speed_of_sound = 340.0;\n\n    physics::EntityForces forces;\n    model.compute_forces(state, env, 0.01, forces);\n\n    EXPECT_NEAR(model.get_alpha(), 0.05, 0.001);\n    EXPECT_GT(model.get_cl(), 0.0);\n}\n</code></pre>"},{"location":"advanced/custom-models/#see-also","title":"See Also","text":"<ul> <li>Architecture - System architecture overview</li> <li>API Reference - Core API documentation</li> <li>Examples - Complete code examples</li> </ul>"},{"location":"advanced/networking/","title":"Network Integration","text":"<p>This guide covers JaguarEngine's network interfaces for distributed simulation, including DIS (Distributed Interactive Simulation) and HLA (High Level Architecture).</p>"},{"location":"advanced/networking/#overview","title":"Overview","text":"<p>JaguarEngine provides complete implementations of industry-standard networking protocols for Live-Virtual-Constructive (LVC) integration:</p> Protocol Standard Status Use Case DIS IEEE 1278.1-2012 Complete Real-time entity state exchange HLA IEEE 1516-2010 Complete Federation-based distributed simulation <p>Both protocols are fully implemented with: - Complete PDU/interaction support - Dead reckoning algorithms - Time management - Ownership management (HLA) - Data Distribution Management (HLA DDM)</p> <p>For detailed API reference, see Federation API.</p>"},{"location":"advanced/networking/#dis-protocol","title":"DIS Protocol","text":""},{"location":"advanced/networking/#configuration","title":"Configuration","text":"<p>Enable DIS in the engine configuration:</p> <pre><code>&lt;engine_config&gt;\n    &lt;network&gt;\n        &lt;dis enabled=\"true\"&gt;\n            &lt;port&gt;3000&lt;/port&gt;\n            &lt;site_id&gt;1&lt;/site_id&gt;\n            &lt;app_id&gt;1&lt;/app_id&gt;\n            &lt;exercise_id&gt;1&lt;/exercise_id&gt;\n        &lt;/dis&gt;\n    &lt;/network&gt;\n&lt;/engine_config&gt;\n</code></pre>"},{"location":"advanced/networking/#supported-pdus","title":"Supported PDUs","text":"PDU Type Direction Purpose Entity State TX/RX Position, velocity, orientation Fire TX/RX Weapon discharge events Detonation TX/RX Impact and explosion events Collision TX Physical contact detection Start/Resume RX Simulation control Stop/Freeze RX Simulation control"},{"location":"advanced/networking/#c-api","title":"C++ API","text":"<pre><code>#include &lt;jaguar/network/dis.h&gt;\n\n// Configure DIS\njaguar::network::DISConfig dis_cfg;\ndis_cfg.enabled = true;\ndis_cfg.port = 3000;\ndis_cfg.site_id = 1;\ndis_cfg.app_id = 1;\n\n// Initialize DIS interface\njaguar::network::DISInterface dis;\ndis.initialize(dis_cfg);\n\n// Register entity for DIS publication\nEntityId aircraft = engine.create_entity(\"F16\", Domain::Air);\ndis.register_entity(aircraft, DISEntityType::Aircraft);\n\n// In simulation loop\nwhile (running) {\n    engine.step(dt);\n\n    // Publish entity states\n    dis.publish_entity_states();\n\n    // Process incoming PDUs\n    dis.process_received_pdus();\n\n    // Handle fire events\n    if (dis.has_fire_events()) {\n        for (const auto&amp; fire : dis.get_fire_events()) {\n            handle_fire_event(fire);\n        }\n    }\n}\n\ndis.shutdown();\n</code></pre>"},{"location":"advanced/networking/#entity-type-mapping","title":"Entity Type Mapping","text":"<pre><code>// Configure entity type for DIS\nDISEntityType entity_type;\nentity_type.kind = 1;        // Platform\nentity_type.domain = 2;      // Air\nentity_type.country = 225;   // USA\nentity_type.category = 1;    // Fighter\nentity_type.subcategory = 2; // F-16\n\ndis.set_entity_type(aircraft, entity_type);\n</code></pre>"},{"location":"advanced/networking/#hla-interface","title":"HLA Interface","text":""},{"location":"advanced/networking/#configuration_1","title":"Configuration","text":"<pre><code>&lt;engine_config&gt;\n    &lt;network&gt;\n        &lt;hla enabled=\"true\"&gt;\n            &lt;federation&gt;ExampleFederation&lt;/federation&gt;\n            &lt;federate&gt;JaguarEngine&lt;/federate&gt;\n            &lt;fom&gt;RPR_FOM_v2.0.xml&lt;/fom&gt;\n            &lt;rti&gt;Portico&lt;/rti&gt;\n        &lt;/hla&gt;\n    &lt;/network&gt;\n&lt;/engine_config&gt;\n</code></pre>"},{"location":"advanced/networking/#rpr-fom-object-classes","title":"RPR FOM Object Classes","text":"<p>JaguarEngine supports RPR FOM 2.0 object classes:</p> <ul> <li><code>BaseEntity.PhysicalEntity</code></li> <li><code>Platform.Aircraft</code></li> <li><code>Platform.GroundVehicle</code></li> <li><code>Platform.SurfaceVessel</code></li> <li><code>Platform.Spacecraft</code></li> <li><code>Munition</code></li> </ul>"},{"location":"advanced/networking/#interaction-classes","title":"Interaction Classes","text":"<ul> <li><code>WeaponFire</code> - Weapon discharge events</li> <li><code>MunitionDetonation</code> - Impact and explosion events</li> <li><code>RadioSignal</code> - Communication events</li> </ul>"},{"location":"advanced/networking/#c-api_1","title":"C++ API","text":"<pre><code>#include &lt;jaguar/network/hla.h&gt;\n\n// Configure HLA\njaguar::network::HLAConfig hla_cfg;\nhla_cfg.enabled = true;\nhla_cfg.federation = \"ExampleFederation\";\nhla_cfg.federate = \"JaguarEngine\";\nhla_cfg.fom_path = \"RPR_FOM_v2.0.xml\";\n\n// Initialize HLA federate\njaguar::network::HLAFederate federate;\nfederate.initialize(hla_cfg);\n\n// Join federation\nfederate.join_federation();\n\n// Register object classes\nfederate.subscribe_object_class(\"Platform.Aircraft\");\nfederate.publish_object_class(\"Platform.Aircraft\");\n\n// Register entity as HLA object\nEntityId aircraft = engine.create_entity(\"F16\", Domain::Air);\nauto hla_handle = federate.register_object(aircraft, \"Platform.Aircraft\");\n\n// In simulation loop\nwhile (running) {\n    engine.step(dt);\n\n    // Update HLA attributes\n    federate.update_attributes();\n\n    // Process reflections\n    federate.tick();\n\n    // Handle discovered objects\n    for (const auto&amp; obj : federate.get_discovered_objects()) {\n        create_remote_entity(obj);\n    }\n}\n\n// Leave federation\nfederate.resign();\nfederate.shutdown();\n</code></pre>"},{"location":"advanced/networking/#time-management","title":"Time Management","text":"<pre><code>// Enable time management\nfederate.enable_time_regulation(lookahead);\nfederate.enable_time_constrained();\n\n// Advance time\nwhile (running) {\n    federate.request_time_advance(current_time + dt);\n\n    // Wait for grant\n    while (!federate.is_time_granted()) {\n        federate.tick();\n    }\n\n    engine.step(dt);\n}\n</code></pre>"},{"location":"advanced/networking/#dead-reckoning","title":"Dead Reckoning","text":"<p>JaguarEngine implements dead reckoning algorithms for bandwidth optimization:</p> <pre><code>// Configure dead reckoning\nDeadReckoningConfig dr_cfg;\ndr_cfg.algorithm = DeadReckoningAlgorithm::DRM_FPW;  // Fixed velocity\ndr_cfg.position_threshold = 1.0;   // meters\ndr_cfg.orientation_threshold = 0.05;  // radians\n\ndis.set_dead_reckoning(aircraft, dr_cfg);\n\n// Entity state PDUs are only sent when thresholds are exceeded\n</code></pre>"},{"location":"advanced/networking/#supported-algorithms","title":"Supported Algorithms","text":"<p>JaguarEngine implements all IEEE 1278.1-2012 dead reckoning algorithms:</p> Algorithm Description DRM_Static Static entity (no extrapolation) DRM_FPW Fixed position, world coordinates DRM_RPW Rotating position, world coordinates DRM_RVW Rotating velocity, world coordinates DRM_FVW Fixed velocity, world coordinates DRM_FPB Fixed position, body coordinates DRM_RPB Rotating position, body coordinates DRM_RVB Rotating velocity, body coordinates DRM_FVB Fixed velocity, body coordinates DRM_*_HighRes High-resolution variants of above (IEEE 1278.1-2012)"},{"location":"advanced/networking/#python-api","title":"Python API","text":"<pre><code>import pyjaguar as jag\n\n# Create engine with DIS\nconfig = jag.EngineConfig()\nconfig.dis_enabled = True\nconfig.dis_port = 3000\nconfig.dis_site_id = 1\nconfig.dis_app_id = 1\n\nengine = jag.Engine()\nengine.initialize(config)\n\n# Create entity\naircraft = engine.create_entity(\"F16\", jag.Domain.Air)\n\n# Run with network\nwhile running:\n    engine.step(0.01)\n    # DIS PDUs are automatically exchanged\n\nengine.shutdown()\n</code></pre>"},{"location":"advanced/networking/#best-practices","title":"Best Practices","text":""},{"location":"advanced/networking/#performance","title":"Performance","text":"<ol> <li>Use dead reckoning: Reduces network traffic by 80-90%</li> <li>Batch updates: Group attribute updates where possible</li> <li>Filter subscriptions: Only subscribe to needed object classes</li> </ol>"},{"location":"advanced/networking/#reliability","title":"Reliability","text":"<ol> <li>Handle disconnections: Implement reconnection logic</li> <li>Validate incoming data: Check for invalid states</li> <li>Log network events: Enable debug logging for troubleshooting</li> </ol>"},{"location":"advanced/networking/#interoperability","title":"Interoperability","text":"<ol> <li>Follow FOM conventions: Use standard attribute names and types</li> <li>Test with multiple RTIs: Verify compatibility with different RTI implementations</li> <li>Document custom extensions: Clearly document any FOM extensions</li> </ol>"},{"location":"advanced/networking/#example-multi-federate-exercise","title":"Example: Multi-Federate Exercise","text":"<pre><code>// Federate 1: Aircraft simulation\njaguar::Engine aircraft_sim;\naircraft_sim.initialize(aircraft_config);\n\njaguar::network::HLAFederate fed1;\nfed1.initialize(hla_config);\nfed1.join_federation();\nfed1.publish_object_class(\"Platform.Aircraft\");\nfed1.subscribe_object_class(\"Platform.GroundVehicle\");\n\n// Federate 2: Ground vehicle simulation\njaguar::Engine ground_sim;\nground_sim.initialize(ground_config);\n\njaguar::network::HLAFederate fed2;\nfed2.initialize(hla_config);\nfed2.join_federation();\nfed2.publish_object_class(\"Platform.GroundVehicle\");\nfed2.subscribe_object_class(\"Platform.Aircraft\");\n\n// Both federates now exchange entity states automatically\n</code></pre>"},{"location":"advanced/networking/#advanced-topics","title":"Advanced Topics","text":""},{"location":"advanced/networking/#coordinate-transformations","title":"Coordinate Transformations","text":"<p>JaguarEngine handles all required coordinate transformations:</p> <ul> <li>ECEF (Earth-Centered Earth-Fixed): DIS wire format</li> <li>Geodetic (WGS84): Latitude, longitude, altitude</li> <li>NED (North-East-Down): Local tangent plane</li> <li>Body Frame: Aircraft/vehicle body coordinates</li> </ul> <pre><code>#include &lt;jaguar/federation/dis_protocol.h&gt;\n\n// Convert between coordinate frames\nGeodeticCoordinates geo{lat_rad, lon_rad, alt_m};\nVec3 ecef = geo.to_ecef();\nGeodeticCoordinates back = GeodeticCoordinates::from_ecef(ecef);\n</code></pre>"},{"location":"advanced/networking/#distributed-time-synchronization","title":"Distributed Time Synchronization","text":"<p>For large-scale distributed simulations, JaguarEngine provides advanced time synchronization through the Cloud Burst module:</p> <ul> <li>Raft consensus for time master election</li> <li>Vector clocks for causal ordering</li> <li>Barrier synchronization for checkpoints</li> <li>Multiple time advancement modes (Conservative, Optimistic, Bounded, Adaptive)</li> </ul> <p>See Cloud Burst API for details.</p>"},{"location":"advanced/networking/#scalability","title":"Scalability","text":"<p>JaguarEngine scales to thousands of entities through:</p> <ol> <li>Spatial Partitioning: Octree-based entity distribution</li> <li>Dead Reckoning: 80-90% bandwidth reduction</li> <li>Interest Management: DDM for HLA, area-of-interest filtering for DIS</li> <li>Load Balancing: Dynamic entity migration between compute nodes</li> </ol>"},{"location":"advanced/networking/#see-also","title":"See Also","text":"<ul> <li>Architecture - System architecture</li> <li>Federation API - Complete DIS/HLA API reference</li> <li>Cloud Burst API - Distributed simulation scaling</li> <li>Configuration - Configuration options</li> <li>Examples - Complete examples</li> </ul>"},{"location":"api/air/","title":"Air Domain API Reference","text":"<p>Aerodynamics, propulsion, and flight control system APIs.</p> <p>Header: <code>jaguar/domain/air.h</code></p>"},{"location":"api/air/#aerotable","title":"AeroTable","text":"<p>Multi-dimensional lookup table for aerodynamic coefficients.</p> <pre><code>class AeroTable {\npublic:\n    // Configuration\n    void set_breakpoints(int dimension, const std::vector&lt;Real&gt;&amp; values);\n    void set_data(const std::vector&lt;Real&gt;&amp; data);\n\n    // Lookup\n    Real lookup(const std::vector&lt;Real&gt;&amp; inputs) const;\n    Real lookup(Real input) const;  // 1D convenience\n    Real lookup(Real input1, Real input2) const;  // 2D convenience\n};\n</code></pre>"},{"location":"api/air/#example","title":"Example","text":"<pre><code>// Create 2D table: CL vs alpha and Mach\nAeroTable cl_table;\n\n// Alpha breakpoints (radians)\ncl_table.set_breakpoints(0, {-0.35, -0.17, 0.0, 0.17, 0.35, 0.52});\n\n// Mach breakpoints\ncl_table.set_breakpoints(1, {0.0, 0.5, 0.9, 1.2});\n\n// CL data (row-major: alpha varies fastest)\ncl_table.set_data({\n    -0.80, -0.75, -0.70, -0.60,  // alpha = -0.35\n    -0.40, -0.38, -0.35, -0.30,  // alpha = -0.17\n     0.20,  0.22,  0.25,  0.20,  // alpha = 0.0\n     0.80,  0.85,  0.90,  0.75,  // alpha = 0.17\n     1.20,  1.25,  1.15,  0.90,  // alpha = 0.35\n     0.90,  0.85,  0.70,  0.50   // alpha = 0.52\n});\n\n// Lookup\nReal alpha = 0.1;  // rad\nReal mach = 0.7;\nReal cl = cl_table.lookup(alpha, mach);\n</code></pre>"},{"location":"api/air/#aerodynamicsmodel","title":"AerodynamicsModel","text":"<p>Complete aerodynamic force and moment model.</p> <pre><code>class AerodynamicsModel : public physics::IAerodynamicsModel {\npublic:\n    // Reference geometry\n    void set_reference_area(Real area);    // m\u00b2\n    void set_reference_chord(Real chord);  // m (for pitching moment)\n    void set_reference_span(Real span);    // m (for rolling/yawing)\n\n    // Coefficient tables\n    void set_cl_table(std::unique_ptr&lt;AeroTable&gt; table);\n    void set_cd_table(std::unique_ptr&lt;AeroTable&gt; table);\n    void set_cm_table(std::unique_ptr&lt;AeroTable&gt; table);\n    void set_cy_table(std::unique_ptr&lt;AeroTable&gt; table);  // Side force\n    void set_cn_table(std::unique_ptr&lt;AeroTable&gt; table);  // Yawing moment\n    void set_cll_table(std::unique_ptr&lt;AeroTable&gt; table); // Rolling moment\n\n    // Control effectiveness\n    void set_cl_elevator(Real dcl_de);   // dCL/d_elevator\n    void set_cm_elevator(Real dcm_de);   // dCm/d_elevator\n    void set_cy_rudder(Real dcy_dr);     // dCY/d_rudder\n    void set_cn_rudder(Real dcn_dr);     // dCn/d_rudder\n    void set_cll_aileron(Real dcll_da);  // dCll/d_aileron\n\n    // Damping derivatives\n    void set_cl_alpha_dot(Real cl_ad);   // CL_alpha_dot\n    void set_cm_alpha_dot(Real cm_ad);   // Cm_alpha_dot\n    void set_cm_q(Real cmq);             // Pitch damping\n    void set_cn_r(Real cnr);             // Yaw damping\n    void set_cll_p(Real cllp);           // Roll damping\n\n    // Control surface positions\n    void set_elevator(Real deg);\n    void set_aileron(Real deg);\n    void set_rudder(Real deg);\n\n    // IForceGenerator\n    void compute_forces(const physics::EntityState&amp; state,\n                        const environment::Environment&amp; env,\n                        Real dt,\n                        physics::EntityForces&amp; forces) override;\n\n    // IAerodynamicsModel queries\n    Real get_cl() const override;\n    Real get_cd() const override;\n    Real get_cm() const override;\n    Real get_alpha() const override;  // rad\n    Real get_beta() const override;   // rad\n    Real get_mach() const override;\n    Real get_qbar() const override;   // Pa\n};\n</code></pre>"},{"location":"api/air/#example_1","title":"Example","text":"<pre><code>domain::air::AerodynamicsModel aero;\n\n// Set reference geometry\naero.set_reference_area(27.87);   // m\u00b2\naero.set_reference_chord(3.45);   // m\naero.set_reference_span(10.0);    // m\n\n// Set coefficient tables\naero.set_cl_table(std::move(cl_table));\naero.set_cd_table(std::move(cd_table));\naero.set_cm_table(std::move(cm_table));\n\n// Set control effectiveness\naero.set_cm_elevator(-0.05);  // Elevator authority\n\n// Set damping\naero.set_cm_q(-15.0);  // Pitch damping\naero.set_cll_p(-0.4);  // Roll damping\n\n// In simulation loop\naero.set_elevator(elevator_cmd);\naero.set_aileron(aileron_cmd);\n\nphysics::EntityForces forces;\naero.compute_forces(state, env, dt, forces);\n\n// Query aerodynamic state\nstd::cout &lt;&lt; \"Alpha: \" &lt;&lt; aero.get_alpha() * RAD_TO_DEG &lt;&lt; \" deg\\n\";\nstd::cout &lt;&lt; \"Mach: \" &lt;&lt; aero.get_mach() &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"CL: \" &lt;&lt; aero.get_cl() &lt;&lt; \"\\n\";\n</code></pre>"},{"location":"api/air/#propulsionmodel","title":"PropulsionModel","text":"<p>Engine thrust and fuel consumption model.</p> <pre><code>class PropulsionModel : public physics::IPropulsionModel {\npublic:\n    // Configuration\n    void set_max_thrust(Real thrust);               // N\n    void set_afterburner_thrust(Real thrust);       // N (optional)\n    void set_fuel_capacity(Real fuel);              // kg\n    void set_specific_fuel_consumption(Real sfc);   // kg/N/s\n    void set_afterburner_sfc(Real sfc);             // kg/N/s\n\n    // Thrust table (optional, for altitude/Mach variation)\n    void set_thrust_table(std::unique_ptr&lt;AeroTable&gt; table);\n\n    // Engine position (for thrust line offset)\n    void set_position(const Vec3&amp; pos);\n    void set_thrust_axis(const Vec3&amp; axis);\n\n    // Control\n    void set_throttle(Real throttle);  // 0.0 to 1.0\n    void set_afterburner(bool enabled);\n    void start();\n    void stop();\n\n    // Fuel management\n    void set_fuel(Real fuel);  // kg\n    void add_fuel(Real fuel);  // kg\n\n    // IForceGenerator\n    void compute_forces(const physics::EntityState&amp; state,\n                        const environment::Environment&amp; env,\n                        Real dt,\n                        physics::EntityForces&amp; forces) override;\n\n    // IPropulsionModel queries\n    Real get_thrust() const override;           // N\n    Real get_fuel_flow() const override;        // kg/s\n    Real get_fuel_remaining() const override;   // kg\n    bool is_running() const override;\n};\n</code></pre>"},{"location":"api/air/#example_2","title":"Example","text":"<pre><code>domain::air::PropulsionModel engine;\n\n// Configure engine\nengine.set_max_thrust(76000.0);        // 76 kN military thrust\nengine.set_afterburner_thrust(127000.0); // 127 kN with AB\nengine.set_fuel_capacity(3000.0);       // 3000 kg internal fuel\nengine.set_specific_fuel_consumption(0.0225);  // SFC\nengine.set_afterburner_sfc(0.058);\n\n// Position (behind CG)\nengine.set_position(Vec3{-5.0, 0.0, 0.0});\nengine.set_thrust_axis(Vec3{1.0, 0.0, 0.0});\n\n// Start and set throttle\nengine.start();\nengine.set_throttle(0.8);  // 80% throttle\n\n// In simulation loop\nphysics::EntityForces forces;\nengine.compute_forces(state, env, dt, forces);\n\n// Check fuel\nif (engine.get_fuel_remaining() &lt; 500.0) {\n    std::cout &lt;&lt; \"Bingo fuel!\\n\";\n}\n</code></pre>"},{"location":"api/air/#flightcontrolsystem","title":"FlightControlSystem","text":"<p>Flight control surface management.</p> <pre><code>class FlightControlSystem {\npublic:\n    struct ControlInputs {\n        Real pitch_cmd{0.0};     // -1 to +1\n        Real roll_cmd{0.0};      // -1 to +1\n        Real yaw_cmd{0.0};       // -1 to +1\n        Real throttle_cmd{0.0};  // 0 to 1\n    };\n\n    struct ControlOutputs {\n        Real elevator_deg{0.0};\n        Real aileron_deg{0.0};\n        Real rudder_deg{0.0};\n    };\n\n    // Configuration\n    void set_elevator_range(Real min_deg, Real max_deg);\n    void set_aileron_range(Real min_deg, Real max_deg);\n    void set_rudder_range(Real min_deg, Real max_deg);\n\n    // Rate limits\n    void set_elevator_rate_limit(Real deg_per_sec);\n    void set_aileron_rate_limit(Real deg_per_sec);\n    void set_rudder_rate_limit(Real deg_per_sec);\n\n    // Trim\n    void set_pitch_trim(Real trim);  // -1 to +1\n    void set_roll_trim(Real trim);\n    void set_yaw_trim(Real trim);\n\n    // Process inputs\n    ControlOutputs process(const ControlInputs&amp; inputs, Real dt);\n\n    // Query current positions\n    Real get_elevator() const;\n    Real get_aileron() const;\n    Real get_rudder() const;\n};\n</code></pre>"},{"location":"api/air/#example_3","title":"Example","text":"<pre><code>domain::air::FlightControlSystem fcs;\n\n// Configure control ranges\nfcs.set_elevator_range(-25.0, 25.0);\nfcs.set_aileron_range(-21.5, 21.5);\nfcs.set_rudder_range(-30.0, 30.0);\n\n// Set rate limits\nfcs.set_elevator_rate_limit(60.0);  // 60 deg/s\n\n// Trim for level flight\nfcs.set_pitch_trim(0.05);\n\n// Process pilot inputs\nFlightControlSystem::ControlInputs inputs;\ninputs.pitch_cmd = -0.2;  // Nose up\ninputs.roll_cmd = 0.5;    // Roll right\ninputs.throttle_cmd = 0.8;\n\nauto outputs = fcs.process(inputs, dt);\n\n// Apply to aerodynamics model\naero.set_elevator(outputs.elevator_deg);\naero.set_aileron(outputs.aileron_deg);\naero.set_rudder(outputs.rudder_deg);\n</code></pre>"},{"location":"api/air/#atmosphere-integration","title":"Atmosphere Integration","text":"<p>The air domain models integrate with the atmosphere service.</p> <pre><code>// Get environment at entity position\nauto env = engine.get_environment(aircraft_id);\n\n// Atmosphere properties available\nReal temperature = env.atmosphere.temperature;    // K\nReal pressure = env.atmosphere.pressure;          // Pa\nReal density = env.atmosphere.density;            // kg/m\u00b3\nReal speed_of_sound = env.atmosphere.speed_of_sound;  // m/s\nVec3 wind = env.atmosphere.wind;                  // m/s (NED)\n\n// Aerodynamics automatically uses these\naero.compute_forces(state, env, dt, forces);\n</code></pre>"},{"location":"api/air/#see-also","title":"See Also","text":"<ul> <li>Physics API - Force generator interfaces</li> <li>Environment API - Atmosphere system</li> <li>Air Domain Concepts - Domain overview</li> <li>Air Domain Tutorial - Step-by-step guide</li> </ul>"},{"location":"api/cloud/","title":"Cloud Burst API Reference","text":"<p>Cloud Burst module (<code>jaguar_cloud</code>) provides distributed simulation capabilities including state synchronization, spatial partitioning, and distributed time management with Raft consensus.</p>"},{"location":"api/cloud/#overview","title":"Overview","text":"<p>The Cloud Burst module enables: - State Synchronization: Distributed state sync with conflict resolution - Partition Management: Spatial and domain-based workload distribution - Distributed Time: Consensus-based time management with vector clocks</p>"},{"location":"api/cloud/#state-synchronization","title":"State Synchronization","text":""},{"location":"api/cloud/#header","title":"Header","text":"<pre><code>#include &lt;jaguar/cloud/state_sync.h&gt;\n</code></pre>"},{"location":"api/cloud/#core-types","title":"Core Types","text":"<pre><code>namespace jaguar::cloud {\n\n// Synchronization strategies\nenum class SyncStrategy {\n    Full,           // Full state transfer\n    Delta,          // Only changed fields\n    Incremental,    // Streaming updates\n    Snapshot,       // Point-in-time snapshot\n    Adaptive        // Auto-selects based on change rate\n};\n\n// Conflict resolution modes\nenum class ConflictResolution {\n    LastWriteWins,      // Timestamp-based resolution\n    FirstWriteWins,     // Original value preserved\n    MergeValues,        // Attempt to merge\n    CustomResolver,     // User-defined resolver\n    VectorClockBased    // Causal ordering\n};\n\n// Synchronization result\nstruct SyncResult {\n    bool success;\n    std::string error_message;\n    uint64_t version;\n    size_t bytes_transferred;\n    std::chrono::microseconds latency;\n    size_t conflicts_resolved;\n};\n\n// State delta for incremental sync\nstruct StateDelta {\n    uint64_t base_version;\n    uint64_t target_version;\n    std::vector&lt;uint8_t&gt; delta_data;\n    std::chrono::system_clock::time_point timestamp;\n    std::vector&lt;std::string&gt; changed_paths;\n};\n\n// Configuration\nstruct StateSyncConfig {\n    SyncStrategy strategy = SyncStrategy::Delta;\n    ConflictResolution conflict_resolution = ConflictResolution::LastWriteWins;\n    std::chrono::milliseconds sync_interval{100};\n    std::chrono::milliseconds timeout{5000};\n    size_t max_batch_size = 1000;\n    bool compression_enabled = true;\n    int compression_level = 6;\n    size_t max_delta_size = 1024 * 1024;  // 1 MB\n    bool checksum_enabled = true;\n};\n\n}  // namespace jaguar::cloud\n</code></pre>"},{"location":"api/cloud/#statesynchronizer-class","title":"StateSynchronizer Class","text":"<pre><code>class StateSynchronizer {\npublic:\n    // Initialize with configuration\n    SyncResult initialize(const StateSyncConfig&amp; config);\n\n    // Shutdown synchronizer\n    void shutdown();\n\n    // Synchronize local state to remote nodes\n    SyncResult sync_state(const void* state_data, size_t size);\n\n    // Receive state from remote node\n    SyncResult receive_state(const void* state_data, size_t size,\n                            const std::string&amp; source_node);\n\n    // Create snapshot\n    SyncResult create_snapshot(const std::string&amp; snapshot_id);\n\n    // Restore from snapshot\n    SyncResult restore_snapshot(const std::string&amp; snapshot_id);\n\n    // Get current version\n    uint64_t get_version() const;\n\n    // Check sync status\n    bool is_synchronized() const;\n\n    // Get pending changes count\n    size_t get_pending_changes() const;\n\n    // Register state change callback\n    void set_state_change_callback(\n        std::function&lt;void(const StateDelta&amp;)&gt; callback);\n\n    // Get synchronization statistics\n    struct SyncStats {\n        uint64_t total_syncs;\n        uint64_t successful_syncs;\n        uint64_t failed_syncs;\n        uint64_t conflicts_resolved;\n        size_t total_bytes_sent;\n        size_t total_bytes_received;\n        std::chrono::microseconds avg_latency;\n    };\n    SyncStats get_statistics() const;\n};\n\n// Factory function\nstd::unique_ptr&lt;StateSynchronizer&gt; create_state_synchronizer(\n    const StateSyncConfig&amp; config);\n</code></pre>"},{"location":"api/cloud/#conflict-resolver-interface","title":"Conflict Resolver Interface","text":"<pre><code>class IConflictResolver {\npublic:\n    virtual ~IConflictResolver() = default;\n\n    // Resolve conflict between local and remote values\n    virtual std::vector&lt;uint8_t&gt; resolve(\n        const std::vector&lt;uint8_t&gt;&amp; local_value,\n        const std::vector&lt;uint8_t&gt;&amp; remote_value,\n        const std::string&amp; path,\n        std::chrono::system_clock::time_point local_timestamp,\n        std::chrono::system_clock::time_point remote_timestamp) = 0;\n\n    // Check if values can be merged\n    virtual bool can_merge(const std::string&amp; path) const = 0;\n};\n\n// Built-in resolvers\nstd::unique_ptr&lt;IConflictResolver&gt; create_last_write_wins_resolver();\nstd::unique_ptr&lt;IConflictResolver&gt; create_vector_clock_resolver();\n</code></pre>"},{"location":"api/cloud/#partition-management","title":"Partition Management","text":""},{"location":"api/cloud/#header_1","title":"Header","text":"<pre><code>#include &lt;jaguar/cloud/partition_manager.h&gt;\n</code></pre>"},{"location":"api/cloud/#core-types_1","title":"Core Types","text":"<pre><code>namespace jaguar::cloud {\n\n// Partitioning strategies\nenum class PartitionStrategy {\n    Spatial,            // Geographic/spatial partitioning\n    Domain,             // By entity domain type\n    DomainThenSpatial,  // Hierarchical partitioning\n    LoadBased,          // Dynamic load balancing\n    Hybrid,             // Combined approach\n    Custom              // User-defined strategy\n};\n\n// Load balancing strategies\nenum class LoadBalanceStrategy {\n    RoundRobin,         // Simple rotation\n    LeastLoaded,        // Target least loaded node\n    WeightedRandom,     // Weighted probability\n    ConsistentHash,     // Consistent hashing\n    Adaptive            // ML-based prediction\n};\n\n// Axis-aligned bounding box\nstruct AABB {\n    Vec3 min_corner;\n    Vec3 max_corner;\n\n    bool contains(const Vec3&amp; point) const;\n    bool intersects(const AABB&amp; other) const;\n    AABB merge(const AABB&amp; other) const;\n    Vec3 center() const;\n    Vec3 size() const;\n    Real volume() const;\n};\n\n// Node information\nstruct NodeInfo {\n    std::string node_id;\n    std::string address;\n    uint16_t port;\n    Real current_load;          // 0.0 - 1.0\n    size_t entity_count;\n    size_t max_entities;\n    std::chrono::milliseconds latency;\n    bool is_healthy;\n    std::chrono::system_clock::time_point last_heartbeat;\n};\n\n// Partition information\nstruct PartitionInfo {\n    uint64_t partition_id;\n    AABB bounds;\n    std::string assigned_node;\n    size_t entity_count;\n    Real load_factor;\n    std::vector&lt;uint64_t&gt; child_partitions;\n};\n\n// Migration request\nstruct MigrationRequest {\n    uint64_t entity_id;\n    std::string source_node;\n    std::string target_node;\n    uint64_t source_partition;\n    uint64_t target_partition;\n    std::chrono::system_clock::time_point requested_at;\n    bool is_urgent;\n};\n\n// Partition result\nstruct PartitionResult {\n    bool success;\n    std::string error_message;\n    uint64_t partition_id;\n    size_t entities_affected;\n    std::chrono::microseconds duration;\n};\n\n}  // namespace jaguar::cloud\n</code></pre>"},{"location":"api/cloud/#partitionmanager-class","title":"PartitionManager Class","text":"<pre><code>class PartitionManager {\npublic:\n    // Initialize partition manager\n    PartitionResult initialize(const PartitionConfig&amp; config);\n\n    // Shutdown\n    void shutdown();\n\n    // Register a compute node\n    PartitionResult register_node(const NodeInfo&amp; node);\n\n    // Unregister a compute node\n    PartitionResult unregister_node(const std::string&amp; node_id);\n\n    // Add entity to partition system\n    PartitionResult add_entity(uint64_t entity_id, const Vec3&amp; position,\n                               Domain domain);\n\n    // Remove entity from partition system\n    PartitionResult remove_entity(uint64_t entity_id);\n\n    // Update entity position (may trigger migration)\n    PartitionResult update_entity_position(uint64_t entity_id,\n                                          const Vec3&amp; new_position);\n\n    // Get partition for entity\n    uint64_t get_entity_partition(uint64_t entity_id) const;\n\n    // Get node assignment for entity\n    std::string get_entity_node(uint64_t entity_id) const;\n\n    // Get all entities in partition\n    std::vector&lt;uint64_t&gt; get_partition_entities(uint64_t partition_id) const;\n\n    // Trigger rebalancing\n    PartitionResult rebalance();\n\n    // Get migration queue\n    std::vector&lt;MigrationRequest&gt; get_pending_migrations() const;\n\n    // Execute migration\n    PartitionResult execute_migration(const MigrationRequest&amp; request);\n\n    // Get partition tree (for octree-based spatial partitioning)\n    const PartitionInfo&amp; get_root_partition() const;\n\n    // Query partitions intersecting region\n    std::vector&lt;uint64_t&gt; query_partitions(const AABB&amp; region) const;\n\n    // Statistics\n    struct PartitionStats {\n        size_t total_partitions;\n        size_t active_nodes;\n        size_t total_entities;\n        Real avg_load_factor;\n        Real load_imbalance;  // std dev of load\n        size_t migrations_completed;\n        size_t migrations_pending;\n    };\n    PartitionStats get_statistics() const;\n};\n\n// Factory functions\nstd::unique_ptr&lt;PartitionManager&gt; create_partition_manager(\n    const PartitionConfig&amp; config);\nstd::unique_ptr&lt;ISpatialPartitioner&gt; create_octree_partitioner(\n    const AABB&amp; world_bounds, size_t max_entities_per_leaf);\nstd::unique_ptr&lt;ILoadBalancer&gt; create_load_balancer(\n    LoadBalanceStrategy strategy);\n</code></pre>"},{"location":"api/cloud/#distributed-time-management","title":"Distributed Time Management","text":""},{"location":"api/cloud/#header_2","title":"Header","text":"<pre><code>#include &lt;jaguar/cloud/distributed_time.h&gt;\n</code></pre>"},{"location":"api/cloud/#core-types_2","title":"Core Types","text":"<pre><code>namespace jaguar::cloud {\n\n// Raft consensus states\nenum class RaftState {\n    Follower,\n    Candidate,\n    Leader\n};\n\n// Time advancement modes\nenum class TimeAdvancementMode {\n    Conservative,   // Wait for all federates\n    Optimistic,     // Advance and rollback if needed\n    Bounded,        // Limited lookahead\n    Adaptive        // Auto-selects based on federation\n};\n\n// Clock synchronization algorithms\nenum class ClockSyncAlgorithm {\n    NTP,            // Network Time Protocol\n    PTP,            // Precision Time Protocol (IEEE 1588)\n    Cristian,       // Cristian's algorithm\n    Berkeley        // Berkeley algorithm\n};\n\n// Vector clock for causal ordering\nclass VectorClock {\npublic:\n    void increment(const std::string&amp; node_id);\n    void update(const VectorClock&amp; other);\n    bool happens_before(const VectorClock&amp; other) const;\n    bool is_concurrent(const VectorClock&amp; other) const;\n    uint64_t get(const std::string&amp; node_id) const;\n    std::map&lt;std::string, uint64_t&gt; get_all() const;\n};\n\n// Timestamped event for ordering\nstruct TimestampedEvent {\n    uint64_t event_id;\n    std::string source_node;\n    VectorClock vector_clock;\n    uint64_t lamport_timestamp;\n    std::chrono::system_clock::time_point wall_clock;\n    std::vector&lt;uint8_t&gt; event_data;\n};\n\n// Barrier synchronization state\nstruct BarrierState {\n    uint64_t barrier_id;\n    std::set&lt;std::string&gt; expected_nodes;\n    std::set&lt;std::string&gt; arrived_nodes;\n    std::chrono::system_clock::time_point deadline;\n    bool is_complete() const { return arrived_nodes == expected_nodes; }\n};\n\n// Time sync result\nstruct TimeSyncResult {\n    bool success;\n    std::string error_message;\n    std::chrono::nanoseconds clock_offset;\n    std::chrono::nanoseconds round_trip_time;\n    double precision_estimate;\n};\n\n// Configuration\nstruct TimeSyncConfig {\n    TimeAdvancementMode advancement_mode = TimeAdvancementMode::Conservative;\n    ClockSyncAlgorithm sync_algorithm = ClockSyncAlgorithm::PTP;\n    std::chrono::milliseconds sync_interval{100};\n    std::chrono::milliseconds max_lookahead{1000};\n    std::chrono::milliseconds barrier_timeout{5000};\n    bool enable_vector_clocks = true;\n    bool enable_lamport_clocks = true;\n    size_t raft_election_timeout_min_ms = 150;\n    size_t raft_election_timeout_max_ms = 300;\n    size_t raft_heartbeat_interval_ms = 50;\n};\n\n}  // namespace jaguar::cloud\n</code></pre>"},{"location":"api/cloud/#distributedtimemanager-class","title":"DistributedTimeManager Class","text":"<pre><code>class DistributedTimeManager {\npublic:\n    // Initialize time manager\n    TimeSyncResult initialize(const TimeSyncConfig&amp; config);\n\n    // Shutdown\n    void shutdown();\n\n    // Join time federation\n    TimeSyncResult join(const std::string&amp; node_id,\n                       const std::vector&lt;std::string&gt;&amp; peer_nodes);\n\n    // Leave time federation\n    void leave();\n\n    // Get current logical time\n    uint64_t get_logical_time() const;\n\n    // Get current simulation time\n    std::chrono::nanoseconds get_simulation_time() const;\n\n    // Advance time (may block for synchronization)\n    TimeSyncResult advance_time(std::chrono::nanoseconds delta);\n\n    // Request time advance (non-blocking)\n    void request_time_advance(std::chrono::nanoseconds target_time);\n\n    // Check if time advance is granted\n    bool is_time_advance_granted() const;\n\n    // Wait for time advance grant\n    TimeSyncResult wait_for_time_advance(\n        std::chrono::milliseconds timeout = std::chrono::milliseconds{5000});\n\n    // Vector clock operations\n    VectorClock get_vector_clock() const;\n    void update_vector_clock(const VectorClock&amp; received);\n\n    // Lamport timestamp\n    uint64_t get_lamport_timestamp() const;\n    uint64_t increment_lamport_timestamp();\n    void update_lamport_timestamp(uint64_t received);\n\n    // Event ordering\n    void submit_event(const TimestampedEvent&amp; event);\n    std::vector&lt;TimestampedEvent&gt; get_ordered_events();\n\n    // Barrier synchronization\n    uint64_t create_barrier(const std::set&lt;std::string&gt;&amp; nodes,\n                           std::chrono::milliseconds timeout);\n    TimeSyncResult arrive_at_barrier(uint64_t barrier_id);\n    TimeSyncResult wait_for_barrier(uint64_t barrier_id);\n\n    // Raft consensus (for leader election)\n    RaftState get_raft_state() const;\n    std::string get_leader_id() const;\n    bool is_leader() const;\n\n    // Clock synchronization\n    TimeSyncResult synchronize_clock();\n    std::chrono::nanoseconds get_clock_offset() const;\n\n    // Statistics\n    struct TimeStats {\n        uint64_t current_logical_time;\n        std::chrono::nanoseconds current_sim_time;\n        std::chrono::nanoseconds clock_offset;\n        size_t time_advances;\n        size_t barrier_syncs;\n        size_t events_ordered;\n        RaftState raft_state;\n        std::string leader_id;\n    };\n    TimeStats get_statistics() const;\n};\n\n// Factory functions\nstd::unique_ptr&lt;DistributedTimeManager&gt; create_distributed_time_manager(\n    const TimeSyncConfig&amp; config);\nstd::unique_ptr&lt;ITimeMaster&gt; create_time_master(\n    const std::string&amp; node_id);\n</code></pre>"},{"location":"api/cloud/#usage-examples","title":"Usage Examples","text":""},{"location":"api/cloud/#basic-state-synchronization","title":"Basic State Synchronization","text":"<pre><code>#include &lt;jaguar/cloud/state_sync.h&gt;\n\nusing namespace jaguar::cloud;\n\n// Configure synchronizer\nStateSyncConfig config;\nconfig.strategy = SyncStrategy::Delta;\nconfig.conflict_resolution = ConflictResolution::VectorClockBased;\nconfig.sync_interval = std::chrono::milliseconds{50};\nconfig.compression_enabled = true;\n\nauto synchronizer = create_state_synchronizer(config);\nsynchronizer-&gt;initialize(config);\n\n// Register callback for incoming state changes\nsynchronizer-&gt;set_state_change_callback([](const StateDelta&amp; delta) {\n    std::cout &lt;&lt; \"Received delta from version \" &lt;&lt; delta.base_version\n              &lt;&lt; \" to \" &lt;&lt; delta.target_version &lt;&lt; \"\\n\";\n    apply_delta(delta);\n});\n\n// In simulation loop\nwhile (running) {\n    engine.step(dt);\n\n    // Sync local state\n    auto state = engine.serialize_state();\n    auto result = synchronizer-&gt;sync_state(state.data(), state.size());\n\n    if (!result.success) {\n        handle_sync_error(result.error_message);\n    }\n}\n</code></pre>"},{"location":"api/cloud/#spatial-partitioning","title":"Spatial Partitioning","text":"<pre><code>#include &lt;jaguar/cloud/partition_manager.h&gt;\n\nusing namespace jaguar::cloud;\n\n// Define world bounds\nAABB world_bounds;\nworld_bounds.min_corner = {-1000000, -1000000, -100000};  // 1000 km x 1000 km x 100 km\nworld_bounds.max_corner = {1000000, 1000000, 100000};\n\n// Configure partition manager\nPartitionConfig config;\nconfig.strategy = PartitionStrategy::DomainThenSpatial;\nconfig.load_balance_strategy = LoadBalanceStrategy::Adaptive;\nconfig.world_bounds = world_bounds;\nconfig.max_entities_per_partition = 1000;\nconfig.rebalance_threshold = 0.2;  // Rebalance at 20% imbalance\n\nauto manager = create_partition_manager(config);\nmanager-&gt;initialize(config);\n\n// Register compute nodes\nNodeInfo node1{\"node-1\", \"192.168.1.10\", 8080, 0.0, 0, 10000};\nNodeInfo node2{\"node-2\", \"192.168.1.11\", 8080, 0.0, 0, 10000};\nmanager-&gt;register_node(node1);\nmanager-&gt;register_node(node2);\n\n// Add entities\nfor (auto&amp; entity : entities) {\n    manager-&gt;add_entity(entity.id, entity.position, entity.domain);\n}\n\n// In simulation loop - update positions\nfor (auto&amp; entity : entities) {\n    manager-&gt;update_entity_position(entity.id, entity.position);\n}\n\n// Periodically rebalance\nif (should_rebalance) {\n    auto result = manager-&gt;rebalance();\n\n    // Execute pending migrations\n    for (auto&amp; migration : manager-&gt;get_pending_migrations()) {\n        manager-&gt;execute_migration(migration);\n    }\n}\n</code></pre>"},{"location":"api/cloud/#distributed-time-with-raft-consensus","title":"Distributed Time with Raft Consensus","text":"<pre><code>#include &lt;jaguar/cloud/distributed_time.h&gt;\n\nusing namespace jaguar::cloud;\n\n// Configure time manager\nTimeSyncConfig config;\nconfig.advancement_mode = TimeAdvancementMode::Conservative;\nconfig.sync_algorithm = ClockSyncAlgorithm::PTP;\nconfig.enable_vector_clocks = true;\nconfig.max_lookahead = std::chrono::milliseconds{100};\n\nauto time_manager = create_distributed_time_manager(config);\ntime_manager-&gt;initialize(config);\n\n// Join federation\nstd::vector&lt;std::string&gt; peers = {\"node-2\", \"node-3\", \"node-4\"};\ntime_manager-&gt;join(\"node-1\", peers);\n\n// Wait for leader election\nwhile (time_manager-&gt;get_leader_id().empty()) {\n    std::this_thread::sleep_for(std::chrono::milliseconds{10});\n}\nstd::cout &lt;&lt; \"Leader elected: \" &lt;&lt; time_manager-&gt;get_leader_id() &lt;&lt; \"\\n\";\n\n// Simulation loop with distributed time\nstd::chrono::nanoseconds dt{10000000};  // 10 ms\n\nwhile (running) {\n    // Request time advance\n    time_manager-&gt;request_time_advance(\n        time_manager-&gt;get_simulation_time() + dt);\n\n    // Wait for grant (blocks until all nodes ready)\n    auto result = time_manager-&gt;wait_for_time_advance();\n\n    if (result.success) {\n        // Execute simulation step\n        engine.step(std::chrono::duration&lt;double&gt;(dt).count());\n\n        // Advance time manager\n        time_manager-&gt;advance_time(dt);\n    }\n}\n</code></pre>"},{"location":"api/cloud/#barrier-synchronization","title":"Barrier Synchronization","text":"<pre><code>// Create barrier for checkpoint\nstd::set&lt;std::string&gt; all_nodes = {\"node-1\", \"node-2\", \"node-3\"};\nauto barrier_id = time_manager-&gt;create_barrier(\n    all_nodes, std::chrono::milliseconds{10000});\n\n// Each node arrives at barrier when ready\ntime_manager-&gt;arrive_at_barrier(barrier_id);\n\n// Wait for all nodes\nauto result = time_manager-&gt;wait_for_barrier(barrier_id);\nif (result.success) {\n    // All nodes synchronized, safe to checkpoint\n    save_checkpoint();\n}\n</code></pre>"},{"location":"api/cloud/#see-also","title":"See Also","text":"<ul> <li>Architecture - System architecture overview</li> <li>Network Integration - DIS/HLA networking</li> <li>Federation API - Federation protocols</li> <li>Configuration - Engine configuration</li> </ul>"},{"location":"api/configuration/","title":"Configuration API Reference","text":"<p>XML configuration loading and engine/entity configuration.</p> <p>Header: <code>jaguar/interface/config.h</code></p>"},{"location":"api/configuration/#engineconfig","title":"EngineConfig","text":"<p>Engine-wide configuration settings.</p> <pre><code>struct EngineConfig {\n    // Simulation\n    Real time_step{0.01};                           // Integration step (s)\n    SizeT max_entities{10000};                      // Maximum entities\n    CoordinateFrame coordinate_frame{CoordinateFrame::ECEF};\n\n    // Threading\n    int physics_threads{-1};                        // -1 = auto-detect\n    int io_threads{2};\n    bool work_stealing{true};\n\n    // Terrain\n    bool terrain_enabled{true};\n    SizeT terrain_cache_mb{2048};\n    int terrain_tile_size{256};\n    std::vector&lt;std::string&gt; terrain_data_paths;\n\n    // Atmosphere\n    std::string atmosphere_model{\"us_standard_1976\"};\n    bool weather_enabled{true};\n\n    // Network (DIS)\n    bool dis_enabled{false};\n    int dis_port{3000};\n    int dis_site_id{1};\n    int dis_app_id{1};\n    std::string dis_address{\"239.1.2.3\"};\n\n    // Network (HLA)\n    bool hla_enabled{false};\n    std::string hla_federation;\n    std::string hla_federate;\n    std::string hla_fom_path;\n\n    // Static methods\n    static EngineConfig load(const std::string&amp; path);\n    static EngineConfig defaults();\n    bool save(const std::string&amp; path) const;\n    bool validate() const;\n};\n</code></pre>"},{"location":"api/configuration/#xml-format","title":"XML Format","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;engine_config version=\"1.0\"&gt;\n    &lt;simulation&gt;\n        &lt;time_step&gt;0.01&lt;/time_step&gt;\n        &lt;max_entities&gt;10000&lt;/max_entities&gt;\n        &lt;coordinate_frame&gt;ECEF&lt;/coordinate_frame&gt;\n    &lt;/simulation&gt;\n\n    &lt;threading&gt;\n        &lt;physics_threads&gt;-1&lt;/physics_threads&gt;\n        &lt;io_threads&gt;2&lt;/io_threads&gt;\n        &lt;work_stealing&gt;true&lt;/work_stealing&gt;\n    &lt;/threading&gt;\n\n    &lt;terrain enabled=\"true\"&gt;\n        &lt;cache_mb&gt;2048&lt;/cache_mb&gt;\n        &lt;tile_size&gt;256&lt;/tile_size&gt;\n        &lt;data_path&gt;/data/dted/&lt;/data_path&gt;\n        &lt;data_path&gt;/data/srtm/&lt;/data_path&gt;\n    &lt;/terrain&gt;\n\n    &lt;atmosphere&gt;\n        &lt;model&gt;us_standard_1976&lt;/model&gt;\n        &lt;weather_enabled&gt;true&lt;/weather_enabled&gt;\n    &lt;/atmosphere&gt;\n\n    &lt;network&gt;\n        &lt;dis enabled=\"false\"&gt;\n            &lt;port&gt;3000&lt;/port&gt;\n            &lt;site_id&gt;1&lt;/site_id&gt;\n            &lt;app_id&gt;1&lt;/app_id&gt;\n        &lt;/dis&gt;\n        &lt;hla enabled=\"false\"&gt;\n            &lt;federation&gt;MyFederation&lt;/federation&gt;\n            &lt;federate&gt;JaguarEngine&lt;/federate&gt;\n        &lt;/hla&gt;\n    &lt;/network&gt;\n&lt;/engine_config&gt;\n</code></pre>"},{"location":"api/configuration/#example","title":"Example","text":"<pre><code>// Load from file\nauto cfg = config::EngineConfig::load(\"config/engine.xml\");\n\n// Or create programmatically\nconfig::EngineConfig cfg;\ncfg.time_step = 0.005;           // 200 Hz\ncfg.physics_threads = 8;\ncfg.terrain_enabled = true;\ncfg.terrain_cache_mb = 4096;\ncfg.terrain_data_paths.push_back(\"/data/terrain/\");\n\n// Validate\nif (!cfg.validate()) {\n    std::cerr &lt;&lt; \"Invalid configuration\\n\";\n}\n\n// Initialize engine\nEngine engine;\nengine.initialize(cfg);\n\n// Save for later\ncfg.save(\"config/my_config.xml\");\n</code></pre>"},{"location":"api/configuration/#entityconfig","title":"EntityConfig","text":"<p>Entity definition configuration.</p> <pre><code>struct EntityConfig {\n    std::string name;\n    Domain domain{Domain::Generic};\n\n    // Mass properties\n    Real empty_mass{0.0};           // kg\n    Real fuel_capacity{0.0};        // kg\n    Vec3 cg_location{0, 0, 0};      // m\n    Mat3x3 inertia{};               // kg\u00b7m\u00b2\n\n    // Geometry\n    Real wingspan{0.0};             // m\n    Real length{0.0};               // m\n    Real height{0.0};               // m\n    Real reference_area{0.0};       // m\u00b2\n    Real reference_chord{0.0};      // m\n\n    // Component flags\n    ComponentMask components{0};\n\n    // Path to aerodynamics data (if any)\n    std::string aero_data_path;\n\n    // Path to propulsion data (if any)\n    std::string propulsion_data_path;\n\n    // Static methods\n    static EntityConfig load(const std::string&amp; path);\n};\n</code></pre>"},{"location":"api/configuration/#aircraft-xml","title":"Aircraft XML","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;entity type=\"aircraft\" name=\"F-16C\"&gt;\n    &lt;description&gt;General Dynamics F-16C&lt;/description&gt;\n\n    &lt;metrics&gt;\n        &lt;wingspan unit=\"ft\"&gt;32.8&lt;/wingspan&gt;\n        &lt;length unit=\"ft\"&gt;49.5&lt;/length&gt;\n        &lt;height unit=\"ft\"&gt;16.7&lt;/height&gt;\n        &lt;wing_area unit=\"ft2\"&gt;300.0&lt;/wing_area&gt;\n        &lt;wing_chord unit=\"ft\"&gt;11.32&lt;/wing_chord&gt;\n    &lt;/metrics&gt;\n\n    &lt;mass_balance&gt;\n        &lt;empty_weight unit=\"lbs\"&gt;19700&lt;/empty_weight&gt;\n        &lt;fuel_capacity unit=\"lbs\"&gt;6972&lt;/fuel_capacity&gt;\n\n        &lt;center_of_gravity unit=\"in\"&gt;\n            &lt;x&gt;180.0&lt;/x&gt;\n            &lt;y&gt;0.0&lt;/y&gt;\n            &lt;z&gt;0.0&lt;/z&gt;\n        &lt;/center_of_gravity&gt;\n\n        &lt;inertia unit=\"slug*ft2\"&gt;\n            &lt;ixx&gt;9496&lt;/ixx&gt;\n            &lt;iyy&gt;55814&lt;/iyy&gt;\n            &lt;izz&gt;63100&lt;/izz&gt;\n            &lt;ixz&gt;982&lt;/ixz&gt;\n        &lt;/inertia&gt;\n    &lt;/mass_balance&gt;\n\n    &lt;aerodynamics&gt;\n        &lt;!-- Aerodynamic tables --&gt;\n    &lt;/aerodynamics&gt;\n\n    &lt;propulsion&gt;\n        &lt;engine type=\"turbofan\" name=\"F110-GE-129\"&gt;\n            &lt;max_thrust unit=\"lbf\"&gt;17000&lt;/max_thrust&gt;\n            &lt;afterburner_thrust unit=\"lbf\"&gt;29000&lt;/afterburner_thrust&gt;\n        &lt;/engine&gt;\n    &lt;/propulsion&gt;\n\n    &lt;flight_control&gt;\n        &lt;!-- FCS definition --&gt;\n    &lt;/flight_control&gt;\n&lt;/entity&gt;\n</code></pre>"},{"location":"api/configuration/#ground-vehicle-xml","title":"Ground Vehicle XML","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;entity type=\"ground_vehicle\" name=\"M1A2\"&gt;\n    &lt;metrics&gt;\n        &lt;length unit=\"m\"&gt;9.77&lt;/length&gt;\n        &lt;width unit=\"m\"&gt;3.66&lt;/width&gt;\n        &lt;height unit=\"m\"&gt;2.44&lt;/height&gt;\n    &lt;/metrics&gt;\n\n    &lt;mass_balance&gt;\n        &lt;combat_weight unit=\"kg\"&gt;62000&lt;/combat_weight&gt;\n        &lt;fuel_capacity unit=\"L\"&gt;1900&lt;/fuel_capacity&gt;\n\n        &lt;inertia unit=\"kg*m2\"&gt;\n            &lt;ixx&gt;50000&lt;/ixx&gt;\n            &lt;iyy&gt;200000&lt;/iyy&gt;\n            &lt;izz&gt;220000&lt;/izz&gt;\n        &lt;/inertia&gt;\n    &lt;/mass_balance&gt;\n\n    &lt;tracks&gt;\n        &lt;track_width unit=\"m\"&gt;0.63&lt;/track_width&gt;\n        &lt;track_length unit=\"m\"&gt;4.6&lt;/track_length&gt;\n        &lt;sprocket_radius unit=\"m\"&gt;0.33&lt;/sprocket_radius&gt;\n    &lt;/tracks&gt;\n\n    &lt;suspension type=\"torsion_bar\"&gt;\n        &lt;road_wheels_per_side&gt;7&lt;/road_wheels_per_side&gt;\n        &lt;spring_rate unit=\"N/m\"&gt;300000&lt;/spring_rate&gt;\n        &lt;damping_rate unit=\"N*s/m\"&gt;30000&lt;/damping_rate&gt;\n    &lt;/suspension&gt;\n&lt;/entity&gt;\n</code></pre>"},{"location":"api/configuration/#ship-xml","title":"Ship XML","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;entity type=\"surface_ship\" name=\"DDG-51\"&gt;\n    &lt;metrics&gt;\n        &lt;length unit=\"m\"&gt;154.0&lt;/length&gt;\n        &lt;beam unit=\"m\"&gt;20.0&lt;/beam&gt;\n        &lt;draft unit=\"m\"&gt;9.4&lt;/draft&gt;\n    &lt;/metrics&gt;\n\n    &lt;mass_balance&gt;\n        &lt;displacement unit=\"tonnes\"&gt;8600&lt;/displacement&gt;\n        &lt;metacentric_height unit=\"m\"&gt;2.5&lt;/metacentric_height&gt;\n    &lt;/mass_balance&gt;\n\n    &lt;hydrodynamics&gt;\n        &lt;hull_coefficients&gt;\n            &lt;x_vv&gt;-0.04&lt;/x_vv&gt;\n            &lt;y_v&gt;-0.4&lt;/y_v&gt;\n            &lt;n_v&gt;-0.1&lt;/n_v&gt;\n        &lt;/hull_coefficients&gt;\n\n        &lt;rudder&gt;\n            &lt;area unit=\"m2\"&gt;18.0&lt;/area&gt;\n            &lt;max_angle unit=\"deg\"&gt;35&lt;/max_angle&gt;\n        &lt;/rudder&gt;\n\n        &lt;propeller&gt;\n            &lt;diameter unit=\"m\"&gt;5.2&lt;/diameter&gt;\n            &lt;max_rpm&gt;180&lt;/max_rpm&gt;\n        &lt;/propeller&gt;\n    &lt;/hydrodynamics&gt;\n&lt;/entity&gt;\n</code></pre>"},{"location":"api/configuration/#spacecraft-xml","title":"Spacecraft XML","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;entity type=\"spacecraft\" name=\"GPS-IIR\"&gt;\n    &lt;mass_balance&gt;\n        &lt;dry_mass unit=\"kg\"&gt;1080&lt;/dry_mass&gt;\n        &lt;fuel_mass unit=\"kg\"&gt;350&lt;/fuel_mass&gt;\n    &lt;/mass_balance&gt;\n\n    &lt;aerodynamics&gt;\n        &lt;drag_coefficient&gt;2.2&lt;/drag_coefficient&gt;\n        &lt;cross_section unit=\"m2\"&gt;10.0&lt;/cross_section&gt;\n    &lt;/aerodynamics&gt;\n\n    &lt;srp&gt;\n        &lt;reflectivity&gt;0.8&lt;/reflectivity&gt;\n        &lt;area unit=\"m2\"&gt;15.0&lt;/area&gt;\n    &lt;/srp&gt;\n\n    &lt;orbit&gt;\n        &lt;semi_major_axis unit=\"km\"&gt;26560&lt;/semi_major_axis&gt;\n        &lt;eccentricity&gt;0.0&lt;/eccentricity&gt;\n        &lt;inclination unit=\"deg\"&gt;55.0&lt;/inclination&gt;\n    &lt;/orbit&gt;\n&lt;/entity&gt;\n</code></pre>"},{"location":"api/configuration/#configloader","title":"ConfigLoader","text":"<p>Configuration file loading and path management.</p> <pre><code>class ConfigLoader {\npublic:\n    // Add search paths\n    void add_search_path(const std::string&amp; path);\n    void clear_search_paths();\n\n    // Find file in search paths\n    std::string find_file(const std::string&amp; filename) const;\n    bool file_exists(const std::string&amp; filename) const;\n\n    // Load configurations\n    EngineConfig load_engine_config(const std::string&amp; path);\n    EntityConfig load_entity_config(const std::string&amp; path);\n\n    // Load aerodynamic tables\n    std::unique_ptr&lt;domain::air::AeroTable&gt; load_aero_table(\n        const std::string&amp; path);\n\n    // Load material database\n    std::vector&lt;domain::land::SoilProperties&gt; load_soil_database(\n        const std::string&amp; path);\n};\n</code></pre>"},{"location":"api/configuration/#example_1","title":"Example","text":"<pre><code>config::ConfigLoader loader;\n\n// Add search paths\nloader.add_search_path(\"/opt/jaguar/data/\");\nloader.add_search_path(\"./data/\");\nloader.add_search_path(std::getenv(\"JAGUAR_DATA\"));\n\n// Load engine config\nauto engine_cfg = loader.load_engine_config(\"config/engine.xml\");\n\n// Load entity configs\nauto f16_cfg = loader.load_entity_config(\"aircraft/f16.xml\");\nauto tank_cfg = loader.load_entity_config(\"vehicles/m1a2.xml\");\n\n// Create entities from config\nEntityId f16 = engine.create_entity_from_config(f16_cfg);\nEntityId tank = engine.create_entity_from_config(tank_cfg);\n</code></pre>"},{"location":"api/configuration/#unit-system","title":"Unit System","text":"<p>Configuration files support multiple units with automatic conversion.</p> Quantity Supported Units Length m, ft, in, cm, mm, km, nm (nautical mile) Mass kg, lbs, slug, g Force N, lbf, kN Angle rad, deg Area m2, ft2, in2 Velocity m/s, ft/s, kts, km/h, mph Inertia kg*m2, slug*ft2 Pressure Pa, psi, atm, bar, hPa Temperature K, C, F Time s, ms, min, hr"},{"location":"api/configuration/#example_2","title":"Example","text":"<pre><code>&lt;!-- All internally converted to SI --&gt;\n&lt;wingspan unit=\"ft\"&gt;32.8&lt;/wingspan&gt;     &lt;!-- \u2192 10.0 m --&gt;\n&lt;mass unit=\"lbs\"&gt;19700&lt;/mass&gt;           &lt;!-- \u2192 8936 kg --&gt;\n&lt;angle unit=\"deg\"&gt;45.0&lt;/angle&gt;          &lt;!-- \u2192 0.785 rad --&gt;\n&lt;velocity unit=\"kts\"&gt;250&lt;/velocity&gt;     &lt;!-- \u2192 128.6 m/s --&gt;\n</code></pre>"},{"location":"api/configuration/#see-also","title":"See Also","text":"<ul> <li>API Overview - Complete API index</li> <li>Getting Started - Quick start guide</li> <li>Engine Setup - First simulation</li> </ul>"},{"location":"api/core/","title":"Core API Reference","text":"<p>Core types, vectors, quaternions, and fundamental data structures.</p> <p>Header: <code>jaguar/core/types.h</code></p>"},{"location":"api/core/#basic-types","title":"Basic Types","text":"<pre><code>namespace jaguar {\n    using Real = double;         // Primary floating-point type\n    using SizeT = std::size_t;   // Size type\n    using UInt8 = uint8_t;       // 8-bit unsigned\n    using UInt32 = uint32_t;     // 32-bit unsigned\n    using UInt64 = uint64_t;     // 64-bit unsigned\n    using Int32 = int32_t;       // 32-bit signed\n    using Int64 = int64_t;       // 64-bit signed\n\n    using ComponentMask = UInt64;\n    using EntityId = UInt64;\n    constexpr EntityId INVALID_ENTITY_ID = 0;\n}\n</code></pre>"},{"location":"api/core/#vec3","title":"Vec3","text":"<p>3D vector type for positions, velocities, and forces.</p> <pre><code>struct Vec3 {\n    Real x, y, z;\n\n    // Constructors\n    Vec3();\n    Vec3(Real x, Real y, Real z);\n\n    // Operations\n    Real norm() const;                    // Vector magnitude\n    Vec3 normalized() const;              // Unit vector\n    Real dot(const Vec3&amp; other) const;    // Dot product\n    Vec3 cross(const Vec3&amp; other) const;  // Cross product\n\n    // Operators\n    Vec3 operator+(const Vec3&amp; other) const;\n    Vec3 operator-(const Vec3&amp; other) const;\n    Vec3 operator*(Real scalar) const;\n    Vec3 operator/(Real scalar) const;\n    Vec3&amp; operator+=(const Vec3&amp; other);\n    Vec3&amp; operator-=(const Vec3&amp; other);\n    Vec3&amp; operator*=(Real scalar);\n};\n</code></pre>"},{"location":"api/core/#example","title":"Example","text":"<pre><code>Vec3 position{100.0, 200.0, -500.0};\nVec3 velocity{50.0, 0.0, 0.0};\n\n// Vector operations\nReal speed = velocity.norm();           // 50.0\nVec3 direction = velocity.normalized(); // {1, 0, 0}\n\n// Update position\nposition += velocity * dt;\n\n// Cross product for torque\nVec3 force{0.0, 0.0, -9.81 * mass};\nVec3 arm{1.0, 0.0, 0.0};\nVec3 torque = arm.cross(force);\n</code></pre>"},{"location":"api/core/#vec4","title":"Vec4","text":"<p>4D vector type.</p> <pre><code>struct Vec4 {\n    Real x, y, z, w;\n\n    Vec4();\n    Vec4(Real x, Real y, Real z, Real w);\n};\n</code></pre>"},{"location":"api/core/#quaternion","title":"Quaternion","text":"<p>Rotation representation using quaternions.</p> <pre><code>struct Quaternion {\n    Real w, x, y, z;\n\n    // Static constructors\n    static Quaternion identity();\n    static Quaternion from_euler(Real roll, Real pitch, Real yaw);\n    static Quaternion from_axis_angle(const Vec3&amp; axis, Real angle);\n\n    // Operations\n    Quaternion normalized() const;\n    Quaternion conjugate() const;\n    Vec3 rotate(const Vec3&amp; v) const;\n    Mat3x3 to_rotation_matrix() const;\n    void to_euler(Real&amp; roll, Real&amp; pitch, Real&amp; yaw) const;\n\n    // Operators\n    Quaternion operator*(const Quaternion&amp; other) const;\n};\n</code></pre>"},{"location":"api/core/#example_1","title":"Example","text":"<pre><code>// Create from Euler angles (radians)\nReal roll = 0.0;\nReal pitch = 10.0 * DEG_TO_RAD;\nReal yaw = 45.0 * DEG_TO_RAD;\nQuaternion orientation = Quaternion::from_euler(roll, pitch, yaw);\n\n// Rotate a vector\nVec3 body_force{1000.0, 0.0, 0.0};\nVec3 world_force = orientation.rotate(body_force);\n\n// Combine rotations\nQuaternion rotation = Quaternion::from_axis_angle(Vec3{0, 0, 1}, 0.1);\norientation = orientation * rotation;\n\n// Convert back to Euler\norientation.to_euler(roll, pitch, yaw);\n</code></pre>"},{"location":"api/core/#mat3x3","title":"Mat3x3","text":"<p>3x3 matrix for rotations and inertia tensors.</p> <pre><code>struct Mat3x3 {\n    Real data[3][3];\n\n    // Static constructors\n    static Mat3x3 identity();\n    static Mat3x3 from_euler(Real roll, Real pitch, Real yaw);\n\n    // Operations\n    Vec3 operator*(const Vec3&amp; v) const;\n    Mat3x3 operator*(const Mat3x3&amp; other) const;\n    Mat3x3 transpose() const;\n    Mat3x3 inverse() const;\n    Real determinant() const;\n};\n</code></pre>"},{"location":"api/core/#example_2","title":"Example","text":"<pre><code>// Create inertia tensor\nMat3x3 inertia = Mat3x3::identity();\ninertia.data[0][0] = 10000.0;  // Ixx\ninertia.data[1][1] = 50000.0;  // Iyy\ninertia.data[2][2] = 55000.0;  // Izz\n\n// Transform vector\nVec3 angular_momentum = inertia * angular_velocity;\n\n// Rotation matrix\nMat3x3 rotation = Mat3x3::from_euler(roll, pitch, yaw);\nVec3 world_vec = rotation * body_vec;\n</code></pre>"},{"location":"api/core/#enumerations","title":"Enumerations","text":""},{"location":"api/core/#domain","title":"Domain","text":"<pre><code>enum class Domain : UInt8 {\n    Generic = 0,  // Generic entity\n    Air = 1,      // Aircraft, missiles\n    Land = 2,     // Ground vehicles\n    Sea = 3,      // Ships, submarines\n    Space = 4     // Satellites, spacecraft\n};\n</code></pre>"},{"location":"api/core/#coordinateframe","title":"CoordinateFrame","text":"<pre><code>enum class CoordinateFrame : UInt8 {\n    ECEF = 0,   // Earth-Centered Earth-Fixed\n    NED = 1,    // North-East-Down (local)\n    ENU = 2,    // East-North-Up (local)\n    ECI = 3     // Earth-Centered Inertial\n};\n</code></pre>"},{"location":"api/core/#constants","title":"Constants","text":"<p>Physical and mathematical constants.</p> <pre><code>namespace constants {\n    // Mathematical\n    constexpr Real PI = 3.14159265358979323846;\n    constexpr Real TWO_PI = 6.28318530717958647692;\n    constexpr Real HALF_PI = 1.57079632679489661923;\n\n    // Conversion\n    constexpr Real DEG_TO_RAD = PI / 180.0;\n    constexpr Real RAD_TO_DEG = 180.0 / PI;\n\n    // Physical\n    constexpr Real G0 = 9.80665;              // Standard gravity (m/s\u00b2)\n    constexpr Real EARTH_RADIUS = 6378137.0;  // WGS84 equatorial (m)\n    constexpr Real EARTH_POLAR = 6356752.3;   // WGS84 polar (m)\n    constexpr Real EARTH_MU = 3.986004418e14; // Gravitational param (m\u00b3/s\u00b2)\n    constexpr Real EARTH_J2 = 1.08263e-3;     // J2 perturbation\n    constexpr Real EARTH_OMEGA = 7.2921159e-5; // Rotation rate (rad/s)\n\n    // Atmosphere\n    constexpr Real SEA_LEVEL_PRESSURE = 101325.0;    // Pa\n    constexpr Real SEA_LEVEL_TEMPERATURE = 288.15;   // K\n    constexpr Real SEA_LEVEL_DENSITY = 1.225;        // kg/m\u00b3\n    constexpr Real SPEED_OF_SOUND_SL = 340.29;       // m/s\n\n    // Water\n    constexpr Real WATER_DENSITY = 1025.0;   // Seawater (kg/m\u00b3)\n}\n</code></pre>"},{"location":"api/core/#example_3","title":"Example","text":"<pre><code>using namespace jaguar::constants;\n\n// Convert angles\nReal heading_deg = 45.0;\nReal heading_rad = heading_deg * DEG_TO_RAD;\n\n// Calculate orbital velocity\nReal altitude = 400000.0;  // 400 km\nReal radius = EARTH_RADIUS + altitude;\nReal orbital_velocity = std::sqrt(EARTH_MU / radius);\n\n// Gravity at altitude\nReal g = G0 * std::pow(EARTH_RADIUS / radius, 2);\n</code></pre>"},{"location":"api/core/#coordinate-transforms","title":"Coordinate Transforms","text":"<p>Coordinate system conversions.</p> <pre><code>namespace transforms {\n    // ECEF &lt;-&gt; Geodetic\n    Vec3 geodetic_to_ecef(Real lat, Real lon, Real alt);\n    void ecef_to_geodetic(const Vec3&amp; ecef, Real&amp; lat, Real&amp; lon, Real&amp; alt);\n\n    // ECEF &lt;-&gt; ECI\n    Vec3 ecef_to_eci(const Vec3&amp; ecef, Real jd);\n    Vec3 eci_to_ecef(const Vec3&amp; eci, Real jd);\n\n    // Local frames\n    Mat3x3 ecef_to_ned_rotation(Real lat, Real lon);\n    Mat3x3 ecef_to_enu_rotation(Real lat, Real lon);\n\n    // Time\n    Real greenwich_sidereal_time(Real jd);\n    Real julian_date(int year, int month, int day,\n                     int hour, int min, Real sec);\n}\n</code></pre>"},{"location":"api/core/#example_4","title":"Example","text":"<pre><code>using namespace jaguar::transforms;\n\n// Convert geodetic to ECEF\nReal lat = 37.0 * DEG_TO_RAD;\nReal lon = -122.0 * DEG_TO_RAD;\nReal alt = 1000.0;  // 1 km altitude\nVec3 ecef = geodetic_to_ecef(lat, lon, alt);\n\n// Convert ECEF to ECI for orbital calculations\nReal jd = julian_date(2024, 1, 1, 12, 0, 0.0);\nVec3 eci = ecef_to_eci(ecef, jd);\n\n// Get local NED frame\nMat3x3 ned_rotation = ecef_to_ned_rotation(lat, lon);\nVec3 velocity_ned = ned_rotation * velocity_ecef;\n</code></pre>"},{"location":"api/core/#see-also","title":"See Also","text":"<ul> <li>Physics API - Entity state and forces</li> <li>Concepts: Coordinates - Coordinate systems explained</li> <li>API Overview - Complete API index</li> </ul>"},{"location":"api/environment/","title":"Environment API Reference","text":"<p>Atmosphere, terrain, ocean, and environmental systems.</p> <p>Headers: <code>jaguar/environment/environment.h</code>, <code>jaguar/environment/atmosphere.h</code>, <code>jaguar/environment/terrain.h</code>, <code>jaguar/environment/ocean.h</code></p>"},{"location":"api/environment/#environment","title":"Environment","text":"<p>Complete environmental state at a location.</p> <pre><code>struct Environment {\n    // Position\n    Real latitude{0.0};            // rad\n    Real longitude{0.0};           // rad\n    Real altitude{0.0};            // m above WGS84 ellipsoid\n    Vec3 position_ecef{0, 0, 0};\n\n    // Atmosphere\n    AtmosphereState atmosphere;\n\n    // Terrain\n    TerrainQuery terrain;\n    Real terrain_elevation{0.0};   // m above WGS84\n\n    // Ocean\n    OceanState ocean;\n    bool over_water{false};\n\n    // Gravity\n    Vec3 gravity{0, 0, 9.80665};   // Local gravity vector (NED)\n\n    // Time\n    Real time{0.0};                // Simulation time\n    Real julian_date{0.0};         // For sun position\n};\n</code></pre>"},{"location":"api/environment/#example","title":"Example","text":"<pre><code>// Get environment at entity location\nEnvironment env = engine.get_environment(entity_id);\n\n// Or at arbitrary position\nVec3 ecef = transforms::geodetic_to_ecef(lat, lon, alt);\nEnvironment env = engine.get_environment_at(ecef);\n\n// Use environment data\nReal temperature = env.atmosphere.temperature;\nReal terrain_height = env.terrain.elevation;\nbool is_water = env.over_water;\n</code></pre>"},{"location":"api/environment/#environmentservice","title":"EnvironmentService","text":"<p>Central environment management service.</p> <pre><code>class EnvironmentService {\npublic:\n    // Lifecycle\n    bool initialize();\n    void shutdown();\n    void update(Real dt);\n\n    // Query environment\n    Environment query(const Vec3&amp; ecef, Real time) const;\n    Environment query_geodetic(Real lat, Real lon, Real alt, Real time) const;\n\n    // Access managers\n    TerrainManager&amp; terrain();\n    AtmosphereManager&amp; atmosphere();\n    OceanManager&amp; ocean();\n\n    // Time management\n    void set_time(Real time);\n    Real get_time() const;\n    void set_julian_date(Real jd);\n    Real get_julian_date() const;\n\n    // Sun position\n    Vec3 get_sun_direction() const;  // Unit vector toward sun (ECEF)\n    Real get_solar_flux() const;     // W/m\u00b2 at Earth distance\n};\n</code></pre>"},{"location":"api/environment/#atmospherestate","title":"AtmosphereState","text":"<p>Atmospheric properties at a point.</p> <pre><code>struct AtmosphereState {\n    Real temperature{288.15};      // K\n    Real pressure{101325.0};       // Pa\n    Real density{1.225};           // kg/m\u00b3\n    Real speed_of_sound{340.29};   // m/s\n    Real viscosity{1.789e-5};      // Pa\u00b7s (dynamic)\n    Vec3 wind{0, 0, 0};            // m/s (NED frame)\n    Real humidity{0.0};            // 0-1 relative humidity\n    Real visibility{10000.0};      // m\n};\n</code></pre>"},{"location":"api/environment/#standardatmosphere","title":"StandardAtmosphere","text":"<p>ISA (International Standard Atmosphere) model.</p> <pre><code>class StandardAtmosphere {\npublic:\n    // Query at altitude\n    AtmosphereState get_state(Real altitude) const;\n\n    // Individual properties\n    Real get_temperature(Real altitude) const;    // K\n    Real get_pressure(Real altitude) const;       // Pa\n    Real get_density(Real altitude) const;        // kg/m\u00b3\n    Real get_speed_of_sound(Real altitude) const; // m/s\n\n    // Altitude conversions\n    static Real geometric_to_geopotential(Real h);\n    static Real geopotential_to_geometric(Real H);\n\n    // Pressure altitude\n    static Real pressure_altitude(Real pressure);\n    static Real density_altitude(Real density);\n};\n</code></pre>"},{"location":"api/environment/#example_1","title":"Example","text":"<pre><code>StandardAtmosphere isa;\n\n// Get properties at 10 km\nReal alt = 10000.0;\nauto state = isa.get_state(alt);\n\nstd::cout &lt;&lt; \"Temperature: \" &lt;&lt; state.temperature &lt;&lt; \" K\\n\";\nstd::cout &lt;&lt; \"Pressure: \" &lt;&lt; state.pressure &lt;&lt; \" Pa\\n\";\nstd::cout &lt;&lt; \"Density: \" &lt;&lt; state.density &lt;&lt; \" kg/m\u00b3\\n\";\nstd::cout &lt;&lt; \"Speed of sound: \" &lt;&lt; state.speed_of_sound &lt;&lt; \" m/s\\n\";\n</code></pre>"},{"location":"api/environment/#weathermodel","title":"WeatherModel","text":"<p>Dynamic weather effects.</p> <pre><code>class WeatherModel {\npublic:\n    // Wind layers\n    void set_wind_layer(Real altitude, Real direction, Real speed);\n    void add_wind_layer(Real altitude, Real direction, Real speed);\n    void clear_wind_layers();\n    Vec3 get_wind(Real lat, Real lon, Real alt) const;\n\n    // Turbulence\n    void set_turbulence_intensity(Real intensity);  // 0-1\n    Vec3 get_turbulence(Real lat, Real lon, Real alt, Real time) const;\n\n    // Precipitation\n    void set_rain_rate(Real rate);  // mm/hour\n    Real get_rain_attenuation(Real frequency_ghz) const;  // dB/km\n\n    // Visibility\n    void set_fog_visibility(Real visibility_m);\n    Real get_visibility(Real lat, Real lon, Real alt) const;\n\n    // Temperature deviation from ISA\n    void set_isa_deviation(Real delta_t);  // K\n};\n</code></pre>"},{"location":"api/environment/#example_2","title":"Example","text":"<pre><code>auto&amp; weather = engine.get_environment_service().atmosphere().weather();\n\n// Set wind layers\nweather.set_wind_layer(0, 270.0 * DEG_TO_RAD, 5.0);     // Surface: 5 m/s from W\nweather.set_wind_layer(1000, 280.0 * DEG_TO_RAD, 15.0); // 1 km: 15 m/s\nweather.set_wind_layer(5000, 290.0 * DEG_TO_RAD, 30.0); // 5 km: 30 m/s\n\n// Get interpolated wind\nVec3 wind = weather.get_wind(lat, lon, 2500.0);\n\n// Enable turbulence\nweather.set_turbulence_intensity(0.3);\n</code></pre>"},{"location":"api/environment/#atmospheremanager","title":"AtmosphereManager","text":"<p>Complete atmosphere management.</p> <pre><code>class AtmosphereManager {\npublic:\n    // Query\n    AtmosphereState get_state(Real lat, Real lon, Real alt) const;\n\n    // Access components\n    const StandardAtmosphere&amp; standard() const;\n    WeatherModel&amp; weather();\n\n    // Enable/disable features\n    void set_weather_enabled(bool enabled);\n    bool is_weather_enabled() const;\n\n    // Upper atmosphere (for space domain)\n    Real get_density_jb08(Real lat, Real lon, Real alt, Real jd) const;\n};\n</code></pre>"},{"location":"api/environment/#terrainquery","title":"TerrainQuery","text":"<p>Terrain query result.</p> <pre><code>struct TerrainQuery {\n    Real elevation{0.0};         // m above WGS84\n    Vec3 normal{0, 0, 1};        // Surface normal (NED)\n    Real slope_angle{0.0};       // rad\n    TerrainMaterial material;\n    bool valid{false};           // True if terrain data available\n};\n\nstruct TerrainMaterial {\n    enum class Type {\n        Unknown, Rock, Sand, Clay, Snow, Water, Forest, Urban, Road\n    };\n\n    Type type{Type::Unknown};\n    std::string name;\n    Real friction{0.5};\n    Real vegetation_density{0.0};\n};\n</code></pre>"},{"location":"api/environment/#terrainmanager","title":"TerrainManager","text":"<p>Terrain data management and queries.</p> <pre><code>class TerrainManager {\npublic:\n    // Configuration\n    void add_data_path(const std::string&amp; path);\n    void set_cache_size(SizeT mb);\n\n    // Lifecycle\n    bool initialize();\n    void shutdown();\n\n    // Queries\n    Real get_elevation(Real lat, Real lon) const;\n    Vec3 get_surface_normal(Real lat, Real lon) const;\n    Real get_slope_angle(Real lat, Real lon) const;\n    TerrainMaterial get_material(Real lat, Real lon) const;\n    TerrainQuery query(Real lat, Real lon) const;\n\n    // Line of sight\n    bool has_line_of_sight(const Vec3&amp; from_ecef,\n                           const Vec3&amp; to_ecef) const;\n\n    // LOD management\n    void set_focus_point(const Vec3&amp; ecef);\n    void set_detail_radius(Real radius_m);\n    void update();\n\n    // Status\n    SizeT loaded_tile_count() const;\n    SizeT cache_usage_bytes() const;\n    bool has_coverage(Real lat, Real lon) const;\n};\n</code></pre>"},{"location":"api/environment/#example_3","title":"Example","text":"<pre><code>auto&amp; terrain = engine.get_environment_service().terrain();\n\n// Add data paths\nterrain.add_data_path(\"/data/dted/\");\nterrain.add_data_path(\"/data/srtm/\");\nterrain.set_cache_size(4096);  // 4 GB cache\n\n// Initialize\nterrain.initialize();\n\n// Query elevation\nReal lat = 37.0 * DEG_TO_RAD;\nReal lon = -122.0 * DEG_TO_RAD;\nReal elevation = terrain.get_elevation(lat, lon);\n\n// Full query\nTerrainQuery query = terrain.query(lat, lon);\nif (query.valid) {\n    std::cout &lt;&lt; \"Elevation: \" &lt;&lt; query.elevation &lt;&lt; \" m\\n\";\n    std::cout &lt;&lt; \"Slope: \" &lt;&lt; query.slope_angle * RAD_TO_DEG &lt;&lt; \" deg\\n\";\n    std::cout &lt;&lt; \"Material: \" &lt;&lt; query.material.name &lt;&lt; \"\\n\";\n}\n\n// Set LOD focus\nterrain.set_focus_point(player_position);\nterrain.set_detail_radius(50000.0);  // 50 km high detail\n\n// Check line of sight\nbool los = terrain.has_line_of_sight(observer_ecef, target_ecef);\n</code></pre>"},{"location":"api/environment/#oceanstate","title":"OceanState","text":"<p>Ocean properties at a point.</p> <pre><code>struct OceanState {\n    Real water_depth{1000.0};      // m\n    Real surface_elevation{0.0};   // m (wave height)\n    Vec3 current{0, 0, 0};         // m/s\n    Real temperature{15.0};        // \u00b0C\n    Real salinity{35.0};           // ppt\n    Real density{1025.0};          // kg/m\u00b3\n    Real sound_speed{1500.0};      // m/s\n};\n</code></pre>"},{"location":"api/environment/#oceanmanager","title":"OceanManager","text":"<p>Ocean environment management.</p> <pre><code>class OceanManager {\npublic:\n    // Sea state\n    void set_sea_state(const domain::sea::SeaState&amp; state);\n    const domain::sea::SeaState&amp; get_sea_state() const;\n\n    // Query\n    OceanState get_state(Real lat, Real lon, Real time) const;\n\n    // Wave surface\n    Real get_wave_elevation(Real x, Real y, Real time) const;\n    Vec3 get_wave_slope(Real x, Real y, Real time) const;\n    Vec3 get_particle_velocity(Real x, Real y, Real z, Real time) const;\n\n    // Currents\n    void set_current(const Vec3&amp; current);\n    Vec3 get_current(Real lat, Real lon, Real depth) const;\n\n    // Properties\n    Real get_density(Real lat, Real lon, Real depth) const;\n    Real get_sound_speed(Real lat, Real lon, Real depth) const;\n\n    // Update\n    void update(Real dt);\n};\n</code></pre>"},{"location":"api/environment/#example_4","title":"Example","text":"<pre><code>auto&amp; ocean = engine.get_environment_service().ocean();\n\n// Set sea state\nauto sea = domain::sea::SeaState::FromNATOSeaState(4);\nocean.set_sea_state(sea);\n\n// Set current\nocean.set_current(Vec3{0.5, 0.0, 0.0});  // 0.5 m/s eastward\n\n// Query wave height\nReal wave_height = ocean.get_wave_elevation(ship_x, ship_y, sim_time);\n\n// Get water properties for sonar\nReal sound_speed = ocean.get_sound_speed(lat, lon, -50.0);  // 50m depth\n</code></pre>"},{"location":"api/environment/#see-also","title":"See Also","text":"<ul> <li>Core API - Coordinate transforms</li> <li>Air Domain API - Atmosphere integration</li> <li>Land Domain API - Terrain integration</li> <li>Sea Domain API - Ocean integration</li> <li>Concepts: Environment - Environment system overview</li> </ul>"},{"location":"api/federation/","title":"Federation API Reference","text":"<p>Federation module provides complete implementations of IEEE 1278.1-2012 Distributed Interactive Simulation (DIS) protocol and IEEE 1516-2010 High Level Architecture (HLA) Runtime Infrastructure (RTI).</p>"},{"location":"api/federation/#overview","title":"Overview","text":"<p>The Federation module enables: - DIS Protocol: Real-time entity state exchange via UDP PDUs - HLA RTI: Federation-based distributed simulation with time management</p>"},{"location":"api/federation/#dis-protocol-ieee-12781-2012","title":"DIS Protocol (IEEE 1278.1-2012)","text":""},{"location":"api/federation/#header","title":"Header","text":"<pre><code>#include &lt;jaguar/federation/dis_protocol.h&gt;\n</code></pre>"},{"location":"api/federation/#pdu-types","title":"PDU Types","text":"<pre><code>namespace jaguar::federation {\n\n// PDU type enumeration (IEEE 1278.1-2012)\nenum class PDUType : uint8_t {\n    Other = 0,\n    EntityState = 1,\n    Fire = 2,\n    Detonation = 3,\n    Collision = 4,\n    ServiceRequest = 5,\n    ResupplyOffer = 6,\n    ResupplyReceived = 7,\n    ResupplyCancel = 8,\n    RepairComplete = 9,\n    RepairResponse = 10,\n    CreateEntity = 11,\n    RemoveEntity = 12,\n    StartResume = 13,\n    StopFreeze = 14,\n    Acknowledge = 15,\n    ActionRequest = 16,\n    ActionResponse = 17,\n    DataQuery = 18,\n    SetData = 19,\n    Data = 20,\n    EventReport = 21,\n    Comment = 22,\n    ElectromagneticEmission = 23,\n    Designator = 24,\n    Transmitter = 25,\n    Signal = 26,\n    Receiver = 27,\n    IFF = 28,\n    UnderwaterAcoustic = 29,\n    SupplementalEmission = 30,\n    IntercomSignal = 31,\n    IntercomControl = 32,\n    AggregateState = 33,\n    IsGroupOf = 34,\n    TransferOwnership = 35,\n    IsPartOf = 36,\n    MinefieldState = 37,\n    MinefieldQuery = 38,\n    MinefieldData = 39,\n    MinefieldResponseNACK = 40,\n    EnvironmentalProcess = 41,\n    GriddedData = 42,\n    PointObjectState = 43,\n    LinearObjectState = 44,\n    ArealObjectState = 45,\n    TSPI = 46,\n    Appearance = 47,\n    ArticulatedParts = 48,\n    LEFire = 49,\n    LEDetonation = 50,\n    CreateEntityR = 51,\n    RemoveEntityR = 52,\n    StartResumeR = 53,\n    StopFreezeR = 54,\n    AcknowledgeR = 55,\n    ActionRequestR = 56,\n    ActionResponseR = 57,\n    DataQueryR = 58,\n    SetDataR = 59,\n    DataR = 60,\n    EventReportR = 61,\n    CommentR = 62,\n    RecordR = 63,\n    SetRecordR = 64,\n    RecordQueryR = 65,\n    CollisionElastic = 66,\n    EntityStateUpdate = 67,\n    DirectedEnergyFire = 68,\n    EntityDamageStatus = 69,\n    InformationOperationsAction = 70,\n    InformationOperationsReport = 71,\n    Attribute = 72\n};\n\n}  // namespace jaguar::federation\n</code></pre>"},{"location":"api/federation/#dead-reckoning-algorithms","title":"Dead Reckoning Algorithms","text":"<pre><code>namespace jaguar::federation {\n\n// Dead reckoning algorithm enumeration\nenum class DeadReckoningAlgorithm : uint8_t {\n    DRM_Other = 0,\n    DRM_Static = 1,           // Static entity\n    DRM_FPW = 2,              // Fixed position, world coordinates\n    DRM_RPW = 3,              // Rotating position, world coordinates\n    DRM_RVW = 4,              // Rotating velocity, world coordinates\n    DRM_FVW = 5,              // Fixed velocity, world coordinates\n    DRM_FPB = 6,              // Fixed position, body coordinates\n    DRM_RPB = 7,              // Rotating position, body coordinates\n    DRM_RVB = 8,              // Rotating velocity, body coordinates\n    DRM_FVB = 9,              // Fixed velocity, body coordinates\n    DRM_FPW_HighRes = 10,     // High resolution variants\n    DRM_RPW_HighRes = 11,\n    DRM_RVW_HighRes = 12,\n    DRM_FVW_HighRes = 13,\n    DRM_FPB_HighRes = 14,\n    DRM_RPB_HighRes = 15,\n    DRM_RVB_HighRes = 16,\n    DRM_FVB_HighRes = 17\n};\n\n// Dead reckoning calculator\nclass DeadReckoningCalculator {\npublic:\n    // Set algorithm\n    void set_algorithm(DeadReckoningAlgorithm algorithm);\n    DeadReckoningAlgorithm get_algorithm() const;\n\n    // Set initial state\n    void set_state(const Vec3&amp; position,\n                   const Vec3&amp; velocity,\n                   const Vec3&amp; acceleration,\n                   const EulerAngles&amp; orientation,\n                   const Vec3&amp; angular_velocity);\n\n    // Extrapolate to time\n    void extrapolate(double delta_time,\n                    Vec3&amp; out_position,\n                    Vec3&amp; out_velocity,\n                    EulerAngles&amp; out_orientation) const;\n\n    // Check if update needed (threshold exceeded)\n    bool needs_update(const Vec3&amp; actual_position,\n                     const Vec3&amp; actual_velocity,\n                     const EulerAngles&amp; actual_orientation,\n                     double position_threshold,\n                     double orientation_threshold) const;\n};\n\n}  // namespace jaguar::federation\n</code></pre>"},{"location":"api/federation/#entity-and-type-identifiers","title":"Entity and Type Identifiers","text":"<pre><code>namespace jaguar::federation {\n\n// Entity identifier (site, application, entity)\nstruct EntityIdentifier {\n    uint16_t site_id;\n    uint16_t application_id;\n    uint16_t entity_id;\n\n    bool operator==(const EntityIdentifier&amp; other) const;\n    bool operator&lt;(const EntityIdentifier&amp; other) const;\n    std::string to_string() const;\n};\n\n// Entity type enumeration\nstruct EntityType {\n    uint8_t entity_kind;        // Platform, Munition, Life Form, etc.\n    uint8_t domain;             // Land, Air, Surface, Subsurface, Space\n    uint16_t country;           // Country code (SISO-REF-010)\n    uint8_t category;           // Vehicle category\n    uint8_t subcategory;        // Specific type\n    uint8_t specific;           // Specific variant\n    uint8_t extra;              // Extra information\n\n    bool operator==(const EntityType&amp; other) const;\n    std::string to_string() const;\n};\n\n// Force ID\nenum class ForceId : uint8_t {\n    Other = 0,\n    Friendly = 1,\n    Opposing = 2,\n    Neutral = 3\n};\n\n// Entity kind\nenum class EntityKind : uint8_t {\n    Other = 0,\n    Platform = 1,\n    Munition = 2,\n    LifeForm = 3,\n    Environmental = 4,\n    CulturalFeature = 5,\n    Supply = 6,\n    Radio = 7,\n    Expendable = 8,\n    SensorEmitter = 9\n};\n\n// Platform domain\nenum class PlatformDomain : uint8_t {\n    Other = 0,\n    Land = 1,\n    Air = 2,\n    Surface = 3,\n    Subsurface = 4,\n    Space = 5\n};\n\n}  // namespace jaguar::federation\n</code></pre>"},{"location":"api/federation/#coordinate-types","title":"Coordinate Types","text":"<pre><code>namespace jaguar::federation {\n\n// Euler angles (psi, theta, phi - heading, pitch, roll)\nstruct EulerAngles {\n    float psi;      // Heading (radians)\n    float theta;    // Pitch (radians)\n    float phi;      // Roll (radians)\n\n    Quaternion to_quaternion() const;\n    static EulerAngles from_quaternion(const Quaternion&amp; q);\n};\n\n// Geodetic coordinates (WGS84)\nstruct GeodeticCoordinates {\n    double latitude;    // Radians\n    double longitude;   // Radians\n    double altitude;    // Meters above ellipsoid\n\n    Vec3 to_ecef() const;\n    static GeodeticCoordinates from_ecef(const Vec3&amp; ecef);\n};\n\n// World coordinates (ECEF - Earth-Centered Earth-Fixed)\n// Represented as Vec3 {x, y, z} in meters\n\n}  // namespace jaguar::federation\n</code></pre>"},{"location":"api/federation/#pdu-structures","title":"PDU Structures","text":"<pre><code>namespace jaguar::federation {\n\n// PDU Header (common to all PDUs)\nstruct PDUHeader {\n    uint8_t protocol_version;   // 7 for IEEE 1278.1-2012\n    uint8_t exercise_id;\n    PDUType pdu_type;\n    uint8_t protocol_family;\n    uint32_t timestamp;\n    uint16_t pdu_length;\n    uint16_t pdu_status;\n    uint8_t padding;\n};\n\n// Entity State PDU\nstruct EntityStatePDU {\n    PDUHeader header;\n    EntityIdentifier entity_id;\n    ForceId force_id;\n    uint8_t num_articulation_params;\n    EntityType entity_type;\n    EntityType alt_entity_type;\n    Vec3 linear_velocity;           // ECEF, m/s\n    Vec3 location;                  // ECEF, meters\n    EulerAngles orientation;\n    uint32_t entity_appearance;\n    DeadReckoningAlgorithm dr_algorithm;\n    uint8_t dr_params[15];\n    Vec3 linear_acceleration;\n    Vec3 angular_velocity;\n    uint8_t marking[12];            // Entity marking (callsign)\n    uint32_t capabilities;\n    // Variable articulation parameters follow\n};\n\n// Fire PDU\nstruct FirePDU {\n    PDUHeader header;\n    EntityIdentifier firing_entity_id;\n    EntityIdentifier target_entity_id;\n    EntityIdentifier munition_id;\n    uint32_t event_id;\n    uint32_t fire_mission_index;\n    Vec3 location;                  // ECEF firing location\n    EntityType burst_descriptor;\n    Vec3 velocity;                  // Munition velocity\n    float range;\n};\n\n// Detonation PDU\nstruct DetonationPDU {\n    PDUHeader header;\n    EntityIdentifier firing_entity_id;\n    EntityIdentifier target_entity_id;\n    EntityIdentifier munition_id;\n    uint32_t event_id;\n    Vec3 velocity;                  // Munition velocity at impact\n    Vec3 location;                  // Detonation location (ECEF)\n    EntityType burst_descriptor;\n    Vec3 location_in_entity;        // Relative to target\n    uint8_t detonation_result;\n    uint8_t num_articulation_params;\n    uint16_t padding;\n    // Variable articulation parameters follow\n};\n\n// Detonation result codes\nenum class DetonationResult : uint8_t {\n    Other = 0,\n    EntityImpact = 1,\n    EntityProximateDetonation = 2,\n    GroundImpact = 3,\n    GroundProximateDetonation = 4,\n    Detonation = 5,\n    None = 6,\n    HEHitSmall = 7,\n    HEHitMedium = 8,\n    HEHitLarge = 9,\n    ArmorPiercingHit = 10,\n    DirtBlast_Small = 11,\n    DirtBlast_Medium = 12,\n    DirtBlast_Large = 13,\n    WaterBlast_Small = 14,\n    WaterBlast_Medium = 15,\n    WaterBlast_Large = 16,\n    AirHit = 17,\n    BuildingHit_Small = 18,\n    BuildingHit_Medium = 19,\n    BuildingHit_Large = 20,\n    MineClearingLineCharge = 21,\n    EnvironmentObjectImpact = 22,\n    EnvironmentObjectProximateDetonation = 23,\n    WaterImpact = 24,\n    AirBurst = 25,\n    KillWithFragmentType1 = 26,\n    KillWithFragmentType2 = 27,\n    KillWithFragmentType3 = 28,\n    KillWithFragmentType1After = 29,\n    KillWithFragmentType2After = 30,\n    MissedDueToFlyout = 31,\n    MissedDueToEndGame = 32,\n    MissedDueToFlyoutEndGame = 33\n};\n\n}  // namespace jaguar::federation\n</code></pre>"},{"location":"api/federation/#dis-interface-classes","title":"DIS Interface Classes","text":"<pre><code>namespace jaguar::federation {\n\n// DIS codec interface\nclass IDISCodec {\npublic:\n    virtual ~IDISCodec() = default;\n\n    // Encode PDU to bytes\n    virtual std::vector&lt;uint8_t&gt; encode(const EntityStatePDU&amp; pdu) = 0;\n    virtual std::vector&lt;uint8_t&gt; encode(const FirePDU&amp; pdu) = 0;\n    virtual std::vector&lt;uint8_t&gt; encode(const DetonationPDU&amp; pdu) = 0;\n\n    // Decode bytes to PDU\n    virtual PDUType get_pdu_type(const std::vector&lt;uint8_t&gt;&amp; data) = 0;\n    virtual EntityStatePDU decode_entity_state(const std::vector&lt;uint8_t&gt;&amp; data) = 0;\n    virtual FirePDU decode_fire(const std::vector&lt;uint8_t&gt;&amp; data) = 0;\n    virtual DetonationPDU decode_detonation(const std::vector&lt;uint8_t&gt;&amp; data) = 0;\n};\n\n// DIS network interface\nclass IDISNetwork {\npublic:\n    virtual ~IDISNetwork() = default;\n\n    // Initialize network\n    virtual bool initialize(const DISConfig&amp; config) = 0;\n    virtual void shutdown() = 0;\n\n    // Send PDU\n    virtual bool send(const std::vector&lt;uint8_t&gt;&amp; pdu_data) = 0;\n\n    // Receive PDUs (non-blocking)\n    virtual std::vector&lt;std::vector&lt;uint8_t&gt;&gt; receive() = 0;\n\n    // Join/leave multicast group\n    virtual bool join_multicast(const std::string&amp; group_address) = 0;\n    virtual void leave_multicast(const std::string&amp; group_address) = 0;\n};\n\n// DIS configuration\nstruct DISConfig {\n    bool enabled = false;\n    std::string broadcast_address = \"255.255.255.255\";\n    std::string multicast_address = \"\";     // Optional multicast\n    uint16_t port = 3000;\n    uint16_t site_id = 1;\n    uint16_t application_id = 1;\n    uint8_t exercise_id = 1;\n    DeadReckoningAlgorithm default_dr_algorithm = DeadReckoningAlgorithm::DRM_FVW;\n    double position_threshold = 1.0;        // meters\n    double orientation_threshold = 0.05;    // radians\n    double heartbeat_interval = 5.0;        // seconds\n    bool enable_ieee_2012 = true;           // Use IEEE 1278.1-2012 features\n};\n\n// Factory functions\nstd::unique_ptr&lt;IDISCodec&gt; create_dis_codec(bool ieee_2012 = true);\nstd::unique_ptr&lt;IDISNetwork&gt; create_dis_network(const DISConfig&amp; config);\n\n}  // namespace jaguar::federation\n</code></pre>"},{"location":"api/federation/#hla-rti-ieee-1516-2010","title":"HLA RTI (IEEE 1516-2010)","text":""},{"location":"api/federation/#header_1","title":"Header","text":"<pre><code>#include &lt;jaguar/federation/hla_rti.h&gt;\n</code></pre>"},{"location":"api/federation/#handle-types","title":"Handle Types","text":"<pre><code>namespace jaguar::federation {\n\n// Strongly-typed handles\nstruct ObjectInstanceHandle {\n    uint64_t value;\n    bool is_valid() const { return value != 0; }\n    bool operator==(const ObjectInstanceHandle&amp; other) const;\n    bool operator&lt;(const ObjectInstanceHandle&amp; other) const;\n};\n\nstruct ObjectClassHandle {\n    uint64_t value;\n    bool is_valid() const { return value != 0; }\n    bool operator==(const ObjectClassHandle&amp; other) const;\n};\n\nstruct AttributeHandle {\n    uint64_t value;\n    bool is_valid() const { return value != 0; }\n    bool operator==(const AttributeHandle&amp; other) const;\n};\n\nstruct InteractionClassHandle {\n    uint64_t value;\n    bool is_valid() const { return value != 0; }\n};\n\nstruct ParameterHandle {\n    uint64_t value;\n    bool is_valid() const { return value != 0; }\n};\n\nstruct FederateHandle {\n    uint64_t value;\n    bool is_valid() const { return value != 0; }\n};\n\n// Handle sets\nusing AttributeHandleSet = std::set&lt;AttributeHandle&gt;;\nusing ObjectInstanceHandleSet = std::set&lt;ObjectInstanceHandle&gt;;\n\n}  // namespace jaguar::federation\n</code></pre>"},{"location":"api/federation/#time-management","title":"Time Management","text":"<pre><code>namespace jaguar::federation {\n\n// Logical time (HLA time representation)\nclass LogicalTime {\npublic:\n    LogicalTime();\n    explicit LogicalTime(double time);\n\n    double get_time() const;\n    void set_time(double time);\n\n    LogicalTime operator+(const LogicalTimeInterval&amp; interval) const;\n    LogicalTime operator-(const LogicalTimeInterval&amp; interval) const;\n    bool operator&lt;(const LogicalTime&amp; other) const;\n    bool operator&lt;=(const LogicalTime&amp; other) const;\n    bool operator==(const LogicalTime&amp; other) const;\n\nprivate:\n    double time_;\n};\n\n// Logical time interval (duration)\nclass LogicalTimeInterval {\npublic:\n    LogicalTimeInterval();\n    explicit LogicalTimeInterval(double interval);\n\n    double get_interval() const;\n    void set_interval(double interval);\n\n    bool operator&lt;(const LogicalTimeInterval&amp; other) const;\n    bool operator==(const LogicalTimeInterval&amp; other) const;\n\nprivate:\n    double interval_;\n};\n\n}  // namespace jaguar::federation\n</code></pre>"},{"location":"api/federation/#rti-ambassador-interface","title":"RTI Ambassador Interface","text":"<pre><code>namespace jaguar::federation {\n\n// RTI Ambassador - main interface to RTI\nclass IRTIAmbassador {\npublic:\n    virtual ~IRTIAmbassador() = default;\n\n    // Federation management\n    virtual void connect(const std::string&amp; local_settings_designator) = 0;\n    virtual void disconnect() = 0;\n\n    virtual void create_federation_execution(\n        const std::string&amp; federation_name,\n        const std::vector&lt;std::string&gt;&amp; fom_modules) = 0;\n\n    virtual void destroy_federation_execution(\n        const std::string&amp; federation_name) = 0;\n\n    virtual FederateHandle join_federation_execution(\n        const std::string&amp; federate_name,\n        const std::string&amp; federate_type,\n        const std::string&amp; federation_name) = 0;\n\n    virtual void resign_federation_execution(\n        int resign_action) = 0;\n\n    // Object management\n    virtual ObjectClassHandle get_object_class_handle(\n        const std::string&amp; class_name) = 0;\n\n    virtual std::string get_object_class_name(\n        ObjectClassHandle class_handle) = 0;\n\n    virtual AttributeHandle get_attribute_handle(\n        ObjectClassHandle class_handle,\n        const std::string&amp; attribute_name) = 0;\n\n    virtual void publish_object_class_attributes(\n        ObjectClassHandle class_handle,\n        const AttributeHandleSet&amp; attributes) = 0;\n\n    virtual void subscribe_object_class_attributes(\n        ObjectClassHandle class_handle,\n        const AttributeHandleSet&amp; attributes) = 0;\n\n    virtual ObjectInstanceHandle register_object_instance(\n        ObjectClassHandle class_handle) = 0;\n\n    virtual ObjectInstanceHandle register_object_instance(\n        ObjectClassHandle class_handle,\n        const std::string&amp; instance_name) = 0;\n\n    virtual void update_attribute_values(\n        ObjectInstanceHandle object_handle,\n        const std::map&lt;AttributeHandle, std::vector&lt;uint8_t&gt;&gt;&amp; attributes,\n        const std::vector&lt;uint8_t&gt;&amp; user_tag) = 0;\n\n    virtual void update_attribute_values(\n        ObjectInstanceHandle object_handle,\n        const std::map&lt;AttributeHandle, std::vector&lt;uint8_t&gt;&gt;&amp; attributes,\n        const std::vector&lt;uint8_t&gt;&amp; user_tag,\n        const LogicalTime&amp; time) = 0;\n\n    virtual void delete_object_instance(\n        ObjectInstanceHandle object_handle,\n        const std::vector&lt;uint8_t&gt;&amp; user_tag) = 0;\n\n    // Interaction management\n    virtual InteractionClassHandle get_interaction_class_handle(\n        const std::string&amp; interaction_name) = 0;\n\n    virtual ParameterHandle get_parameter_handle(\n        InteractionClassHandle interaction_handle,\n        const std::string&amp; parameter_name) = 0;\n\n    virtual void publish_interaction_class(\n        InteractionClassHandle interaction_handle) = 0;\n\n    virtual void subscribe_interaction_class(\n        InteractionClassHandle interaction_handle) = 0;\n\n    virtual void send_interaction(\n        InteractionClassHandle interaction_handle,\n        const std::map&lt;ParameterHandle, std::vector&lt;uint8_t&gt;&gt;&amp; parameters,\n        const std::vector&lt;uint8_t&gt;&amp; user_tag) = 0;\n\n    virtual void send_interaction(\n        InteractionClassHandle interaction_handle,\n        const std::map&lt;ParameterHandle, std::vector&lt;uint8_t&gt;&gt;&amp; parameters,\n        const std::vector&lt;uint8_t&gt;&amp; user_tag,\n        const LogicalTime&amp; time) = 0;\n\n    // Time management\n    virtual void enable_time_regulation(\n        const LogicalTimeInterval&amp; lookahead) = 0;\n\n    virtual void disable_time_regulation() = 0;\n\n    virtual void enable_time_constrained() = 0;\n\n    virtual void disable_time_constrained() = 0;\n\n    virtual void time_advance_request(const LogicalTime&amp; time) = 0;\n\n    virtual void time_advance_request_available(const LogicalTime&amp; time) = 0;\n\n    virtual void next_message_request(const LogicalTime&amp; time) = 0;\n\n    virtual void next_message_request_available(const LogicalTime&amp; time) = 0;\n\n    virtual void flush_queue_request(const LogicalTime&amp; time) = 0;\n\n    virtual void modify_lookahead(const LogicalTimeInterval&amp; lookahead) = 0;\n\n    virtual LogicalTimeInterval query_lookahead() = 0;\n\n    // Ownership management\n    virtual void request_attribute_ownership_assumption(\n        ObjectInstanceHandle object_handle,\n        const AttributeHandleSet&amp; attributes,\n        const std::vector&lt;uint8_t&gt;&amp; user_tag) = 0;\n\n    virtual void unconditional_attribute_ownership_divestiture(\n        ObjectInstanceHandle object_handle,\n        const AttributeHandleSet&amp; attributes) = 0;\n\n    // DDM (Data Distribution Management)\n    virtual void create_region(/* ... */) = 0;\n    virtual void delete_region(/* ... */) = 0;\n\n    // Tick (process callbacks)\n    virtual bool tick() = 0;\n    virtual bool tick(double min_seconds, double max_seconds) = 0;\n};\n\n}  // namespace jaguar::federation\n</code></pre>"},{"location":"api/federation/#federate-ambassador-interface","title":"Federate Ambassador Interface","text":"<pre><code>namespace jaguar::federation {\n\n// Federate Ambassador - callbacks from RTI\nclass IFederateAmbassador {\npublic:\n    virtual ~IFederateAmbassador() = default;\n\n    // Federation management callbacks\n    virtual void connection_lost(const std::string&amp; fault_description) = 0;\n\n    virtual void synchronization_point_registration_succeeded(\n        const std::string&amp; label) = 0;\n\n    virtual void synchronization_point_registration_failed(\n        const std::string&amp; label,\n        int reason) = 0;\n\n    virtual void announce_synchronization_point(\n        const std::string&amp; label,\n        const std::vector&lt;uint8_t&gt;&amp; user_tag) = 0;\n\n    virtual void federation_synchronized(const std::string&amp; label) = 0;\n\n    // Object management callbacks\n    virtual void discover_object_instance(\n        ObjectInstanceHandle object_handle,\n        ObjectClassHandle object_class,\n        const std::string&amp; instance_name) = 0;\n\n    virtual void reflect_attribute_values(\n        ObjectInstanceHandle object_handle,\n        const std::map&lt;AttributeHandle, std::vector&lt;uint8_t&gt;&gt;&amp; attributes,\n        const std::vector&lt;uint8_t&gt;&amp; user_tag,\n        int order_type,\n        int transport_type) = 0;\n\n    virtual void reflect_attribute_values(\n        ObjectInstanceHandle object_handle,\n        const std::map&lt;AttributeHandle, std::vector&lt;uint8_t&gt;&gt;&amp; attributes,\n        const std::vector&lt;uint8_t&gt;&amp; user_tag,\n        int order_type,\n        int transport_type,\n        const LogicalTime&amp; time) = 0;\n\n    virtual void remove_object_instance(\n        ObjectInstanceHandle object_handle,\n        const std::vector&lt;uint8_t&gt;&amp; user_tag,\n        int order_type) = 0;\n\n    // Interaction callbacks\n    virtual void receive_interaction(\n        InteractionClassHandle interaction_handle,\n        const std::map&lt;ParameterHandle, std::vector&lt;uint8_t&gt;&gt;&amp; parameters,\n        const std::vector&lt;uint8_t&gt;&amp; user_tag,\n        int order_type,\n        int transport_type) = 0;\n\n    virtual void receive_interaction(\n        InteractionClassHandle interaction_handle,\n        const std::map&lt;ParameterHandle, std::vector&lt;uint8_t&gt;&gt;&amp; parameters,\n        const std::vector&lt;uint8_t&gt;&amp; user_tag,\n        int order_type,\n        int transport_type,\n        const LogicalTime&amp; time) = 0;\n\n    // Time management callbacks\n    virtual void time_regulation_enabled(const LogicalTime&amp; time) = 0;\n\n    virtual void time_constrained_enabled(const LogicalTime&amp; time) = 0;\n\n    virtual void time_advance_grant(const LogicalTime&amp; time) = 0;\n\n    // Ownership callbacks\n    virtual void request_attribute_ownership_release(\n        ObjectInstanceHandle object_handle,\n        const AttributeHandleSet&amp; attributes,\n        const std::vector&lt;uint8_t&gt;&amp; user_tag) = 0;\n\n    virtual void attribute_ownership_unavailable(\n        ObjectInstanceHandle object_handle,\n        const AttributeHandleSet&amp; attributes) = 0;\n\n    virtual void attribute_ownership_acquisition_notification(\n        ObjectInstanceHandle object_handle,\n        const AttributeHandleSet&amp; attributes,\n        const std::vector&lt;uint8_t&gt;&amp; user_tag) = 0;\n};\n\n}  // namespace jaguar::federation\n</code></pre>"},{"location":"api/federation/#hla-configuration","title":"HLA Configuration","text":"<pre><code>namespace jaguar::federation {\n\n// HLA configuration\nstruct HLAConfiguration {\n    bool enabled = false;\n    std::string federation_name;\n    std::string federate_name;\n    std::string federate_type;\n    std::vector&lt;std::string&gt; fom_modules;\n    std::string rti_designator;         // RTI-specific connection string\n    LogicalTimeInterval lookahead{0.1};\n    bool time_regulating = true;\n    bool time_constrained = true;\n    int resign_action = 0;              // NO_ACTION, DELETE_OBJECTS, etc.\n};\n\n// RTI types supported\nenum class RTIType {\n    Portico,\n    MAK,\n    Pitch,\n    OpenRTI,\n    Generic\n};\n\n// Factory function\nstd::unique_ptr&lt;IRTIAmbassador&gt; create_rti_ambassador(RTIType type = RTIType::Generic);\n\n}  // namespace jaguar::federation\n</code></pre>"},{"location":"api/federation/#usage-examples","title":"Usage Examples","text":""},{"location":"api/federation/#dis-entity-state-publication","title":"DIS Entity State Publication","text":"<pre><code>#include &lt;jaguar/federation/dis_protocol.h&gt;\n\nusing namespace jaguar::federation;\n\n// Configure DIS\nDISConfig config;\nconfig.enabled = true;\nconfig.broadcast_address = \"192.168.1.255\";\nconfig.port = 3000;\nconfig.site_id = 1;\nconfig.application_id = 1;\nconfig.exercise_id = 1;\nconfig.default_dr_algorithm = DeadReckoningAlgorithm::DRM_RVW;\nconfig.position_threshold = 1.0;\nconfig.orientation_threshold = 0.05;\n\nauto codec = create_dis_codec(true);\nauto network = create_dis_network(config);\nnetwork-&gt;initialize(config);\n\n// Create dead reckoning calculator\nDeadReckoningCalculator dr;\ndr.set_algorithm(DeadReckoningAlgorithm::DRM_RVW);\n\n// Entity state\nEntityIdentifier entity_id{1, 1, 100};\nEntityType entity_type{1, 2, 225, 1, 2, 0, 0};  // US F-16\n\n// Simulation loop\nVec3 last_published_position;\nEulerAngles last_published_orientation;\n\nwhile (running) {\n    auto state = engine.get_entity_state(aircraft);\n\n    // Convert to ECEF\n    Vec3 ecef_position = ned_to_ecef(state.position, reference_point);\n    Vec3 ecef_velocity = ned_to_ecef_velocity(state.velocity, reference_point);\n    EulerAngles orientation = quaternion_to_euler(state.orientation);\n\n    // Check if update needed\n    if (dr.needs_update(ecef_position, ecef_velocity, orientation,\n                       config.position_threshold, config.orientation_threshold)) {\n\n        // Build Entity State PDU\n        EntityStatePDU pdu;\n        pdu.header.protocol_version = 7;\n        pdu.header.exercise_id = config.exercise_id;\n        pdu.header.pdu_type = PDUType::EntityState;\n        pdu.header.timestamp = get_dis_timestamp();\n\n        pdu.entity_id = entity_id;\n        pdu.force_id = ForceId::Friendly;\n        pdu.entity_type = entity_type;\n        pdu.location = ecef_position;\n        pdu.linear_velocity = ecef_velocity;\n        pdu.orientation = orientation;\n        pdu.dr_algorithm = config.default_dr_algorithm;\n\n        // Set marking (callsign)\n        std::string callsign = \"VIPER01\";\n        std::copy(callsign.begin(), callsign.end(), pdu.marking);\n\n        // Encode and send\n        auto data = codec-&gt;encode(pdu);\n        network-&gt;send(data);\n\n        // Update dead reckoning state\n        dr.set_state(ecef_position, ecef_velocity,\n                    state.acceleration, orientation, state.angular_velocity);\n        last_published_position = ecef_position;\n        last_published_orientation = orientation;\n    }\n\n    // Receive and process incoming PDUs\n    auto received = network-&gt;receive();\n    for (const auto&amp; pdu_data : received) {\n        auto type = codec-&gt;get_pdu_type(pdu_data);\n\n        switch (type) {\n            case PDUType::EntityState: {\n                auto pdu = codec-&gt;decode_entity_state(pdu_data);\n                update_remote_entity(pdu);\n                break;\n            }\n            case PDUType::Fire: {\n                auto pdu = codec-&gt;decode_fire(pdu_data);\n                handle_fire_event(pdu);\n                break;\n            }\n            case PDUType::Detonation: {\n                auto pdu = codec-&gt;decode_detonation(pdu_data);\n                handle_detonation(pdu);\n                break;\n            }\n            default:\n                break;\n        }\n    }\n\n    engine.step(dt);\n}\n\nnetwork-&gt;shutdown();\n</code></pre>"},{"location":"api/federation/#hla-federation","title":"HLA Federation","text":"<pre><code>#include &lt;jaguar/federation/hla_rti.h&gt;\n\nusing namespace jaguar::federation;\n\n// Custom federate ambassador\nclass MyFederateAmbassador : public IFederateAmbassador {\n    bool time_advance_granted_ = false;\n    LogicalTime current_time_;\n    std::map&lt;ObjectInstanceHandle, RemoteEntity&gt; remote_entities_;\n\npublic:\n    void discover_object_instance(\n            ObjectInstanceHandle handle,\n            ObjectClassHandle class_handle,\n            const std::string&amp; name) override {\n        std::cout &lt;&lt; \"Discovered object: \" &lt;&lt; name &lt;&lt; \"\\n\";\n        remote_entities_[handle] = RemoteEntity{name, class_handle};\n    }\n\n    void reflect_attribute_values(\n            ObjectInstanceHandle handle,\n            const std::map&lt;AttributeHandle, std::vector&lt;uint8_t&gt;&gt;&amp; attributes,\n            const std::vector&lt;uint8_t&gt;&amp; tag,\n            int order, int transport) override {\n        auto&amp; entity = remote_entities_[handle];\n        for (const auto&amp; [attr, data] : attributes) {\n            entity.update_attribute(attr, data);\n        }\n    }\n\n    void time_advance_grant(const LogicalTime&amp; time) override {\n        current_time_ = time;\n        time_advance_granted_ = true;\n    }\n\n    bool is_time_advance_granted() const { return time_advance_granted_; }\n    void reset_time_advance() { time_advance_granted_ = false; }\n    LogicalTime get_current_time() const { return current_time_; }\n};\n\n// Main simulation\nint main() {\n    // Create RTI ambassador\n    auto rti = create_rti_ambassador(RTIType::Portico);\n    auto federate = std::make_unique&lt;MyFederateAmbassador&gt;();\n\n    // Connect to RTI\n    rti-&gt;connect(\"\");\n\n    // Create or join federation\n    try {\n        rti-&gt;create_federation_execution(\"AirCombat\",\n            {\"RPR_FOM_v2.0.xml\", \"JaguarExtensions.xml\"});\n    } catch (...) {\n        // Federation already exists\n    }\n\n    auto federate_handle = rti-&gt;join_federation_execution(\n        \"JaguarSim\", \"Simulation\", \"AirCombat\");\n\n    // Get handles\n    auto aircraft_class = rti-&gt;get_object_class_handle(\"BaseEntity.PhysicalEntity.Platform.Aircraft\");\n    auto position_attr = rti-&gt;get_attribute_handle(aircraft_class, \"WorldLocation\");\n    auto velocity_attr = rti-&gt;get_attribute_handle(aircraft_class, \"VelocityVector\");\n    auto orientation_attr = rti-&gt;get_attribute_handle(aircraft_class, \"Orientation\");\n\n    // Publish and subscribe\n    AttributeHandleSet attributes{position_attr, velocity_attr, orientation_attr};\n    rti-&gt;publish_object_class_attributes(aircraft_class, attributes);\n    rti-&gt;subscribe_object_class_attributes(aircraft_class, attributes);\n\n    // Enable time management\n    rti-&gt;enable_time_regulation(LogicalTimeInterval{0.1});\n    rti-&gt;enable_time_constrained();\n\n    // Register local aircraft\n    auto aircraft_handle = rti-&gt;register_object_instance(aircraft_class, \"VIPER01\");\n\n    // Simulation loop\n    LogicalTime sim_time{0.0};\n    double dt = 0.02;\n\n    while (running) {\n        // Request time advance\n        federate-&gt;reset_time_advance();\n        rti-&gt;time_advance_request(sim_time + LogicalTimeInterval{dt});\n\n        // Process callbacks until grant\n        while (!federate-&gt;is_time_advance_granted()) {\n            rti-&gt;tick();\n        }\n\n        // Run simulation step\n        engine.step(dt);\n\n        // Update HLA attributes\n        auto state = engine.get_entity_state(aircraft);\n        auto position_data = serialize_position(state.position);\n        auto velocity_data = serialize_velocity(state.velocity);\n        auto orientation_data = serialize_orientation(state.orientation);\n\n        std::map&lt;AttributeHandle, std::vector&lt;uint8_t&gt;&gt; attr_values;\n        attr_values[position_attr] = position_data;\n        attr_values[velocity_attr] = velocity_data;\n        attr_values[orientation_attr] = orientation_data;\n\n        rti-&gt;update_attribute_values(aircraft_handle, attr_values, {}, sim_time);\n\n        sim_time = federate-&gt;get_current_time();\n    }\n\n    // Cleanup\n    rti-&gt;delete_object_instance(aircraft_handle, {});\n    rti-&gt;resign_federation_execution(0);  // NO_ACTION\n    rti-&gt;destroy_federation_execution(\"AirCombat\");\n    rti-&gt;disconnect();\n\n    return 0;\n}\n</code></pre>"},{"location":"api/federation/#see-also","title":"See Also","text":"<ul> <li>Network Integration - High-level networking guide</li> <li>Architecture - System architecture overview</li> <li>Cloud Burst API - Distributed simulation support</li> <li>Configuration - Engine configuration</li> </ul>"},{"location":"api/gpu/","title":"GPU Compute API Reference","text":"<p>GPU Compute module (<code>jaguar_gpu</code>) provides hardware-accelerated computation through a unified abstraction layer supporting CUDA, OpenCL, Metal, and Vulkan backends.</p>"},{"location":"api/gpu/#overview","title":"Overview","text":"<p>The GPU module enables: - Backend Abstraction: Single API for multiple GPU backends - Kernel Management: Launch and manage compute kernels - Memory Management: Efficient buffer allocation and transfer - Device Queries: Capability detection and device selection</p>"},{"location":"api/gpu/#compute-backend","title":"Compute Backend","text":""},{"location":"api/gpu/#header","title":"Header","text":"<pre><code>#include &lt;jaguar/gpu/compute_backend.h&gt;\n</code></pre>"},{"location":"api/gpu/#backend-types","title":"Backend Types","text":"<pre><code>namespace jaguar::gpu {\n\n// Supported compute backends\nenum class BackendType {\n    CPU,            // Fallback CPU implementation\n    CUDA,           // NVIDIA CUDA\n    OpenCL,         // OpenCL (cross-platform)\n    Metal,          // Apple Metal\n    Vulkan          // Vulkan Compute\n};\n\n// Device types\nenum class DeviceType {\n    Unknown,\n    CPU,\n    GPU,\n    Accelerator,\n    Custom\n};\n\n// Memory types\nenum class MemoryType {\n    DeviceLocal,    // GPU memory only\n    HostVisible,    // CPU-accessible GPU memory\n    HostCached,     // Cached host memory\n    Shared          // Unified memory (CPU + GPU)\n};\n\n// Memory access patterns\nenum class MemoryAccess {\n    ReadOnly,\n    WriteOnly,\n    ReadWrite\n};\n\n// Kernel argument types\nenum class ArgType {\n    Buffer,\n    Scalar,\n    LocalMemory,\n    Image,\n    Sampler\n};\n\n}  // namespace jaguar::gpu\n</code></pre>"},{"location":"api/gpu/#handle-types","title":"Handle Types","text":"<pre><code>namespace jaguar::gpu {\n\n// Buffer handle (opaque reference to GPU memory)\nstruct BufferHandle {\n    uint64_t id = 0;\n    bool is_valid() const { return id != 0; }\n    bool operator==(const BufferHandle&amp; other) const { return id == other.id; }\n};\n\n// Stream/queue handle for async operations\nstruct StreamHandle {\n    uint64_t id = 0;\n    bool is_valid() const { return id != 0; }\n};\n\n// Event handle for synchronization\nstruct EventHandle {\n    uint64_t id = 0;\n    bool is_valid() const { return id != 0; }\n};\n\n// Kernel handle\nstruct KernelHandle {\n    uint64_t id = 0;\n    bool is_valid() const { return id != 0; }\n};\n\n}  // namespace jaguar::gpu\n</code></pre>"},{"location":"api/gpu/#result-types","title":"Result Types","text":"<pre><code>namespace jaguar::gpu {\n\n// Backend operation result\nstruct BackendResult {\n    bool success;\n    std::string error_message;\n    int error_code = 0;\n};\n\n// Device capabilities\nstruct DeviceCapabilities {\n    std::string device_name;\n    std::string vendor;\n    std::string driver_version;\n    DeviceType device_type;\n\n    // Compute capabilities\n    uint32_t compute_units;\n    uint32_t max_work_group_size;\n    std::array&lt;uint32_t, 3&gt; max_work_item_sizes;\n    uint32_t max_work_item_dimensions;\n    uint32_t warp_size;                     // CUDA warp / AMD wavefront\n\n    // Memory capabilities\n    uint64_t global_memory_size;\n    uint64_t local_memory_size;             // Shared memory per block\n    uint64_t constant_memory_size;\n    uint64_t max_buffer_size;\n    uint32_t memory_bus_width;\n    uint64_t memory_bandwidth;              // bytes/sec\n\n    // Features\n    bool supports_double_precision;\n    bool supports_half_precision;\n    bool supports_atomics;\n    bool supports_images;\n    bool supports_unified_memory;\n\n    // Clock speeds (MHz)\n    uint32_t clock_frequency;\n    uint32_t memory_clock_frequency;\n};\n\n// Launch configuration\nstruct LaunchConfig {\n    std::array&lt;uint32_t, 3&gt; global_size = {1, 1, 1};    // Total work items\n    std::array&lt;uint32_t, 3&gt; local_size = {1, 1, 1};     // Work group size\n    uint32_t shared_memory_size = 0;                     // Dynamic shared memory\n    StreamHandle stream;                                 // Execution stream\n\n    // Helper constructors\n    static LaunchConfig linear(uint32_t total_items, uint32_t group_size = 256);\n    static LaunchConfig grid_2d(uint32_t width, uint32_t height,\n                               uint32_t block_x = 16, uint32_t block_y = 16);\n    static LaunchConfig grid_3d(uint32_t x, uint32_t y, uint32_t z,\n                               uint32_t block_x = 8, uint32_t block_y = 8,\n                               uint32_t block_z = 8);\n};\n\n// Kernel argument\nstruct KernelArg {\n    ArgType type;\n    BufferHandle buffer;            // For buffer arguments\n    const void* scalar_ptr;         // For scalar arguments\n    size_t scalar_size;\n    size_t local_memory_size;       // For local memory arguments\n\n    // Factory methods\n    static KernelArg from_buffer(BufferHandle buffer);\n    static KernelArg from_scalar(const void* ptr, size_t size);\n    template&lt;typename T&gt;\n    static KernelArg from_value(const T&amp; value);\n    static KernelArg local_memory(size_t size);\n};\n\n}  // namespace jaguar::gpu\n</code></pre>"},{"location":"api/gpu/#icomputebackend-interface","title":"IComputeBackend Interface","text":"<pre><code>namespace jaguar::gpu {\n\nclass IComputeBackend {\npublic:\n    virtual ~IComputeBackend() = default;\n\n    // Lifecycle\n    virtual BackendResult initialize() = 0;\n    virtual void shutdown() = 0;\n    virtual BackendType get_type() const = 0;\n\n    // Device management\n    virtual size_t get_device_count() const = 0;\n    virtual DeviceCapabilities get_device_capabilities(size_t device_index = 0) const = 0;\n    virtual BackendResult select_device(size_t device_index) = 0;\n    virtual size_t get_selected_device() const = 0;\n\n    // Buffer management\n    virtual BufferHandle create_buffer(size_t size, MemoryType type = MemoryType::DeviceLocal) = 0;\n    virtual BufferHandle create_buffer(size_t size, const void* initial_data,\n                                       MemoryType type = MemoryType::DeviceLocal) = 0;\n    virtual void destroy_buffer(BufferHandle buffer) = 0;\n    virtual size_t get_buffer_size(BufferHandle buffer) const = 0;\n\n    // Memory transfers\n    virtual BackendResult copy_to_device(BufferHandle dst, const void* src, size_t size) = 0;\n    virtual BackendResult copy_to_device_async(BufferHandle dst, const void* src, size_t size,\n                                               StreamHandle stream) = 0;\n    virtual BackendResult copy_from_device(void* dst, BufferHandle src, size_t size) = 0;\n    virtual BackendResult copy_from_device_async(void* dst, BufferHandle src, size_t size,\n                                                 StreamHandle stream) = 0;\n    virtual BackendResult copy_device_to_device(BufferHandle dst, BufferHandle src, size_t size) = 0;\n\n    // Memory mapping (for HostVisible buffers)\n    virtual void* map_buffer(BufferHandle buffer, MemoryAccess access) = 0;\n    virtual void unmap_buffer(BufferHandle buffer) = 0;\n\n    // Kernel management\n    virtual KernelHandle load_kernel(const std::string&amp; source,\n                                     const std::string&amp; kernel_name,\n                                     const std::string&amp; compile_options = \"\") = 0;\n    virtual KernelHandle load_kernel_from_binary(const std::vector&lt;uint8_t&gt;&amp; binary,\n                                                 const std::string&amp; kernel_name) = 0;\n    virtual void destroy_kernel(KernelHandle kernel) = 0;\n\n    // Kernel execution\n    virtual BackendResult launch_kernel(KernelHandle kernel,\n                                        const LaunchConfig&amp; config,\n                                        const std::vector&lt;KernelArg&gt;&amp; args) = 0;\n\n    // Stream management\n    virtual StreamHandle create_stream() = 0;\n    virtual void destroy_stream(StreamHandle stream) = 0;\n    virtual BackendResult synchronize_stream(StreamHandle stream) = 0;\n    virtual BackendResult synchronize_device() = 0;\n\n    // Event management\n    virtual EventHandle create_event() = 0;\n    virtual void destroy_event(EventHandle event) = 0;\n    virtual BackendResult record_event(EventHandle event, StreamHandle stream) = 0;\n    virtual BackendResult wait_for_event(EventHandle event, StreamHandle stream) = 0;\n    virtual bool is_event_complete(EventHandle event) = 0;\n    virtual float get_elapsed_time(EventHandle start, EventHandle end) = 0;  // milliseconds\n\n    // Utilities\n    virtual size_t get_available_memory() const = 0;\n    virtual size_t get_total_memory() const = 0;\n};\n\n}  // namespace jaguar::gpu\n</code></pre>"},{"location":"api/gpu/#ikernel-interface","title":"IKernel Interface","text":"<pre><code>namespace jaguar::gpu {\n\n// Higher-level kernel wrapper\nclass IKernel {\npublic:\n    virtual ~IKernel() = default;\n\n    // Get kernel name\n    virtual std::string get_name() const = 0;\n\n    // Get argument information\n    virtual size_t get_num_arguments() const = 0;\n    virtual ArgType get_argument_type(size_t index) const = 0;\n\n    // Set arguments\n    virtual void set_argument(size_t index, BufferHandle buffer) = 0;\n    virtual void set_argument(size_t index, const void* data, size_t size) = 0;\n    template&lt;typename T&gt;\n    void set_argument(size_t index, const T&amp; value) {\n        set_argument(index, &amp;value, sizeof(T));\n    }\n    virtual void set_local_memory_argument(size_t index, size_t size) = 0;\n\n    // Launch\n    virtual BackendResult launch(const LaunchConfig&amp; config) = 0;\n\n    // Get preferred work group size\n    virtual size_t get_preferred_work_group_size() const = 0;\n\n    // Get local memory usage\n    virtual size_t get_local_memory_usage() const = 0;\n};\n\n}  // namespace jaguar::gpu\n</code></pre>"},{"location":"api/gpu/#backend-factory","title":"Backend Factory","text":"<pre><code>namespace jaguar::gpu {\n\nclass BackendFactory {\npublic:\n    // Create specific backend\n    static std::unique_ptr&lt;IComputeBackend&gt; create(BackendType type);\n\n    // Create best available backend (prioritizes GPU over CPU)\n    static std::unique_ptr&lt;IComputeBackend&gt; create_best_available();\n\n    // Query available backends\n    static std::vector&lt;BackendType&gt; get_available_backends();\n\n    // Check if specific backend is available\n    static bool is_backend_available(BackendType type);\n};\n\n}  // namespace jaguar::gpu\n</code></pre>"},{"location":"api/gpu/#usage-examples","title":"Usage Examples","text":""},{"location":"api/gpu/#basic-buffer-operations","title":"Basic Buffer Operations","text":"<pre><code>#include &lt;jaguar/gpu/compute_backend.h&gt;\n\nusing namespace jaguar::gpu;\n\n// Create best available backend\nauto backend = BackendFactory::create_best_available();\nbackend-&gt;initialize();\n\n// Print device info\nauto caps = backend-&gt;get_device_capabilities();\nstd::cout &lt;&lt; \"Device: \" &lt;&lt; caps.device_name &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Memory: \" &lt;&lt; caps.global_memory_size / (1024*1024) &lt;&lt; \" MB\\n\";\nstd::cout &lt;&lt; \"Compute units: \" &lt;&lt; caps.compute_units &lt;&lt; \"\\n\";\n\n// Create buffers\nconst size_t N = 1024 * 1024;\nstd::vector&lt;float&gt; host_input(N, 1.0f);\nstd::vector&lt;float&gt; host_output(N);\n\nauto input_buffer = backend-&gt;create_buffer(N * sizeof(float), host_input.data());\nauto output_buffer = backend-&gt;create_buffer(N * sizeof(float));\n\n// ... compute ...\n\n// Read results\nbackend-&gt;copy_from_device(host_output.data(), output_buffer, N * sizeof(float));\n\n// Cleanup\nbackend-&gt;destroy_buffer(input_buffer);\nbackend-&gt;destroy_buffer(output_buffer);\nbackend-&gt;shutdown();\n</code></pre>"},{"location":"api/gpu/#kernel-compilation-and-launch","title":"Kernel Compilation and Launch","text":"<pre><code>#include &lt;jaguar/gpu/compute_backend.h&gt;\n\nusing namespace jaguar::gpu;\n\nauto backend = BackendFactory::create(BackendType::CUDA);\nbackend-&gt;initialize();\n\n// Kernel source (CUDA)\nconst char* kernel_source = R\"(\nextern \"C\" __global__ void vector_add(\n    const float* a,\n    const float* b,\n    float* c,\n    int n\n) {\n    int idx = blockIdx.x * blockDim.x + threadIdx.x;\n    if (idx &lt; n) {\n        c[idx] = a[idx] + b[idx];\n    }\n}\n)\";\n\n// Compile kernel\nauto kernel = backend-&gt;load_kernel(kernel_source, \"vector_add\", \"-O3\");\n\n// Create buffers\nconst int N = 1000000;\nstd::vector&lt;float&gt; a(N, 1.0f), b(N, 2.0f), c(N);\n\nauto buf_a = backend-&gt;create_buffer(N * sizeof(float), a.data());\nauto buf_b = backend-&gt;create_buffer(N * sizeof(float), b.data());\nauto buf_c = backend-&gt;create_buffer(N * sizeof(float));\n\n// Set kernel arguments\nstd::vector&lt;KernelArg&gt; args = {\n    KernelArg::from_buffer(buf_a),\n    KernelArg::from_buffer(buf_b),\n    KernelArg::from_buffer(buf_c),\n    KernelArg::from_value(N)\n};\n\n// Launch configuration\nauto config = LaunchConfig::linear(N, 256);\n\n// Launch kernel\nauto result = backend-&gt;launch_kernel(kernel, config, args);\nif (!result.success) {\n    std::cerr &lt;&lt; \"Kernel launch failed: \" &lt;&lt; result.error_message &lt;&lt; \"\\n\";\n}\n\n// Synchronize and read results\nbackend-&gt;synchronize_device();\nbackend-&gt;copy_from_device(c.data(), buf_c, N * sizeof(float));\n\n// Verify\nfor (int i = 0; i &lt; 10; ++i) {\n    std::cout &lt;&lt; \"c[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; c[i] &lt;&lt; \"\\n\";  // Should be 3.0\n}\n\n// Cleanup\nbackend-&gt;destroy_buffer(buf_a);\nbackend-&gt;destroy_buffer(buf_b);\nbackend-&gt;destroy_buffer(buf_c);\nbackend-&gt;destroy_kernel(kernel);\nbackend-&gt;shutdown();\n</code></pre>"},{"location":"api/gpu/#async-operations-with-streams","title":"Async Operations with Streams","text":"<pre><code>#include &lt;jaguar/gpu/compute_backend.h&gt;\n\nusing namespace jaguar::gpu;\n\nauto backend = BackendFactory::create_best_available();\nbackend-&gt;initialize();\n\n// Create multiple streams for concurrent operations\nauto stream1 = backend-&gt;create_stream();\nauto stream2 = backend-&gt;create_stream();\n\n// Create events for timing\nauto start_event = backend-&gt;create_event();\nauto end_event = backend-&gt;create_event();\n\nconst size_t N = 10000000;\nstd::vector&lt;float&gt; host_a(N), host_b(N);\n\nauto buf_a = backend-&gt;create_buffer(N * sizeof(float), MemoryType::DeviceLocal);\nauto buf_b = backend-&gt;create_buffer(N * sizeof(float), MemoryType::DeviceLocal);\n\n// Record start\nbackend-&gt;record_event(start_event, stream1);\n\n// Async copy on stream1\nbackend-&gt;copy_to_device_async(buf_a, host_a.data(), N * sizeof(float), stream1);\n\n// Async copy on stream2 (runs concurrently)\nbackend-&gt;copy_to_device_async(buf_b, host_b.data(), N * sizeof(float), stream2);\n\n// Launch kernels (after respective copies complete)\n// ... kernel launches ...\n\n// Record end\nbackend-&gt;record_event(end_event, stream1);\n\n// Synchronize\nbackend-&gt;synchronize_stream(stream1);\nbackend-&gt;synchronize_stream(stream2);\n\n// Get elapsed time\nfloat elapsed_ms = backend-&gt;get_elapsed_time(start_event, end_event);\nstd::cout &lt;&lt; \"Elapsed time: \" &lt;&lt; elapsed_ms &lt;&lt; \" ms\\n\";\n\n// Cleanup\nbackend-&gt;destroy_event(start_event);\nbackend-&gt;destroy_event(end_event);\nbackend-&gt;destroy_stream(stream1);\nbackend-&gt;destroy_stream(stream2);\nbackend-&gt;destroy_buffer(buf_a);\nbackend-&gt;destroy_buffer(buf_b);\nbackend-&gt;shutdown();\n</code></pre>"},{"location":"api/gpu/#cross-platform-kernel","title":"Cross-Platform Kernel","text":"<pre><code>#include &lt;jaguar/gpu/compute_backend.h&gt;\n\nusing namespace jaguar::gpu;\n\n// OpenCL kernel (portable)\nconst char* opencl_kernel = R\"(\n__kernel void physics_update(\n    __global float4* positions,\n    __global float4* velocities,\n    __global const float4* forces,\n    __global const float* masses,\n    float dt,\n    int num_entities\n) {\n    int gid = get_global_id(0);\n    if (gid &gt;= num_entities) return;\n\n    float mass = masses[gid];\n    float4 acceleration = forces[gid] / mass;\n\n    velocities[gid] += acceleration * dt;\n    positions[gid] += velocities[gid] * dt;\n}\n)\";\n\n// CUDA kernel (NVIDIA-optimized)\nconst char* cuda_kernel = R\"(\nextern \"C\" __global__ void physics_update(\n    float4* positions,\n    float4* velocities,\n    const float4* forces,\n    const float* masses,\n    float dt,\n    int num_entities\n) {\n    int gid = blockIdx.x * blockDim.x + threadIdx.x;\n    if (gid &gt;= num_entities) return;\n\n    float mass = masses[gid];\n    float4 acceleration = make_float4(\n        forces[gid].x / mass,\n        forces[gid].y / mass,\n        forces[gid].z / mass,\n        0.0f\n    );\n\n    velocities[gid].x += acceleration.x * dt;\n    velocities[gid].y += acceleration.y * dt;\n    velocities[gid].z += acceleration.z * dt;\n\n    positions[gid].x += velocities[gid].x * dt;\n    positions[gid].y += velocities[gid].y * dt;\n    positions[gid].z += velocities[gid].z * dt;\n}\n)\";\n\n// Select appropriate kernel based on backend\nauto backend = BackendFactory::create_best_available();\nbackend-&gt;initialize();\n\nconst char* kernel_source = nullptr;\nswitch (backend-&gt;get_type()) {\n    case BackendType::CUDA:\n        kernel_source = cuda_kernel;\n        break;\n    case BackendType::OpenCL:\n    case BackendType::CPU:\n    default:\n        kernel_source = opencl_kernel;\n        break;\n}\n\nauto kernel = backend-&gt;load_kernel(kernel_source, \"physics_update\");\n\n// Use kernel for physics simulation\n// ...\n</code></pre>"},{"location":"api/gpu/#memory-mapped-io","title":"Memory-Mapped I/O","text":"<pre><code>#include &lt;jaguar/gpu/compute_backend.h&gt;\n\nusing namespace jaguar::gpu;\n\nauto backend = BackendFactory::create_best_available();\nbackend-&gt;initialize();\n\n// Create host-visible buffer\nconst size_t N = 1024;\nauto buffer = backend-&gt;create_buffer(\n    N * sizeof(float),\n    MemoryType::HostVisible\n);\n\n// Map buffer for CPU access\nfloat* mapped = static_cast&lt;float*&gt;(\n    backend-&gt;map_buffer(buffer, MemoryAccess::WriteOnly)\n);\n\n// Write directly to GPU memory\nfor (size_t i = 0; i &lt; N; ++i) {\n    mapped[i] = static_cast&lt;float&gt;(i);\n}\n\n// Unmap before GPU use\nbackend-&gt;unmap_buffer(buffer);\n\n// ... use buffer in GPU kernel ...\n\n// Map again to read results\nmapped = static_cast&lt;float*&gt;(\n    backend-&gt;map_buffer(buffer, MemoryAccess::ReadOnly)\n);\n\nfor (size_t i = 0; i &lt; 10; ++i) {\n    std::cout &lt;&lt; \"buffer[\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; mapped[i] &lt;&lt; \"\\n\";\n}\n\nbackend-&gt;unmap_buffer(buffer);\nbackend-&gt;destroy_buffer(buffer);\nbackend-&gt;shutdown();\n</code></pre>"},{"location":"api/gpu/#physics-simulation-on-gpu","title":"Physics Simulation on GPU","text":"<pre><code>#include &lt;jaguar/gpu/compute_backend.h&gt;\n#include &lt;jaguar/jaguar.h&gt;\n\nusing namespace jaguar;\nusing namespace jaguar::gpu;\n\nclass GPUPhysicsEngine {\n    std::unique_ptr&lt;IComputeBackend&gt; backend_;\n    KernelHandle integration_kernel_;\n    KernelHandle force_kernel_;\n\n    BufferHandle positions_;\n    BufferHandle velocities_;\n    BufferHandle forces_;\n    BufferHandle masses_;\n\n    size_t num_entities_ = 0;\n\npublic:\n    void initialize(size_t max_entities) {\n        backend_ = BackendFactory::create_best_available();\n        backend_-&gt;initialize();\n\n        // Allocate buffers for max entities\n        size_t vec4_size = max_entities * 4 * sizeof(float);\n        size_t scalar_size = max_entities * sizeof(float);\n\n        positions_ = backend_-&gt;create_buffer(vec4_size);\n        velocities_ = backend_-&gt;create_buffer(vec4_size);\n        forces_ = backend_-&gt;create_buffer(vec4_size);\n        masses_ = backend_-&gt;create_buffer(scalar_size);\n\n        // Load kernels\n        integration_kernel_ = backend_-&gt;load_kernel(\n            integration_kernel_source, \"integrate\");\n        force_kernel_ = backend_-&gt;load_kernel(\n            force_kernel_source, \"compute_forces\");\n    }\n\n    void update_entities(const std::vector&lt;physics::EntityState&gt;&amp; states) {\n        num_entities_ = states.size();\n\n        // Pack data\n        std::vector&lt;float&gt; pos_data(num_entities_ * 4);\n        std::vector&lt;float&gt; vel_data(num_entities_ * 4);\n        std::vector&lt;float&gt; mass_data(num_entities_);\n\n        for (size_t i = 0; i &lt; num_entities_; ++i) {\n            pos_data[i*4 + 0] = states[i].position.x;\n            pos_data[i*4 + 1] = states[i].position.y;\n            pos_data[i*4 + 2] = states[i].position.z;\n            pos_data[i*4 + 3] = 0.0f;\n\n            vel_data[i*4 + 0] = states[i].velocity.x;\n            vel_data[i*4 + 1] = states[i].velocity.y;\n            vel_data[i*4 + 2] = states[i].velocity.z;\n            vel_data[i*4 + 3] = 0.0f;\n\n            mass_data[i] = states[i].mass;\n        }\n\n        // Upload to GPU\n        backend_-&gt;copy_to_device(positions_, pos_data.data(),\n                                pos_data.size() * sizeof(float));\n        backend_-&gt;copy_to_device(velocities_, vel_data.data(),\n                                vel_data.size() * sizeof(float));\n        backend_-&gt;copy_to_device(masses_, mass_data.data(),\n                                mass_data.size() * sizeof(float));\n    }\n\n    void step(float dt) {\n        auto config = LaunchConfig::linear(num_entities_, 256);\n\n        // Compute forces\n        std::vector&lt;KernelArg&gt; force_args = {\n            KernelArg::from_buffer(positions_),\n            KernelArg::from_buffer(velocities_),\n            KernelArg::from_buffer(forces_),\n            KernelArg::from_buffer(masses_),\n            KernelArg::from_value(static_cast&lt;int&gt;(num_entities_))\n        };\n        backend_-&gt;launch_kernel(force_kernel_, config, force_args);\n\n        // Integrate\n        std::vector&lt;KernelArg&gt; int_args = {\n            KernelArg::from_buffer(positions_),\n            KernelArg::from_buffer(velocities_),\n            KernelArg::from_buffer(forces_),\n            KernelArg::from_buffer(masses_),\n            KernelArg::from_value(dt),\n            KernelArg::from_value(static_cast&lt;int&gt;(num_entities_))\n        };\n        backend_-&gt;launch_kernel(integration_kernel_, config, int_args);\n\n        backend_-&gt;synchronize_device();\n    }\n\n    void read_results(std::vector&lt;physics::EntityState&gt;&amp; states) {\n        std::vector&lt;float&gt; pos_data(num_entities_ * 4);\n        std::vector&lt;float&gt; vel_data(num_entities_ * 4);\n\n        backend_-&gt;copy_from_device(pos_data.data(), positions_,\n                                  pos_data.size() * sizeof(float));\n        backend_-&gt;copy_from_device(vel_data.data(), velocities_,\n                                  vel_data.size() * sizeof(float));\n\n        for (size_t i = 0; i &lt; num_entities_; ++i) {\n            states[i].position.x = pos_data[i*4 + 0];\n            states[i].position.y = pos_data[i*4 + 1];\n            states[i].position.z = pos_data[i*4 + 2];\n\n            states[i].velocity.x = vel_data[i*4 + 0];\n            states[i].velocity.y = vel_data[i*4 + 1];\n            states[i].velocity.z = vel_data[i*4 + 2];\n        }\n    }\n\n    void shutdown() {\n        backend_-&gt;destroy_kernel(integration_kernel_);\n        backend_-&gt;destroy_kernel(force_kernel_);\n        backend_-&gt;destroy_buffer(positions_);\n        backend_-&gt;destroy_buffer(velocities_);\n        backend_-&gt;destroy_buffer(forces_);\n        backend_-&gt;destroy_buffer(masses_);\n        backend_-&gt;shutdown();\n    }\n};\n</code></pre>"},{"location":"api/gpu/#see-also","title":"See Also","text":"<ul> <li>Architecture - System architecture overview</li> <li>Machine Learning API - GPU-accelerated ML inference</li> <li>Configuration - Engine configuration</li> </ul>"},{"location":"api/land/","title":"Land Domain API Reference","text":"<p>Terramechanics, suspension, and tracked/wheeled vehicle APIs.</p> <p>Header: <code>jaguar/domain/land.h</code></p>"},{"location":"api/land/#soilproperties","title":"SoilProperties","text":"<p>Bekker-Wong soil parameters for terramechanics.</p> <pre><code>struct SoilProperties {\n    Real k_c{0.0};      // Cohesive modulus (kN/m^(n+1))\n    Real k_phi{0.0};    // Frictional modulus (kN/m^(n+2))\n    Real n{1.0};        // Deformation exponent\n    Real c{0.0};        // Cohesion (kPa)\n    Real phi{0.0};      // Internal friction angle (rad)\n    Real K{0.0};        // Shear deformation modulus (m)\n\n    // Preset soil types\n    static SoilProperties DrySand();\n    static SoilProperties WetSand();\n    static SoilProperties Clay();\n    static SoilProperties Snow();\n    static SoilProperties Asphalt();\n    static SoilProperties Mud();\n    static SoilProperties Gravel();\n};\n</code></pre>"},{"location":"api/land/#preset-values","title":"Preset Values","text":"Soil Type k_c k_phi n c (kPa) \u03c6 (deg) Dry Sand 0.99 1528 1.10 1.04 28 Wet Sand 5.27 1515 0.73 1.72 29 Clay 13.19 692 0.50 4.14 13 Snow 4.37 196 1.60 1.03 19.7 Asphalt 10\u2076 10\u2076 0.0 1000 45"},{"location":"api/land/#example","title":"Example","text":"<pre><code>// Use preset\nauto soil = domain::land::SoilProperties::DrySand();\n\n// Or customize\ndomain::land::SoilProperties custom_soil;\ncustom_soil.k_c = 5.0;\ncustom_soil.k_phi = 1000.0;\ncustom_soil.n = 0.9;\ncustom_soil.c = 2.0;\ncustom_soil.phi = 30.0 * DEG_TO_RAD;\n</code></pre>"},{"location":"api/land/#terramechanicsmodel","title":"TerramechanicsModel","text":"<p>Bekker-Wong pressure-sinkage and shear-displacement model.</p> <pre><code>class TerramechanicsModel : public physics::ITerramechanicsModel {\npublic:\n    // Configuration\n    void set_contact_area(Real width, Real length);  // m\n    void set_vehicle_weight(Real weight_n);          // N\n    void set_soil(const SoilProperties&amp; soil);\n\n    // IForceGenerator\n    void compute_forces(const physics::EntityState&amp; state,\n                        const environment::Environment&amp; env,\n                        Real dt,\n                        physics::EntityForces&amp; forces) override;\n\n    // ITerramechanicsModel queries\n    Real get_sinkage() const override;            // m\n    Real get_motion_resistance() const override;  // N\n    Real get_traction() const override;           // N\n    Real get_slip_ratio() const override;         // 0-1\n\n    // Additional queries\n    Real get_ground_pressure() const;   // Pa\n    Real get_bearing_capacity() const;  // Pa\n    bool is_mobility_limited() const;   // True if sinking\n};\n</code></pre>"},{"location":"api/land/#example_1","title":"Example","text":"<pre><code>domain::land::TerramechanicsModel terra;\n\n// Configure for tank tracks\nterra.set_contact_area(0.63, 4.6);  // Track: 63cm x 4.6m\nterra.set_vehicle_weight(62000.0 * constants::G0);  // 62 tonnes\n\n// Set soil (can change dynamically based on terrain)\nauto soil = domain::land::SoilProperties::DrySand();\nterra.set_soil(soil);\n\n// In simulation loop\nphysics::EntityForces forces;\nterra.compute_forces(state, env, dt, forces);\n\n// Check mobility\nReal sinkage = terra.get_sinkage();\nif (sinkage &gt; 0.3) {\n    std::cout &lt;&lt; \"Warning: Vehicle stuck! Sinkage: \" &lt;&lt; sinkage &lt;&lt; \" m\\n\";\n}\n\nstd::cout &lt;&lt; \"Motion resistance: \" &lt;&lt; terra.get_motion_resistance() &lt;&lt; \" N\\n\";\nstd::cout &lt;&lt; \"Available traction: \" &lt;&lt; terra.get_traction() &lt;&lt; \" N\\n\";\n</code></pre>"},{"location":"api/land/#suspensionunit","title":"SuspensionUnit","text":"<p>Individual suspension unit (road wheel, spring, damper).</p> <pre><code>struct SuspensionUnit {\n    Real spring_k{50000.0};      // Spring stiffness (N/m)\n    Real damper_c{5000.0};       // Damping coefficient (N\u00b7s/m)\n    Real preload{0.0};           // Preload force (N)\n    Real travel_max{0.3};        // Maximum travel (m)\n    Real travel_min{0.0};        // Minimum travel (m)\n    Real current_position{0.0};  // Current compression (m)\n    Real current_velocity{0.0};  // Compression rate (m/s)\n\n    // Calculate spring-damper force\n    Real calculate_force() const;\n\n    // Update state\n    void update(Real ground_height, Real wheel_height, Real dt);\n\n    // Check limits\n    bool is_bottomed_out() const;\n    bool is_topped_out() const;\n};\n</code></pre>"},{"location":"api/land/#example_2","title":"Example","text":"<pre><code>domain::land::SuspensionUnit wheel;\nwheel.spring_k = 300000.0;    // 300 kN/m (heavy vehicle)\nwheel.damper_c = 30000.0;     // 30 kN\u00b7s/m\nwheel.travel_max = 0.40;      // 40 cm travel\nwheel.preload = 10000.0;      // 10 kN preload\n\n// Update based on terrain\nReal terrain_height = env.terrain.elevation;\nReal wheel_height = vehicle_height - wheel_offset;\nwheel.update(terrain_height, wheel_height, dt);\n\n// Get force\nReal suspension_force = wheel.calculate_force();\n</code></pre>"},{"location":"api/land/#suspensionmodel","title":"SuspensionModel","text":"<p>Complete vehicle suspension system.</p> <pre><code>class SuspensionModel {\npublic:\n    // Add suspension units\n    void add_unit(const Vec3&amp; position, const SuspensionUnit&amp; unit);\n    void clear_units();\n\n    // Update all units\n    void update(const physics::EntityState&amp; state,\n                const environment::Environment&amp; env,\n                Real dt);\n\n    // Get total forces and torques\n    Vec3 get_total_force() const;\n    Vec3 get_total_torque() const;\n\n    // Query individual units\n    SizeT unit_count() const;\n    const SuspensionUnit&amp; get_unit(SizeT index) const;\n    Real get_average_compression() const;\n};\n</code></pre>"},{"location":"api/land/#example_3","title":"Example","text":"<pre><code>domain::land::SuspensionModel suspension;\n\n// Configure suspension unit template\ndomain::land::SuspensionUnit wheel;\nwheel.spring_k = 300000.0;\nwheel.damper_c = 30000.0;\nwheel.travel_max = 0.40;\n\n// Add 7 road wheels per side (tank)\nReal wheel_spacing = 0.8;  // meters\nfor (int i = 0; i &lt; 7; ++i) {\n    Real x = -3.0 + i * wheel_spacing;\n\n    // Left side\n    suspension.add_unit(Vec3{x, 1.5, -0.8}, wheel);\n\n    // Right side\n    suspension.add_unit(Vec3{x, -1.5, -0.8}, wheel);\n}\n\n// In simulation loop\nsuspension.update(state, env, dt);\n\nphysics::EntityForces forces;\nforces.add_force(suspension.get_total_force());\nforces.add_torque(suspension.get_total_torque());\n</code></pre>"},{"location":"api/land/#trackedvehiclemodel","title":"TrackedVehicleModel","text":"<p>Track system dynamics.</p> <pre><code>class TrackedVehicleModel {\npublic:\n    struct TrackState {\n        Real tension{10000.0};  // Track tension (N)\n        Real velocity{0.0};     // Track linear velocity (m/s)\n        Real slip{0.0};         // Track slip ratio\n    };\n\n    // Configuration\n    void set_sprocket_radius(Real radius);  // m\n    void set_sprocket_max_torque(Real torque);  // N\u00b7m\n    void set_track_width(Real width);  // m\n    void set_track_length(Real length);  // m\n    void set_idler_radius(Real radius);  // m\n\n    // Update tracks\n    void update(Real left_torque, Real right_torque,\n                Real load, const SoilProperties&amp; soil, Real dt);\n\n    // Queries\n    const TrackState&amp; get_left_track() const;\n    const TrackState&amp; get_right_track() const;\n    Real get_propulsive_force() const;\n    Real get_steering_moment() const;\n\n    // Steering (differential)\n    void set_steering(Real steer);  // -1 to +1 (left to right)\n};\n</code></pre>"},{"location":"api/land/#example_4","title":"Example","text":"<pre><code>domain::land::TrackedVehicleModel tracks;\n\n// Configure\ntracks.set_sprocket_radius(0.33);\ntracks.set_sprocket_max_torque(100000.0);  // 100 kN\u00b7m\ntracks.set_track_width(0.63);\ntracks.set_track_length(4.6);\n\n// In simulation loop\nReal engine_torque = throttle * max_engine_torque;\n\n// Apply steering (differential)\ntracks.set_steering(steering_input);\n\n// Update\nauto soil = domain::land::SoilProperties::DrySand();\ntracks.update(engine_torque, engine_torque, vehicle_weight, soil, dt);\n\n// Get forces\nReal propulsion = tracks.get_propulsive_force();\nReal steering_moment = tracks.get_steering_moment();\n\nphysics::EntityForces forces;\nVec3 thrust_body{propulsion, 0.0, 0.0};\nforces.add_force(state.orientation.rotate(thrust_body));\nforces.add_torque(Vec3{0.0, 0.0, steering_moment});\n</code></pre>"},{"location":"api/land/#wheeledvehiclemodel","title":"WheeledVehicleModel","text":"<p>Wheeled vehicle drivetrain and tire model.</p> <pre><code>class WheeledVehicleModel {\npublic:\n    struct WheelState {\n        Real angular_velocity{0.0};  // rad/s\n        Real slip_ratio{0.0};\n        Real slip_angle{0.0};        // rad\n        Real normal_load{0.0};       // N\n        Vec3 force{0, 0, 0};         // Tire force\n    };\n\n    // Configuration\n    void set_wheel_radius(Real radius);  // m\n    void set_wheel_inertia(Real inertia);  // kg\u00b7m\u00b2\n\n    // Add wheels (position relative to CG)\n    void add_wheel(const Vec3&amp; position, bool is_driven, bool is_steered);\n\n    // Control\n    void set_drive_torque(Real torque);  // N\u00b7m (to driven wheels)\n    void set_brake_torque(Real torque);  // N\u00b7m\n    void set_steering_angle(Real angle);  // rad\n\n    // Update\n    void update(const physics::EntityState&amp; state,\n                const SoilProperties&amp; soil, Real dt);\n\n    // Queries\n    Vec3 get_total_force() const;\n    Vec3 get_total_torque() const;\n    const WheelState&amp; get_wheel(SizeT index) const;\n    SizeT wheel_count() const;\n};\n</code></pre>"},{"location":"api/land/#example_5","title":"Example","text":"<pre><code>domain::land::WheeledVehicleModel wheels;\n\n// Configure wheels\nwheels.set_wheel_radius(0.4);\nwheels.set_wheel_inertia(5.0);\n\n// 4x4 vehicle\nwheels.add_wheel(Vec3{2.0, 1.0, -0.4}, true, true);   // FL: driven, steered\nwheels.add_wheel(Vec3{2.0, -1.0, -0.4}, true, true);  // FR: driven, steered\nwheels.add_wheel(Vec3{-2.0, 1.0, -0.4}, true, false); // RL: driven\nwheels.add_wheel(Vec3{-2.0, -1.0, -0.4}, true, false); // RR: driven\n\n// Control\nwheels.set_drive_torque(throttle * max_torque);\nwheels.set_brake_torque(brake * max_brake);\nwheels.set_steering_angle(steer * max_steer_rad);\n\n// Update\nauto soil = domain::land::SoilProperties::Asphalt();\nwheels.update(state, soil, dt);\n\n// Apply forces\nphysics::EntityForces forces;\nforces.add_force(wheels.get_total_force());\nforces.add_torque(wheels.get_total_torque());\n</code></pre>"},{"location":"api/land/#terrain-integration","title":"Terrain Integration","text":"<pre><code>// Get terrain properties at vehicle location\nauto env = engine.get_environment(vehicle_id);\n\n// Terrain data available\nReal elevation = env.terrain.elevation;\nVec3 normal = env.terrain.normal;\nReal slope = env.terrain.slope_angle;\n\n// Get soil type based on terrain material\nSoilProperties soil;\nswitch (env.terrain.material.type) {\n    case MaterialType::Sand:\n        soil = SoilProperties::DrySand();\n        break;\n    case MaterialType::Clay:\n        soil = SoilProperties::Clay();\n        break;\n    case MaterialType::Road:\n        soil = SoilProperties::Asphalt();\n        break;\n    default:\n        soil = SoilProperties::DrySand();\n}\n\nterra.set_soil(soil);\n</code></pre>"},{"location":"api/land/#see-also","title":"See Also","text":"<ul> <li>Physics API - Force generator interfaces</li> <li>Environment API - Terrain system</li> <li>Land Domain Concepts - Domain overview</li> <li>Land Domain Tutorial - Step-by-step guide</li> <li>Terrain Tutorial - Working with terrain</li> </ul>"},{"location":"api/lua/","title":"Lua API Reference","text":"<p>Lua scripting bindings for JaguarEngine using sol2.</p>"},{"location":"api/lua/#overview","title":"Overview","text":"<p>JaguarEngine provides Lua bindings for scripting simulations, creating scenarios, and automating entity behaviors. Lua scripts can control entities, query environment data, and implement custom logic.</p>"},{"location":"api/lua/#installation","title":"Installation","text":""},{"location":"api/lua/#build-from-source","title":"Build from Source","text":"<pre><code>cd JaguarEngine\n\n# Configure with Lua bindings enabled\ncmake -B build -DJAGUAR_BUILD_LUA=ON\n\n# Build\ncmake --build build --parallel\n\n# The module will be at build/jaguar.so (or jaguar.dll on Windows)\n</code></pre> <p>Requirements: - Lua 5.4+ (bundled if not found on system) - sol2 (auto-fetched by CMake)</p>"},{"location":"api/lua/#loading-the-module","title":"Loading the Module","text":"<pre><code>-- Add build directory to cpath\npackage.cpath = package.cpath .. \";./build/?.so;./build/?.dll\"\n\n-- Load the module\nlocal jag = require(\"jaguar\")\n\n-- All types are now in global scope: Vec3, Quat, Engine, etc.\n</code></pre>"},{"location":"api/lua/#basic-usage","title":"Basic Usage","text":"<pre><code>-- Load the module\nrequire(\"jaguar\")\n\n-- Create and initialize engine\nlocal engine = Engine()\nengine:initialize()\n\n-- Create an entity\nlocal aircraft = engine:create_entity(\"F-16\", Domain.Air)\n\n-- Set state\nlocal state = EntityState()\nstate.position = Vec3(0, 0, -5000)\nstate.velocity = Vec3(200, 0, 0)\nstate.mass = 12000\nengine:set_entity_state(aircraft, state)\n\n-- Run simulation\nfor i = 1, 10000 do\n    engine:step(0.01)\nend\n\nengine:shutdown()\n</code></pre>"},{"location":"api/lua/#core-types","title":"Core Types","text":""},{"location":"api/lua/#vec3","title":"Vec3","text":"<pre><code>-- Construction (both syntaxes work)\nlocal v = Vec3()              -- (0, 0, 0)\nlocal v = Vec3(1, 2, 3)       -- (1, 2, 3)\nlocal v = Vec3.new(1, 2, 3)   -- Alternative syntax\n\n-- Properties\nlocal x, y, z = v.x, v.y, v.z\n\n-- Methods\nlocal length = v:length()\nlocal length_sq = v:length_squared()\nlocal unit = v:normalized()\nlocal dot = v:dot(other)\nlocal cross = v:cross(other)\n\n-- Static factory methods\nlocal zero = Vec3.zero()\nlocal unit_x = Vec3.unit_x()\nlocal unit_y = Vec3.unit_y()\nlocal unit_z = Vec3.unit_z()\n\n-- Operators\nlocal v3 = v1 + v2\nlocal v3 = v1 - v2\nlocal v3 = v * 2.0\nlocal v3 = v / 2.0\nlocal neg = -v\n\n-- String conversion\nprint(v)  -- \"Vec3(1.000000, 2.000000, 3.000000)\"\n\n-- Table conversion\nlocal t = v:to_table()       -- {x=1, y=2, z=3}\nlocal v = Vec3.from_table(t) -- Back to Vec3\n</code></pre>"},{"location":"api/lua/#quat","title":"Quat","text":"<pre><code>-- Construction\nlocal q = Quat()                           -- Identity\nlocal q = Quat(w, x, y, z)\nlocal q = Quat.identity()                  -- Factory method\n\n-- From rotation\nlocal q = Quat.from_euler(roll, pitch, yaw)\nlocal q = Quat.from_axis_angle(axis, angle)\n\n-- Properties\nlocal w, x, y, z = q.w, q.x, q.y, q.z\n\n-- Methods\nlocal q_norm = q:normalized()\nlocal q_conj = q:conjugate()\nlocal q_inv = q:inverse()\nlocal v_rot = q:rotate(v)\nlocal roll, pitch, yaw = q:to_euler()\nlocal mat = q:to_rotation_matrix()\nlocal n = q:norm()\nlocal n_sq = q:norm_squared()\n\n-- Operators\nlocal q3 = q1 * q2   -- Rotation composition\nlocal v_rot = q * v  -- Rotate vector\n\n-- Table conversion\nlocal t = q:to_table()       -- {w=1, x=0, y=0, z=0}\nlocal q = Quat.from_table(t) -- Back to Quat\n</code></pre>"},{"location":"api/lua/#mat3x3","title":"Mat3x3","text":"<pre><code>-- Construction\nlocal m = Mat3x3()              -- Zero matrix\nlocal m = Mat3x3.identity()     -- Identity matrix\nlocal m = Mat3x3.zero()         -- Zero matrix\nlocal m = Mat3x3.diagonal(a, b, c)\nlocal m = Mat3x3.inertia(ixx, iyy, izz)\nlocal m = Mat3x3.inertia(ixx, iyy, izz, ixy, ixz, iyz)\n\n-- Element access (0-indexed)\nlocal value = m:get(row, col)\nm:set(row, col, value)\n\n-- Methods\nlocal mt = m:transpose()\nlocal det = m:determinant()\nlocal minv = m:inverse()\nlocal tr = m:trace()\n\n-- Operators\nlocal v_out = m * v_in     -- Matrix-vector multiply\nlocal m_out = m1 + m2      -- Matrix addition\nlocal m_scaled = m * 2.0   -- Scalar multiply\n</code></pre>"},{"location":"api/lua/#engine-api","title":"Engine API","text":"<pre><code>-- Initialization\nlocal engine = Engine()\nengine:initialize()\n-- or with config file\nengine:initialize(\"config/simulation.xml\")\n\n-- Entity management\nlocal id = engine:create_entity(\"name\", Domain.Air)\nlocal id = engine:create_entity(\"name\", \"air\")  -- String domain also works\nengine:destroy_entity(id)\nlocal exists = engine:entity_exists(id)\n\n-- State access\nlocal state = engine:get_entity_state(id)\nengine:set_entity_state(id, state)\n\n-- Simulation control\nengine:step(dt)           -- Single step\nengine:run()              -- Run until stopped\nengine:run_for(duration)  -- Run for duration seconds\nengine:pause()\nengine:resume()\nengine:stop()\n\n-- Time access\nlocal t = engine:get_time()\nlocal scale = engine:get_time_scale()\nengine:set_time_scale(2.0)     -- 2x speed\nengine:set_fixed_time_step(0.01)\n\n-- State query\nlocal state = engine:get_state()  -- SimulationState enum\nlocal init = engine:is_initialized()\n\n-- Property access\nlocal val = engine:get_property(\"time.scale\")\nlocal val = engine:get_property(entity_id, \"fuel.remaining\")\nengine:set_property(\"time.scale\", 2.0)\nengine:set_property(entity_id, \"throttle\", 0.8)\n\n-- Cleanup\nengine:shutdown()\n</code></pre>"},{"location":"api/lua/#enumerations","title":"Enumerations","text":"<pre><code>-- Domain enum\nDomain.Air\nDomain.Land\nDomain.Sea\nDomain.Space\nDomain.Generic\n\n-- CoordinateFrame enum\nCoordinateFrame.ECEF\nCoordinateFrame.ECI\nCoordinateFrame.NED\nCoordinateFrame.ENU\nCoordinateFrame.Body\n\n-- SimulationState enum\nSimulationState.Uninitialized\nSimulationState.Initialized\nSimulationState.Running\nSimulationState.Paused\nSimulationState.Stopped\nSimulationState.Error\n</code></pre>"},{"location":"api/lua/#entitystate","title":"EntityState","text":"<pre><code>local state = EntityState()\n\n-- Position and velocity\nstate.position = Vec3(x, y, z)           -- m (ECEF)\nstate.velocity = Vec3(vx, vy, vz)        -- m/s\nstate.acceleration = Vec3(ax, ay, az)    -- m/s\u00b2\n\n-- Orientation\nstate.orientation = Quat.from_euler(roll, pitch, yaw)\nstate.angular_velocity = Vec3(p, q, r)   -- rad/s\nstate.angular_accel = Vec3(pdot, qdot, rdot)  -- rad/s\u00b2\n\n-- Mass properties\nstate.mass = 12000                        -- kg\nstate.inertia = Mat3x3.inertia(ixx, iyy, izz)  -- kg\u00b7m\u00b2\n\n-- String representation\nprint(state)  -- \"EntityState(pos=(x, y, z), mass=12000)\"\n</code></pre>"},{"location":"api/lua/#entityforces","title":"EntityForces","text":"<pre><code>local forces = EntityForces()\n\n-- Access properties\nlocal f = forces.force    -- Vec3, N\nlocal t = forces.torque   -- Vec3, N\u00b7m\n\n-- Modification\nforces:clear()\nforces:add_force(Vec3(fx, fy, fz))\nforces:add_torque(Vec3(tx, ty, tz))\nforces:add_force_at_point(force, point, cg)  -- Applies force and computes torque\n\n-- String representation\nprint(forces)  -- \"EntityForces(force=(fx, fy, fz))\"\n</code></pre>"},{"location":"api/lua/#environment","title":"Environment","text":"<pre><code>local env = engine:get_environment(entity_id)\n\n-- Position\nlocal lat = env.latitude      -- rad\nlocal lon = env.longitude     -- rad\nlocal alt = env.altitude      -- m\n\n-- Atmosphere\nlocal temp = env.atmosphere.temperature     -- K\nlocal pressure = env.atmosphere.pressure    -- Pa\nlocal density = env.atmosphere.density      -- kg/m\u00b3\nlocal wind = env.atmosphere.wind            -- Vec3, m/s (NED)\n\n-- Terrain\nlocal elev = env.terrain.elevation          -- m\nlocal normal = env.terrain.normal           -- Vec3\nlocal slope = env.terrain.slope_angle       -- rad\n\n-- Ocean\nlocal wave_height = env.ocean.surface_elevation\nlocal over_water = env.over_water\n</code></pre>"},{"location":"api/lua/#domain-models","title":"Domain Models","text":""},{"location":"api/lua/#air-domain","title":"Air Domain","text":"<pre><code>local air = jaguar.domain.air\n\n-- Aerodynamics\nlocal aero = air.AerodynamicsModel()\naero:set_reference_area(28.0)\naero:set_reference_chord(3.5)\naero:set_reference_span(10.0)\naero:set_elevator(elevator_deg)\naero:compute_forces(state, env, dt, forces)\n\nlocal cl = aero:get_cl()\nlocal alpha = aero:get_alpha()\n\n-- Propulsion\nlocal prop = air.PropulsionModel()\nprop:set_max_thrust(75000)\nprop:set_fuel_capacity(3000)\nprop:set_throttle(0.8)\nprop:start()\nprop:compute_forces(state, env, dt, forces)\n</code></pre>"},{"location":"api/lua/#land-domain","title":"Land Domain","text":"<pre><code>local land = jaguar.domain.land\n\n-- Soil properties\nlocal soil = land.SoilProperties.DrySand()\n-- or customize\nlocal custom_soil = land.SoilProperties()\ncustom_soil.k_c = 5.0\ncustom_soil.k_phi = 1000.0\n\n-- Terramechanics\nlocal terra = land.TerramechanicsModel()\nterra:set_contact_area(0.63, 4.6)\nterra:set_vehicle_weight(62000 * jaguar.G0)\nterra:set_soil(soil)\nterra:compute_forces(state, env, dt, forces)\n\nlocal sinkage = terra:get_sinkage()\n</code></pre>"},{"location":"api/lua/#sea-domain","title":"Sea Domain","text":"<pre><code>local sea = jaguar.domain.sea\n\n-- Sea state\nlocal sea_state = sea.SeaState.FromNATOSeaState(4)\n\n-- Buoyancy\nlocal buoyancy = sea.BuoyancyModel()\nbuoyancy:set_displaced_volume(8390)\nbuoyancy:set_metacentric_height(2.5)\nbuoyancy:compute_forces(state, env, dt, forces)\n\nlocal draft = buoyancy:get_draft()\nlocal heel = buoyancy:get_heel()\n\n-- Hydrodynamics\nlocal hydro = sea.HydrodynamicsModel()\nhydro:set_hull_coefficients(-0.04, -0.01, -0.4, 0.05, -0.1, -0.05)\nhydro:set_rudder_angle(rudder_rad)\nhydro:set_propeller_rpm(120)\n</code></pre>"},{"location":"api/lua/#space-domain","title":"Space Domain","text":"<pre><code>local space = jaguar.domain.space\n\n-- Orbital elements\nlocal orbit = space.OrbitalElements()\norbit.semi_major_axis = jaguar.EARTH_RADIUS + 420000\norbit.eccentricity = 0.0001\norbit.inclination = 51.6 * jaguar.DEG_TO_RAD\n\nlocal pos, vel = orbit:to_cartesian()\nlocal period = orbit:period()\n\n-- TLE parsing\nlocal tle = space.TLE()\ntle:parse(line1, line2)\n\n-- SGP4 propagator\nlocal sgp4 = space.SGP4Propagator()\nsgp4:initialize(tle)\n\nfor minutes = 0, 24*60, 10 do\n    local pos_km, vel_kms = sgp4:propagate(minutes)\nend\n\n-- Gravity model\nlocal gravity = space.GravityModel()\ngravity:set_fidelity(space.GravityFidelity.J2)\n</code></pre>"},{"location":"api/lua/#coordinate-transforms","title":"Coordinate Transforms","text":"<pre><code>local transforms = jaguar.transforms\n\n-- Geodetic &lt;-&gt; ECEF\nlocal ecef = transforms.geodetic_to_ecef(lat_rad, lon_rad, alt_m)\nlocal lat, lon, alt = transforms.ecef_to_geodetic(ecef)\n\n-- ECEF &lt;-&gt; ECI\nlocal eci = transforms.ecef_to_eci(ecef, julian_date)\nlocal ecef = transforms.eci_to_ecef(eci, julian_date)\n\n-- Julian date\nlocal jd = transforms.julian_date(2024, 1, 1, 12, 0, 0.0)\n</code></pre>"},{"location":"api/lua/#constants","title":"Constants","text":"<pre><code>-- Mathematical\njaguar.PI\njaguar.TWO_PI\njaguar.DEG_TO_RAD\njaguar.RAD_TO_DEG\n\n-- Physical\njaguar.G0              -- Standard gravity (9.80665 m/s\u00b2)\njaguar.EARTH_RADIUS    -- WGS84 equatorial radius\njaguar.EARTH_MU        -- Earth gravitational parameter\n\n-- Enumerations\njaguar.Domain.Air\njaguar.Domain.Land\njaguar.Domain.Sea\njaguar.Domain.Space\n</code></pre>"},{"location":"api/lua/#callbacks-and-hooks","title":"Callbacks and Hooks","text":"<pre><code>-- Register update callback\nfunction on_step(dt, time)\n    -- Called each simulation step\n    local state = engine:get_entity_state(my_aircraft)\n    -- Update controls based on state\nend\n\njaguar.register_callback(\"step\", on_step)\n\n-- Register entity event\nfunction on_entity_created(entity_id, name, domain)\n    print(\"Created: \" .. name)\nend\n\njaguar.register_callback(\"entity_created\", on_entity_created)\n</code></pre>"},{"location":"api/lua/#example-simple-scenario","title":"Example: Simple Scenario","text":"<pre><code>-- Initialize\nlocal engine = jaguar.engine\nengine:initialize()\n\n-- Create blue force\nlocal blue = {}\nfor i = 1, 4 do\n    local id = engine:create_entity(\"Blue-\" .. i, jaguar.Domain.Air)\n    local state = jaguar.EntityState()\n    state.position = jaguar.Vec3(0, (i-1) * 500, -8000)\n    state.velocity = jaguar.Vec3(250, 0, 0)\n    state.mass = 12000\n    engine:set_entity_state(id, state)\n    table.insert(blue, id)\nend\n\n-- Create red force\nlocal red = {}\nfor i = 1, 4 do\n    local id = engine:create_entity(\"Red-\" .. i, jaguar.Domain.Air)\n    local state = jaguar.EntityState()\n    state.position = jaguar.Vec3(50000, (i-1) * 500, -8000)\n    state.velocity = jaguar.Vec3(-250, 0, 0)\n    state.mass = 12000\n    engine:set_entity_state(id, state)\n    table.insert(red, id)\nend\n\n-- Simulation loop\nlocal dt = 0.01\nlocal duration = 120.0  -- 2 minutes\nlocal time = 0\n\nwhile time &lt; duration do\n    -- Update all entities\n    for _, id in ipairs(blue) do\n        update_aircraft(id, dt)\n    end\n    for _, id in ipairs(red) do\n        update_aircraft(id, dt)\n    end\n\n    engine:step(dt)\n    time = time + dt\n\n    -- Log every second\n    if math.floor(time) ~= math.floor(time - dt) then\n        print(string.format(\"Time: %.1f s\", time))\n    end\nend\n\nengine:shutdown()\n</code></pre>"},{"location":"api/lua/#see-also","title":"See Also","text":"<ul> <li>API Overview - Complete API index</li> <li>Python API - Python bindings</li> <li>Configuration - Configuration reference</li> </ul>"},{"location":"api/ml/","title":"Machine Learning API Reference","text":"<p>Machine Learning module (<code>jaguar_ml</code>) provides neural network-based autopilot systems, model repository management, and reinforcement learning environments with Gym-compatible APIs.</p>"},{"location":"api/ml/#overview","title":"Overview","text":"<p>The ML module enables: - Neural Autopilot: NN-based flight control with safety constraints - Model Repository: Versioned model storage with caching - RL Environment: Gym-compatible training environments</p>"},{"location":"api/ml/#neural-autopilot","title":"Neural Autopilot","text":""},{"location":"api/ml/#header","title":"Header","text":"<pre><code>#include &lt;jaguar/ml/neural_autopilot.h&gt;\n</code></pre>"},{"location":"api/ml/#core-types","title":"Core Types","text":"<pre><code>namespace jaguar::ml {\n\n// Autopilot operating modes\nenum class AutopilotMode {\n    Manual,             // No automation\n    Waypoint,           // Follow waypoint route\n    Altitude,           // Maintain altitude\n    Speed,              // Maintain airspeed\n    Course,             // Maintain heading\n    AltitudeSpeed,      // Combined altitude + speed hold\n    FullAuto,           // Complete autonomous control\n    Landing,            // Automated landing\n    Takeoff,            // Automated takeoff\n    Formation,          // Formation flight\n    Terrain,            // Terrain following\n    Emergency           // Emergency procedures\n};\n\n// Vehicle types for autopilot specialization\nenum class VehicleType {\n    FixedWing,          // Conventional aircraft\n    Rotorcraft,         // Helicopters, multirotors\n    VTOL,               // Vertical takeoff/landing\n    Ship,               // Surface vessels\n    Submarine,          // Underwater vehicles\n    GroundVehicle,      // Wheeled/tracked vehicles\n    Spacecraft          // Orbital vehicles\n};\n\n// Autopilot observation (inputs to neural network)\nstruct AutopilotObservation {\n    Vec3 position;              // ECEF or NED\n    Vec3 velocity;              // Body or world frame\n    Quaternion orientation;\n    Vec3 angular_velocity;\n    double altitude;\n    double airspeed;\n    double vertical_speed;\n    double heading;\n    double pitch;\n    double roll;\n    Vec3 target_position;\n    double target_altitude;\n    double target_speed;\n    double target_heading;\n    std::vector&lt;Vec3&gt; waypoints;\n    double distance_to_target;\n    double time_to_target;\n    // Environment\n    Vec3 wind_velocity;\n    double air_density;\n    double temperature;\n};\n\n// Autopilot action (outputs from neural network)\nstruct AutopilotAction {\n    double throttle;            // 0.0 - 1.0\n    double elevator;            // -1.0 to 1.0\n    double aileron;             // -1.0 to 1.0\n    double rudder;              // -1.0 to 1.0\n    double flaps;               // 0.0 - 1.0\n    double speed_brake;         // 0.0 - 1.0\n    double collective;          // For rotorcraft: 0.0 - 1.0\n    double cyclic_pitch;        // For rotorcraft: -1.0 to 1.0\n    double cyclic_roll;         // For rotorcraft: -1.0 to 1.0\n    double tail_rotor;          // For rotorcraft: -1.0 to 1.0\n};\n\n// Safety constraints\nstruct SafetyConstraints {\n    double max_bank_angle = 60.0;       // degrees\n    double max_pitch_angle = 30.0;      // degrees\n    double max_g_load = 4.0;            // g\n    double min_altitude = 100.0;        // meters AGL\n    double max_altitude = 15000.0;      // meters\n    double min_airspeed = 50.0;         // m/s\n    double max_airspeed = 300.0;        // m/s\n    double max_vertical_speed = 50.0;   // m/s\n    double max_roll_rate = 60.0;        // deg/s\n    double max_pitch_rate = 30.0;       // deg/s\n    double max_yaw_rate = 30.0;         // deg/s\n    bool enable_stall_protection = true;\n    bool enable_overspeed_protection = true;\n    bool enable_terrain_avoidance = true;\n};\n\n// Autopilot result\nstruct AutopilotResult {\n    bool success;\n    std::string error_message;\n    AutopilotAction action;\n    bool safety_intervention;\n    std::string intervention_reason;\n    double confidence;\n    std::chrono::microseconds inference_time;\n};\n\n// Configuration\nstruct AutopilotConfig {\n    VehicleType vehicle_type = VehicleType::FixedWing;\n    AutopilotMode default_mode = AutopilotMode::Manual;\n    std::string model_path;\n    SafetyConstraints safety;\n    double control_frequency = 50.0;    // Hz\n    bool normalize_inputs = true;\n    bool denormalize_outputs = true;\n    bool enable_safety_monitor = true;\n};\n\n}  // namespace jaguar::ml\n</code></pre>"},{"location":"api/ml/#neuralautopilot-class","title":"NeuralAutopilot Class","text":"<pre><code>class NeuralAutopilot {\npublic:\n    // Initialize with configuration\n    AutopilotResult initialize(const AutopilotConfig&amp; config);\n\n    // Load neural network model\n    AutopilotResult load_model(const std::string&amp; model_path);\n\n    // Shutdown\n    void shutdown();\n\n    // Set operating mode\n    void set_mode(AutopilotMode mode);\n    AutopilotMode get_mode() const;\n\n    // Set target (depends on mode)\n    void set_target_waypoint(const Vec3&amp; waypoint);\n    void set_target_altitude(double altitude_meters);\n    void set_target_speed(double speed_mps);\n    void set_target_heading(double heading_rad);\n    void set_waypoint_route(const std::vector&lt;Vec3&gt;&amp; waypoints);\n\n    // Compute control action\n    AutopilotResult compute_action(const AutopilotObservation&amp; observation);\n\n    // Compute with safety constraints\n    AutopilotResult compute_safe_action(const AutopilotObservation&amp; observation);\n\n    // Update safety constraints\n    void set_safety_constraints(const SafetyConstraints&amp; constraints);\n    SafetyConstraints get_safety_constraints() const;\n\n    // Manual override\n    void engage_manual_override();\n    void disengage_manual_override();\n    bool is_manual_override() const;\n\n    // Get last action\n    AutopilotAction get_last_action() const;\n\n    // Get neural network info\n    struct ModelInfo {\n        std::string model_name;\n        std::string model_version;\n        size_t input_size;\n        size_t output_size;\n        size_t hidden_layers;\n        size_t total_parameters;\n        std::string activation_function;\n    };\n    ModelInfo get_model_info() const;\n\n    // Statistics\n    struct AutopilotStats {\n        size_t total_inferences;\n        size_t safety_interventions;\n        std::chrono::microseconds avg_inference_time;\n        std::chrono::microseconds max_inference_time;\n        double avg_confidence;\n    };\n    AutopilotStats get_statistics() const;\n};\n\n// Factory functions\nstd::unique_ptr&lt;NeuralAutopilot&gt; create_neural_autopilot(\n    const AutopilotConfig&amp; config);\nstd::unique_ptr&lt;NeuralAutopilot&gt; create_aircraft_autopilot(\n    const std::string&amp; model_path);\nstd::unique_ptr&lt;NeuralAutopilot&gt; create_rotorcraft_autopilot(\n    const std::string&amp; model_path);\nstd::unique_ptr&lt;NeuralAutopilot&gt; create_ship_autopilot(\n    const std::string&amp; model_path);\n</code></pre>"},{"location":"api/ml/#model-repository","title":"Model Repository","text":""},{"location":"api/ml/#header_1","title":"Header","text":"<pre><code>#include &lt;jaguar/ml/model_repository.h&gt;\n</code></pre>"},{"location":"api/ml/#core-types_1","title":"Core Types","text":"<pre><code>namespace jaguar::ml {\n\n// Model types\nenum class ModelType {\n    Autopilot,          // Flight control models\n    Behavior,           // AI behavior models\n    Perception,         // Sensor processing models\n    Prediction,         // State prediction models\n    Classification,     // Object classification\n    Regression,         // General regression\n    Reinforcement,      // RL policy models\n    Anomaly,            // Anomaly detection\n    Custom              // User-defined\n};\n\n// Model status\nenum class ModelStatus {\n    Draft,              // Under development\n    Testing,            // In testing\n    Staging,            // Staged for deployment\n    Production,         // Active production\n    Deprecated,         // No longer recommended\n    Archived            // Archived, not for use\n};\n\n// Semantic version\nstruct SemanticVersion {\n    uint32_t major;\n    uint32_t minor;\n    uint32_t patch;\n    std::string prerelease;     // e.g., \"alpha\", \"beta.1\"\n    std::string build_metadata;\n\n    bool operator&lt;(const SemanticVersion&amp; other) const;\n    bool operator==(const SemanticVersion&amp; other) const;\n    std::string to_string() const;\n    static SemanticVersion parse(const std::string&amp; version_str);\n};\n\n// Tensor info for model I/O\nstruct TensorInfo {\n    std::string name;\n    std::vector&lt;int64_t&gt; shape;\n    std::string dtype;          // \"float32\", \"float64\", \"int32\", etc.\n    bool is_optional = false;\n};\n\n// Model metadata\nstruct ModelMetadata {\n    std::string model_id;\n    std::string name;\n    std::string description;\n    ModelType type;\n    SemanticVersion version;\n    ModelStatus status;\n    std::string author;\n    std::chrono::system_clock::time_point created_at;\n    std::chrono::system_clock::time_point updated_at;\n    std::vector&lt;TensorInfo&gt; inputs;\n    std::vector&lt;TensorInfo&gt; outputs;\n    std::map&lt;std::string, std::string&gt; tags;\n    std::map&lt;std::string, double&gt; metrics;  // accuracy, loss, etc.\n    size_t file_size;\n    std::string checksum;\n    std::string framework;      // \"onnx\", \"tensorflow\", \"pytorch\"\n    std::vector&lt;std::string&gt; dependencies;\n};\n\n// Model entry in repository\nstruct ModelEntry {\n    ModelMetadata metadata;\n    std::string storage_path;\n    bool is_cached;\n    std::chrono::system_clock::time_point last_accessed;\n    size_t access_count;\n};\n\n// Model query\nstruct ModelQuery {\n    std::optional&lt;std::string&gt; name_pattern;\n    std::optional&lt;ModelType&gt; type;\n    std::optional&lt;ModelStatus&gt; status;\n    std::optional&lt;SemanticVersion&gt; min_version;\n    std::optional&lt;SemanticVersion&gt; max_version;\n    std::map&lt;std::string, std::string&gt; required_tags;\n    size_t limit = 100;\n    size_t offset = 0;\n    bool latest_only = false;\n};\n\n// Cache configuration\nstruct CacheConfig {\n    bool enabled = true;\n    size_t max_cache_size = 1024 * 1024 * 1024;  // 1 GB\n    size_t max_cached_models = 50;\n    std::chrono::hours cache_ttl{24};\n    bool preload_production = true;\n};\n\n// Model result\nstruct ModelResult {\n    bool success;\n    std::string error_message;\n    std::string model_id;\n    SemanticVersion version;\n};\n\n// Repository configuration\nstruct RepositoryConfig {\n    std::string storage_path = \"./models\";\n    std::string remote_url;\n    CacheConfig cache;\n    bool auto_sync = false;\n    std::chrono::minutes sync_interval{60};\n};\n\n}  // namespace jaguar::ml\n</code></pre>"},{"location":"api/ml/#modelrepository-class","title":"ModelRepository Class","text":"<pre><code>class ModelRepository {\npublic:\n    // Initialize repository\n    ModelResult initialize(const RepositoryConfig&amp; config);\n\n    // Shutdown\n    void shutdown();\n\n    // Register a new model\n    ModelResult register_model(const ModelMetadata&amp; metadata,\n                              const std::vector&lt;uint8_t&gt;&amp; model_data);\n\n    // Register from file\n    ModelResult register_model_from_file(const ModelMetadata&amp; metadata,\n                                         const std::string&amp; file_path);\n\n    // Get model by ID\n    std::optional&lt;ModelEntry&gt; get_model(const std::string&amp; model_id) const;\n\n    // Get model by name and version\n    std::optional&lt;ModelEntry&gt; get_model(const std::string&amp; name,\n                                        const SemanticVersion&amp; version) const;\n\n    // Get latest version of model\n    std::optional&lt;ModelEntry&gt; get_latest_model(const std::string&amp; name) const;\n\n    // Get latest production version\n    std::optional&lt;ModelEntry&gt; get_production_model(const std::string&amp; name) const;\n\n    // Query models\n    std::vector&lt;ModelEntry&gt; query_models(const ModelQuery&amp; query) const;\n\n    // List all versions of a model\n    std::vector&lt;ModelEntry&gt; list_versions(const std::string&amp; name) const;\n\n    // Load model data\n    std::vector&lt;uint8_t&gt; load_model_data(const std::string&amp; model_id);\n\n    // Load model to path\n    ModelResult load_model_to_path(const std::string&amp; model_id,\n                                   const std::string&amp; destination);\n\n    // Update model metadata\n    ModelResult update_metadata(const std::string&amp; model_id,\n                               const ModelMetadata&amp; metadata);\n\n    // Update model status\n    ModelResult set_status(const std::string&amp; model_id, ModelStatus status);\n\n    // Promote model (draft -&gt; testing -&gt; staging -&gt; production)\n    ModelResult promote_model(const std::string&amp; model_id);\n\n    // Deprecate model\n    ModelResult deprecate_model(const std::string&amp; model_id);\n\n    // Delete model\n    ModelResult delete_model(const std::string&amp; model_id);\n\n    // Cache management\n    void preload_to_cache(const std::string&amp; model_id);\n    void evict_from_cache(const std::string&amp; model_id);\n    void clear_cache();\n\n    // Sync with remote repository\n    ModelResult sync_with_remote();\n\n    // Statistics\n    struct RepositoryStats {\n        size_t total_models;\n        size_t production_models;\n        size_t cached_models;\n        size_t total_storage_bytes;\n        size_t cache_size_bytes;\n        double cache_hit_rate;\n    };\n    RepositoryStats get_statistics() const;\n};\n\n// Factory functions\nstd::unique_ptr&lt;ModelRepository&gt; create_model_repository(\n    const RepositoryConfig&amp; config);\nstd::unique_ptr&lt;IModelRepository&gt; create_memory_repository();\nstd::unique_ptr&lt;IModelRepository&gt; create_file_repository(\n    const std::string&amp; path);\n</code></pre>"},{"location":"api/ml/#rl-environment","title":"RL Environment","text":""},{"location":"api/ml/#header_2","title":"Header","text":"<pre><code>#include &lt;jaguar/ml/rl_environment.h&gt;\n</code></pre>"},{"location":"api/ml/#core-types_2","title":"Core Types","text":"<pre><code>namespace jaguar::ml {\n\n// Space types (Gym-compatible)\nenum class SpaceType {\n    Discrete,           // Single integer action\n    Box,                // Continuous bounded space\n    MultiDiscrete,      // Multiple discrete actions\n    MultiBinary,        // Multiple binary actions\n    Dict,               // Dictionary of spaces\n    Tuple               // Tuple of spaces\n};\n\n// Space definition\nstruct Space {\n    SpaceType type;\n    std::vector&lt;int64_t&gt; shape;\n    std::vector&lt;double&gt; low;    // Lower bounds (for Box)\n    std::vector&lt;double&gt; high;   // Upper bounds (for Box)\n    int64_t n = 0;              // Number of options (for Discrete)\n    std::vector&lt;int64_t&gt; nvec;  // Sizes per dimension (for MultiDiscrete)\n\n    // Factory methods\n    static Space discrete(int64_t n);\n    static Space box(const std::vector&lt;int64_t&gt;&amp; shape,\n                    double low, double high);\n    static Space box(const std::vector&lt;int64_t&gt;&amp; shape,\n                    const std::vector&lt;double&gt;&amp; low,\n                    const std::vector&lt;double&gt;&amp; high);\n    static Space multi_discrete(const std::vector&lt;int64_t&gt;&amp; nvec);\n    static Space multi_binary(int64_t n);\n};\n\n// Observation\nstruct Observation {\n    std::vector&lt;double&gt; data;\n    std::map&lt;std::string, std::vector&lt;double&gt;&gt; dict_data;  // For Dict spaces\n\n    double operator[](size_t i) const { return data[i]; }\n    double&amp; operator[](size_t i) { return data[i]; }\n    size_t size() const { return data.size(); }\n};\n\n// Action\nstruct Action {\n    std::vector&lt;double&gt; continuous;     // For Box spaces\n    int64_t discrete = 0;               // For Discrete spaces\n    std::vector&lt;int64_t&gt; multi;         // For MultiDiscrete/MultiBinary\n\n    static Action from_discrete(int64_t action);\n    static Action from_continuous(const std::vector&lt;double&gt;&amp; action);\n};\n\n// Step result\nstruct StepResult {\n    Observation observation;\n    double reward;\n    bool terminated;            // Episode ended (goal reached, failure)\n    bool truncated;             // Episode truncated (time limit, etc.)\n    std::map&lt;std::string, double&gt; info;\n};\n\n// Episode information\nstruct EpisodeInfo {\n    uint64_t episode_id;\n    size_t total_steps;\n    double total_reward;\n    std::chrono::milliseconds duration;\n    bool successful;\n    std::string termination_reason;\n};\n\n// Reward configuration\nstruct RewardConfig {\n    double goal_reward = 100.0;\n    double step_penalty = -0.1;\n    double collision_penalty = -50.0;\n    double out_of_bounds_penalty = -25.0;\n    double fuel_penalty_per_kg = -0.01;\n    double time_penalty_per_second = -0.1;\n    bool shaped_rewards = true;         // Include intermediate rewards\n    double discount_factor = 0.99;\n};\n\n// Environment configuration\nstruct EnvironmentConfig {\n    std::string env_name;\n    Space observation_space;\n    Space action_space;\n    RewardConfig rewards;\n    size_t max_episode_steps = 1000;\n    double dt = 0.02;                   // Simulation timestep\n    uint32_t seed = 0;\n    bool render_enabled = false;\n    std::string render_mode = \"human\";  // \"human\", \"rgb_array\"\n};\n\n// RL result\nstruct RLResult {\n    bool success;\n    std::string error_message;\n    size_t steps;\n    double total_reward;\n};\n\n// Environment statistics\nstruct RLEnvironmentStats {\n    size_t total_episodes;\n    size_t total_steps;\n    double avg_episode_reward;\n    double avg_episode_length;\n    double success_rate;\n    std::chrono::microseconds avg_step_time;\n};\n\n}  // namespace jaguar::ml\n</code></pre>"},{"location":"api/ml/#rlenvironment-class","title":"RLEnvironment Class","text":"<pre><code>class RLEnvironment {\npublic:\n    // Initialize environment\n    RLResult initialize(const EnvironmentConfig&amp; config);\n\n    // Shutdown\n    void shutdown();\n\n    // Gym-compatible interface\n    Observation reset(uint32_t seed = 0);\n    StepResult step(const Action&amp; action);\n    void render();\n    void close();\n\n    // Get spaces\n    Space get_observation_space() const;\n    Space get_action_space() const;\n\n    // Sample random action\n    Action sample_action() const;\n\n    // Check if action is valid\n    bool is_valid_action(const Action&amp; action) const;\n\n    // Episode control\n    bool is_episode_done() const;\n    EpisodeInfo get_episode_info() const;\n\n    // Set scenario\n    void set_initial_state(const Observation&amp; state);\n    void set_goal(const Vec3&amp; goal_position);\n    void set_obstacles(const std::vector&lt;AABB&gt;&amp; obstacles);\n\n    // Configuration\n    void set_reward_config(const RewardConfig&amp; config);\n    void set_max_episode_steps(size_t steps);\n\n    // Get underlying simulation engine\n    interface::Engine&amp; get_engine();\n\n    // Statistics\n    RLEnvironmentStats get_statistics() const;\n\n    // Vectorized environment support\n    std::vector&lt;Observation&gt; reset_batch(size_t num_envs, uint32_t seed = 0);\n    std::vector&lt;StepResult&gt; step_batch(const std::vector&lt;Action&gt;&amp; actions);\n};\n\n// Interface for custom environments\nclass IRLEnvironment {\npublic:\n    virtual ~IRLEnvironment() = default;\n\n    virtual Observation reset(uint32_t seed) = 0;\n    virtual StepResult step(const Action&amp; action) = 0;\n    virtual Space get_observation_space() const = 0;\n    virtual Space get_action_space() const = 0;\n    virtual void render() = 0;\n    virtual void close() = 0;\n};\n\n// Reward function interface\nclass IRewardFunction {\npublic:\n    virtual ~IRewardFunction() = default;\n\n    virtual double compute_reward(\n        const Observation&amp; observation,\n        const Action&amp; action,\n        const Observation&amp; next_observation,\n        bool terminated,\n        const std::map&lt;std::string, double&gt;&amp; info) = 0;\n};\n\n// Termination condition interface\nclass ITerminationCondition {\npublic:\n    virtual ~ITerminationCondition() = default;\n\n    virtual bool check_terminated(\n        const Observation&amp; observation,\n        size_t step,\n        const std::map&lt;std::string, double&gt;&amp; info) = 0;\n\n    virtual bool check_truncated(\n        const Observation&amp; observation,\n        size_t step,\n        const std::map&lt;std::string, double&gt;&amp; info) = 0;\n};\n\n// Factory functions\nstd::unique_ptr&lt;RLEnvironment&gt; create_rl_environment(\n    const EnvironmentConfig&amp; config);\nstd::unique_ptr&lt;RLEnvironment&gt; create_waypoint_environment(\n    const Vec3&amp; start, const Vec3&amp; goal);\nstd::unique_ptr&lt;RLEnvironment&gt; create_landing_environment();\nstd::unique_ptr&lt;RLEnvironment&gt; create_formation_environment(\n    size_t num_aircraft);\n\n// Reward function factories\nstd::unique_ptr&lt;IRewardFunction&gt; create_distance_reward(\n    const Vec3&amp; goal, double scale);\nstd::unique_ptr&lt;IRewardFunction&gt; create_sparse_reward(\n    double goal_reward, double step_penalty);\nstd::unique_ptr&lt;IRewardFunction&gt; create_composite_reward(\n    std::vector&lt;std::unique_ptr&lt;IRewardFunction&gt;&gt; rewards,\n    std::vector&lt;double&gt; weights);\n</code></pre>"},{"location":"api/ml/#usage-examples","title":"Usage Examples","text":""},{"location":"api/ml/#neural-autopilot_1","title":"Neural Autopilot","text":"<pre><code>#include &lt;jaguar/ml/neural_autopilot.h&gt;\n\nusing namespace jaguar::ml;\n\n// Configure autopilot\nAutopilotConfig config;\nconfig.vehicle_type = VehicleType::FixedWing;\nconfig.model_path = \"models/autopilot_v1.2.0.onnx\";\nconfig.default_mode = AutopilotMode::Waypoint;\nconfig.control_frequency = 50.0;\n\n// Safety constraints\nconfig.safety.max_bank_angle = 45.0;\nconfig.safety.max_g_load = 3.0;\nconfig.safety.min_altitude = 500.0;\nconfig.safety.enable_terrain_avoidance = true;\n\nauto autopilot = create_neural_autopilot(config);\nautopilot-&gt;initialize(config);\n\n// Set waypoint route\nstd::vector&lt;Vec3&gt; waypoints = {\n    {1000, 0, -5000},\n    {5000, 2000, -6000},\n    {8000, 1000, -5500}\n};\nautopilot-&gt;set_waypoint_route(waypoints);\nautopilot-&gt;set_mode(AutopilotMode::Waypoint);\n\n// Simulation loop\nwhile (running) {\n    // Get current aircraft state\n    auto state = engine.get_entity_state(aircraft);\n    auto env = engine.get_environment(aircraft);\n\n    // Build observation\n    AutopilotObservation obs;\n    obs.position = state.position;\n    obs.velocity = state.velocity;\n    obs.orientation = state.orientation;\n    obs.altitude = -state.position.z;\n    obs.airspeed = magnitude(state.velocity);\n    obs.waypoints = waypoints;\n    obs.wind_velocity = env.wind;\n\n    // Compute safe action\n    auto result = autopilot-&gt;compute_safe_action(obs);\n\n    if (result.success) {\n        // Apply control action\n        apply_controls(aircraft, result.action);\n\n        if (result.safety_intervention) {\n            std::cout &lt;&lt; \"Safety intervention: \"\n                      &lt;&lt; result.intervention_reason &lt;&lt; \"\\n\";\n        }\n    }\n\n    engine.step(dt);\n}\n</code></pre>"},{"location":"api/ml/#model-repository-management","title":"Model Repository Management","text":"<pre><code>#include &lt;jaguar/ml/model_repository.h&gt;\n\nusing namespace jaguar::ml;\n\n// Configure repository\nRepositoryConfig config;\nconfig.storage_path = \"./model_registry\";\nconfig.cache.max_cache_size = 2ULL * 1024 * 1024 * 1024;  // 2 GB\nconfig.cache.preload_production = true;\n\nauto repo = create_model_repository(config);\nrepo-&gt;initialize(config);\n\n// Register a new model\nModelMetadata metadata;\nmetadata.name = \"aircraft_autopilot\";\nmetadata.description = \"Neural autopilot for fixed-wing aircraft\";\nmetadata.type = ModelType::Autopilot;\nmetadata.version = SemanticVersion{1, 2, 0};\nmetadata.status = ModelStatus::Testing;\nmetadata.author = \"ML Team\";\nmetadata.framework = \"onnx\";\n\nmetadata.inputs.push_back({\"observation\", {1, 24}, \"float32\"});\nmetadata.outputs.push_back({\"action\", {1, 6}, \"float32\"});\n\nmetadata.metrics[\"accuracy\"] = 0.95;\nmetadata.metrics[\"avg_reward\"] = 850.0;\n\nmetadata.tags[\"vehicle\"] = \"fixed_wing\";\nmetadata.tags[\"domain\"] = \"air\";\n\nauto model_data = load_file(\"trained_model.onnx\");\nrepo-&gt;register_model(metadata, model_data);\n\n// Query models\nModelQuery query;\nquery.type = ModelType::Autopilot;\nquery.status = ModelStatus::Production;\nquery.required_tags[\"vehicle\"] = \"fixed_wing\";\n\nauto models = repo-&gt;query_models(query);\nfor (const auto&amp; model : models) {\n    std::cout &lt;&lt; model.metadata.name &lt;&lt; \" v\"\n              &lt;&lt; model.metadata.version.to_string() &lt;&lt; \"\\n\";\n}\n\n// Load and use model\nauto entry = repo-&gt;get_production_model(\"aircraft_autopilot\");\nif (entry) {\n    auto data = repo-&gt;load_model_data(entry-&gt;metadata.model_id);\n    autopilot-&gt;load_model_from_memory(data);\n}\n\n// Promote model through lifecycle\nrepo-&gt;set_status(model_id, ModelStatus::Staging);\n// After validation...\nrepo-&gt;promote_model(model_id);  // Now in Production\n</code></pre>"},{"location":"api/ml/#rl-training-environment","title":"RL Training Environment","text":"<pre><code>#include &lt;jaguar/ml/rl_environment.h&gt;\n\nusing namespace jaguar::ml;\n\n// Configure environment\nEnvironmentConfig config;\nconfig.env_name = \"WaypointNavigation-v1\";\nconfig.observation_space = Space::box({24}, -1.0, 1.0);\nconfig.action_space = Space::box({6}, -1.0, 1.0);\nconfig.max_episode_steps = 1000;\nconfig.dt = 0.02;\n\nconfig.rewards.goal_reward = 100.0;\nconfig.rewards.step_penalty = -0.01;\nconfig.rewards.collision_penalty = -50.0;\nconfig.rewards.shaped_rewards = true;\n\nauto env = create_rl_environment(config);\nenv-&gt;initialize(config);\n\n// Set scenario\nenv-&gt;set_goal({10000, 0, -5000});  // 10 km away, 5 km altitude\n\n// Training loop (pseudocode - typically done with Python/Ray)\nfor (int episode = 0; episode &lt; 10000; ++episode) {\n    auto obs = env-&gt;reset(episode);  // Seed with episode number\n    double total_reward = 0.0;\n\n    while (!env-&gt;is_episode_done()) {\n        // Get action from policy (would typically be a neural network)\n        Action action = policy.get_action(obs);\n\n        // Step environment\n        auto result = env-&gt;step(action);\n\n        // Store transition for training\n        replay_buffer.add(obs, action, result.reward,\n                         result.observation, result.terminated);\n\n        obs = result.observation;\n        total_reward += result.reward;\n    }\n\n    auto info = env-&gt;get_episode_info();\n    std::cout &lt;&lt; \"Episode \" &lt;&lt; episode\n              &lt;&lt; \" reward: \" &lt;&lt; total_reward\n              &lt;&lt; \" steps: \" &lt;&lt; info.total_steps\n              &lt;&lt; \" success: \" &lt;&lt; (info.successful ? \"yes\" : \"no\") &lt;&lt; \"\\n\";\n}\n\n// Get statistics\nauto stats = env-&gt;get_statistics();\nstd::cout &lt;&lt; \"Success rate: \" &lt;&lt; stats.success_rate * 100 &lt;&lt; \"%\\n\";\nstd::cout &lt;&lt; \"Avg reward: \" &lt;&lt; stats.avg_episode_reward &lt;&lt; \"\\n\";\n</code></pre>"},{"location":"api/ml/#custom-reward-function","title":"Custom Reward Function","text":"<pre><code>#include &lt;jaguar/ml/rl_environment.h&gt;\n\nusing namespace jaguar::ml;\n\n// Custom reward function for formation flight\nclass FormationReward : public IRewardFunction {\n    std::vector&lt;Vec3&gt; formation_offsets_;\n    double formation_scale_ = 1.0;\n\npublic:\n    FormationReward(const std::vector&lt;Vec3&gt;&amp; offsets, double scale)\n        : formation_offsets_(offsets), formation_scale_(scale) {}\n\n    double compute_reward(\n            const Observation&amp; obs,\n            const Action&amp; action,\n            const Observation&amp; next_obs,\n            bool terminated,\n            const std::map&lt;std::string, double&gt;&amp; info) override {\n\n        double reward = 0.0;\n\n        // Formation keeping reward\n        double formation_error = info.at(\"formation_error\");\n        reward -= formation_error * formation_scale_;\n\n        // Smooth control reward\n        double control_effort = 0.0;\n        for (double a : action.continuous) {\n            control_effort += a * a;\n        }\n        reward -= 0.01 * control_effort;\n\n        // Collision avoidance\n        if (info.count(\"min_separation\") &amp;&amp; info.at(\"min_separation\") &lt; 50.0) {\n            reward -= 10.0;\n        }\n\n        // Goal bonus\n        if (terminated &amp;&amp; info.count(\"goal_reached\") &amp;&amp; info.at(\"goal_reached\") &gt; 0) {\n            reward += 100.0;\n        }\n\n        return reward;\n    }\n};\n\n// Use custom reward\nauto custom_reward = std::make_unique&lt;FormationReward&gt;(offsets, 0.5);\nenv-&gt;set_reward_function(std::move(custom_reward));\n</code></pre>"},{"location":"api/ml/#see-also","title":"See Also","text":"<ul> <li>Architecture - System architecture overview</li> <li>Digital Thread API - Lifecycle tracking</li> <li>GPU Compute API - GPU acceleration for inference</li> <li>Configuration - Engine configuration</li> </ul>"},{"location":"api/overview/","title":"API Reference Overview","text":"<p>Complete API documentation for JaguarEngine.</p>"},{"location":"api/overview/#module-structure","title":"Module Structure","text":"<p>JaguarEngine is organized into logical modules:</p> <pre><code>jaguar/\n\u251c\u2500\u2500 core/           # Core types, math, utilities\n\u251c\u2500\u2500 physics/        # Entity management, forces, integration\n\u251c\u2500\u2500 domain/         # Domain-specific physics (air, land, sea, space)\n\u251c\u2500\u2500 environment/    # Terrain, atmosphere, ocean\n\u251c\u2500\u2500 interface/      # Public API facade, configuration\n\u251c\u2500\u2500 cloud/          # Distributed simulation, state sync, partitioning\n\u251c\u2500\u2500 thread/         # Digital thread, history, degradation models\n\u251c\u2500\u2500 ml/             # Machine learning, neural autopilot, RL\n\u251c\u2500\u2500 federation/     # DIS/HLA network protocols\n\u251c\u2500\u2500 gpu/            # GPU compute backends (CUDA, OpenCL, Metal)\n\u251c\u2500\u2500 sensors/        # Sensor models with MIL-SPEC noise profiles\n\u2514\u2500\u2500 xr/             # XR integration, spatial audio, haptics\n</code></pre>"},{"location":"api/overview/#quick-reference","title":"Quick Reference","text":""},{"location":"api/overview/#engine-lifecycle","title":"Engine Lifecycle","text":"<pre><code>#include &lt;jaguar/jaguar.h&gt;\n\njaguar::interface::Engine engine;\n\n// Initialize\nbool success = engine.initialize();\nbool success = engine.initialize(config);\n\n// Run simulation\nengine.step(dt);                    // Single step\nengine.run_for(duration_seconds);   // Run duration\nengine.run();                       // Run continuously\n\n// Cleanup\nengine.shutdown();\n</code></pre>"},{"location":"api/overview/#entity-management","title":"Entity Management","text":"<pre><code>// Create\nEntityId id = engine.create_entity(\"name\", Domain::Air);\nEntityId id = engine.create_entity_from_config(config);\n\n// State access\nengine.set_entity_state(id, state);\nEntityState state = engine.get_entity_state(id);\n\n// Forces\nengine.apply_forces(id, forces);\n\n// Environment\nEnvironment env = engine.get_environment(id);\n\n// Destroy\nengine.destroy_entity(id);\n</code></pre>"},{"location":"api/overview/#core-types","title":"Core Types","text":"<pre><code>// Numeric types\nusing Real = double;\nusing EntityId = uint64_t;\n\n// Math types\nstruct Vec3 { Real x, y, z; };\nstruct Vec4 { Real x, y, z, w; };\nstruct Quaternion { Real w, x, y, z; };\nstruct Mat3x3 { Real data[3][3]; };\n\n// Enumerations\nenum class Domain { Generic, Air, Land, Sea, Space };\nenum class CoordinateFrame { ECEF, NED, ENU, ECI };\n</code></pre>"},{"location":"api/overview/#module-reference","title":"Module Reference","text":""},{"location":"api/overview/#core-module","title":"Core Module","text":"<p>Fundamental types, math operations, and utilities.</p> Component Header Description Types <code>jaguar/core/types.h</code> Basic numeric types, EntityId Math <code>jaguar/core/math/</code> Vector, quaternion, matrix Coordinates <code>jaguar/core/coordinates.h</code> ECEF, NED, ECI transforms Memory <code>jaguar/core/memory.h</code> Pool allocation SIMD <code>jaguar/core/simd.h</code> AVX2/FMA wrappers Property <code>jaguar/core/property.h</code> Property system Time <code>jaguar/core/time.h</code> Time management"},{"location":"api/overview/#physics-module","title":"Physics Module","text":"<p>Entity management and physics integration.</p> Component Header Description Entity <code>jaguar/physics/entity.h</code> EntityState, EntityManager Force <code>jaguar/physics/force.h</code> Force generators Solver <code>jaguar/physics/solver.h</code> Numerical integrators Collision <code>jaguar/physics/collision.h</code> Collision detection"},{"location":"api/overview/#air-domain","title":"Air Domain","text":"<p>Aircraft physics models.</p> Component Header Description Aerodynamics <code>jaguar/domain/air.h</code> Lift, drag, moments Propulsion <code>jaguar/domain/air.h</code> Engine models Flight Control <code>jaguar/domain/air.h</code> FCS, autopilot"},{"location":"api/overview/#land-domain","title":"Land Domain","text":"<p>Ground vehicle physics models.</p> Component Header Description Terramechanics <code>jaguar/domain/land.h</code> Soil interaction Suspension <code>jaguar/domain/land.h</code> Spring-damper Tracked <code>jaguar/domain/land.h</code> Track dynamics"},{"location":"api/overview/#sea-domain","title":"Sea Domain","text":"<p>Ship and submarine physics models.</p> Component Header Description Buoyancy <code>jaguar/domain/sea.h</code> Hydrostatics Hydrodynamics <code>jaguar/domain/sea.h</code> Maneuvering Waves <code>jaguar/domain/sea.h</code> Wave spectra, RAO"},{"location":"api/overview/#space-domain","title":"Space Domain","text":"<p>Orbital mechanics and spacecraft physics.</p> Component Header Description Orbital <code>jaguar/domain/space.h</code> Elements, TLE SGP4 <code>jaguar/domain/space.h</code> Orbit propagation Gravity <code>jaguar/domain/space.h</code> Gravity models"},{"location":"api/overview/#environment-module","title":"Environment Module","text":"<p>Environmental models.</p> Component Header Description Atmosphere <code>jaguar/environment/atmosphere.h</code> US Std 1976 Terrain <code>jaguar/environment/terrain.h</code> DEM, materials Ocean <code>jaguar/environment/ocean.h</code> Waves, currents"},{"location":"api/overview/#configuration","title":"Configuration","text":"<p>Configuration and setup.</p> Component Header Description Config <code>jaguar/interface/config.h</code> Engine config XML <code>jaguar/interface/config.h</code> Entity configs"},{"location":"api/overview/#cloud-burst-module","title":"Cloud Burst Module","text":"<p>Distributed simulation and cloud scaling.</p> Component Header Description State Sync <code>jaguar/cloud/state_sync.h</code> Distributed state synchronization Partition Manager <code>jaguar/cloud/partition_manager.h</code> Spatial/domain partitioning Distributed Time <code>jaguar/cloud/distributed_time.h</code> Raft consensus, vector clocks"},{"location":"api/overview/#digital-thread-module","title":"Digital Thread Module","text":"<p>Lifecycle management and predictive maintenance.</p> Component Header Description History Store <code>jaguar/thread/history_store.h</code> State history, snapshots, export Degradation Model <code>jaguar/thread/degradation_model.h</code> Failure prediction, maintenance"},{"location":"api/overview/#machine-learning-module","title":"Machine Learning Module","text":"<p>Neural networks and reinforcement learning.</p> Component Header Description Neural Autopilot <code>jaguar/ml/neural_autopilot.h</code> NN-based flight control Model Repository <code>jaguar/ml/model_repository.h</code> Model versioning, caching RL Environment <code>jaguar/ml/rl_environment.h</code> Gym-compatible RL interface"},{"location":"api/overview/#federation-module","title":"Federation Module","text":"<p>Distributed Interactive Simulation and HLA.</p> Component Header Description DIS Protocol <code>jaguar/federation/dis_protocol.h</code> IEEE 1278.1-2012 PDUs HLA RTI <code>jaguar/federation/hla_rti.h</code> IEEE 1516-2010 federation"},{"location":"api/overview/#gpu-compute-module","title":"GPU Compute Module","text":"<p>Hardware-accelerated computation.</p> Component Header Description Compute Backend <code>jaguar/gpu/compute_backend.h</code> CUDA, OpenCL, Metal abstraction"},{"location":"api/overview/#sensors-module","title":"Sensors Module","text":"<p>Sensor simulation with realistic noise models.</p> Component Header Description Sensor Base <code>jaguar/sensors/sensor.h</code> Sensor interface, noise models IMU Sensor <code>jaguar/sensors/imu_sensor.h</code> MIL-SPEC IMU simulation"},{"location":"api/overview/#xr-module","title":"XR Module","text":"<p>Extended reality integration.</p> Component Header Description OpenXR <code>jaguar/xr/openxr_integration.h</code> VR/AR device support Spatial Audio <code>jaguar/xr/spatial_audio.h</code> 3D audio rendering Haptics <code>jaguar/xr/haptic_feedback.h</code> Tactile feedback Training <code>jaguar/xr/training_scenario.h</code> Scenario management"},{"location":"api/overview/#constants","title":"Constants","text":"<pre><code>namespace jaguar::constants {\n    constexpr Real PI = 3.14159265358979323846;\n    constexpr Real TWO_PI = 6.28318530717958647692;\n    constexpr Real DEG_TO_RAD = PI / 180.0;\n    constexpr Real RAD_TO_DEG = 180.0 / PI;\n\n    constexpr Real G0 = 9.80665;              // Standard gravity (m/s\u00b2)\n    constexpr Real EARTH_RADIUS = 6378137.0;  // WGS84 equatorial (m)\n    constexpr Real EARTH_MU = 3.986004418e14; // Earth GM (m\u00b3/s\u00b2)\n}\n</code></pre>"},{"location":"api/overview/#common-patterns","title":"Common Patterns","text":""},{"location":"api/overview/#creating-an-aircraft","title":"Creating an Aircraft","text":"<pre><code>#include &lt;jaguar/jaguar.h&gt;\n#include &lt;jaguar/domain/air.h&gt;\n\n// Create entity\nauto aircraft = engine.create_entity(\"F-16\", Domain::Air);\n\n// Configure aerodynamics\ndomain::air::AerodynamicsModel aero;\naero.set_reference_area(27.87);  // m\u00b2\naero.set_reference_chord(3.45);  // m\naero.set_reference_span(9.45);   // m\n\n// Configure propulsion\ndomain::air::PropulsionModel prop;\nprop.set_max_thrust(131000.0);   // N\nprop.set_fuel_capacity(3200.0);  // kg\nprop.start();\n\n// Set initial state\nphysics::EntityState state;\nstate.position = {0, 0, -10000};  // 10 km altitude\nstate.velocity = {250, 0, 0};     // 250 m/s\nstate.mass = 12000;\nengine.set_entity_state(aircraft, state);\n\n// Simulation loop\nwhile (running) {\n    physics::EntityForces forces;\n\n    auto s = engine.get_entity_state(aircraft);\n    auto env = engine.get_environment(aircraft);\n\n    aero.compute_forces(s, env, dt, forces);\n    prop.compute_forces(s, env, dt, forces);\n    forces.add_force({0, 0, s.mass * constants::G0});\n\n    engine.apply_forces(aircraft, forces);\n    engine.step(dt);\n}\n</code></pre>"},{"location":"api/overview/#creating-a-ground-vehicle","title":"Creating a Ground Vehicle","text":"<pre><code>#include &lt;jaguar/jaguar.h&gt;\n#include &lt;jaguar/domain/land.h&gt;\n\nauto tank = engine.create_entity(\"M1A2\", Domain::Land);\n\ndomain::land::TerramechanicsModel terra;\nterra.set_contact_area(0.63, 4.6);    // Track dimensions\nterra.set_vehicle_weight(549000.0);   // N\n\ndomain::land::SuspensionModel suspension;\ndomain::land::SuspensionUnit wheel;\nwheel.spring_k = 300000.0;\nwheel.damper_c = 30000.0;\nsuspension.add_unit({-3.5, 1.8, -0.9}, wheel);\n// Add more wheels...\n\nphysics::EntityState state;\nstate.position = {0, 0, 0};\nstate.mass = 56000;\nengine.set_entity_state(tank, state);\n</code></pre>"},{"location":"api/overview/#creating-a-ship","title":"Creating a Ship","text":"<pre><code>#include &lt;jaguar/jaguar.h&gt;\n#include &lt;jaguar/domain/sea.h&gt;\n\nauto ship = engine.create_entity(\"DDG-51\", Domain::Sea);\n\ndomain::sea::BuoyancyModel buoyancy;\nbuoyancy.set_displaced_volume(8400.0);\nbuoyancy.set_metacentric_height(2.5);\n\ndomain::sea::HydrodynamicsModel hydro;\nhydro.set_hull_coefficients(-0.04, -0.01, -0.4, 0.05, -0.1, -0.05);\n\ndomain::sea::WaveModel waves;\nwaves.set_sea_state(domain::sea::SeaState::FromNATOSeaState(4));\n\nphysics::EntityState state;\nstate.position = {0, 0, 0};\nstate.mass = 8600000;  // 8600 tonnes\nengine.set_entity_state(ship, state);\n</code></pre>"},{"location":"api/overview/#creating-a-satellite","title":"Creating a Satellite","text":"<pre><code>#include &lt;jaguar/jaguar.h&gt;\n#include &lt;jaguar/domain/space.h&gt;\n\nauto sat = engine.create_entity(\"GPS-IIR\", Domain::Space);\n\ndomain::space::GravityModel gravity;\ngravity.set_fidelity(domain::space::GravityFidelity::J4);\n\ndomain::space::OrbitalElements orbit;\norbit.semi_major_axis = 26560000;  // GPS orbit\norbit.eccentricity = 0.01;\norbit.inclination = 55.0 * constants::DEG_TO_RAD;\n\nVec3 pos, vel;\norbit.to_cartesian(pos, vel);\n\nphysics::EntityState state;\nstate.position = pos;\nstate.velocity = vel;\nstate.mass = 2000;\nengine.set_entity_state(sat, state);\n</code></pre>"},{"location":"api/overview/#error-handling","title":"Error Handling","text":"<pre><code>// Initialization\nif (!engine.initialize()) {\n    // Handle initialization failure\n    std::cerr &lt;&lt; \"Engine init failed\\n\";\n}\n\n// Entity creation\nEntityId id = engine.create_entity(\"name\", Domain::Air);\nif (id == INVALID_ENTITY_ID) {\n    // Handle creation failure\n}\n\n// State access\nif (engine.entity_exists(id)) {\n    auto state = engine.get_entity_state(id);\n}\n</code></pre>"},{"location":"api/overview/#thread-safety","title":"Thread Safety","text":"<ul> <li>Engine methods are not thread-safe by default</li> <li>Use single-threaded access or external synchronization</li> <li>Internal physics computation may use multiple threads</li> <li>Entity state access should be done from the main thread</li> </ul>"},{"location":"api/overview/#performance-tips","title":"Performance Tips","text":"<ol> <li>Batch operations: Update multiple entities before stepping</li> <li>Pre-fetch states: Get all states before computing forces</li> <li>Reuse force objects: Clear and reuse <code>EntityForces</code></li> <li>Property binding: Bind frequently-accessed properties</li> <li>Appropriate time step: Don't over-resolve dynamics</li> </ol> <pre><code>// Efficient batch update pattern\nstd::vector&lt;EntityId&gt; entities = engine.get_all_entities();\nstd::vector&lt;EntityState&gt; states;\nstd::vector&lt;Environment&gt; envs;\n\n// Pre-fetch all data\nfor (auto id : entities) {\n    states.push_back(engine.get_entity_state(id));\n    envs.push_back(engine.get_environment(id));\n}\n\n// Compute forces (can be parallelized)\nstd::vector&lt;EntityForces&gt; forces(entities.size());\nfor (size_t i = 0; i &lt; entities.size(); ++i) {\n    compute_entity_forces(states[i], envs[i], dt, forces[i]);\n}\n\n// Apply all forces\nfor (size_t i = 0; i &lt; entities.size(); ++i) {\n    engine.apply_forces(entities[i], forces[i]);\n}\n\n// Single physics step\nengine.step(dt);\n</code></pre>"},{"location":"api/overview/#see-also","title":"See Also","text":"<ul> <li>Configuration Reference</li> <li>Python API</li> <li>Lua API</li> <li>Examples</li> </ul>"},{"location":"api/physics/","title":"Physics API Reference","text":"<p>Entity state, forces, integrators, and physics engine components.</p> <p>Headers: <code>jaguar/physics/entity.h</code>, <code>jaguar/physics/solver.h</code>, <code>jaguar/physics/force.h</code></p>"},{"location":"api/physics/#entitystate","title":"EntityState","text":"<p>Complete kinematic state of an entity.</p> <pre><code>struct EntityState {\n    Vec3 position{0, 0, 0};           // Position in ECEF (m)\n    Vec3 velocity{0, 0, 0};           // Velocity (m/s)\n    Quaternion orientation;            // Attitude quaternion\n    Vec3 angular_velocity{0, 0, 0};   // Angular velocity (rad/s)\n    Real mass{1.0};                   // Mass (kg)\n    Mat3x3 inertia;                   // Inertia tensor (kg\u00b7m\u00b2)\n\n    // Derived quantities\n    Real get_roll() const;            // Roll angle (rad)\n    Real get_pitch() const;           // Pitch angle (rad)\n    Real get_yaw() const;             // Yaw/heading angle (rad)\n    Vec3 get_euler_angles() const;    // {roll, pitch, yaw}\n    Mat3x3 get_rotation_matrix() const;\n\n    // Body frame conversions\n    Vec3 world_to_body(const Vec3&amp; world) const;\n    Vec3 body_to_world(const Vec3&amp; body) const;\n};\n</code></pre>"},{"location":"api/physics/#example","title":"Example","text":"<pre><code>physics::EntityState state;\n\n// Set position (San Francisco, 10km altitude)\nReal lat = 37.7749 * DEG_TO_RAD;\nReal lon = -122.4194 * DEG_TO_RAD;\nReal alt = 10000.0;\nstate.position = transforms::geodetic_to_ecef(lat, lon, alt);\n\n// Set velocity (heading east at 200 m/s)\nstate.velocity = Vec3{200.0, 0.0, 0.0};  // Will need rotation\n\n// Set orientation (level flight, heading east)\nstate.orientation = Quaternion::from_euler(0.0, 0.0, 90.0 * DEG_TO_RAD);\n\n// Set mass properties\nstate.mass = 15000.0;  // 15 tonnes\nstate.inertia = Mat3x3::identity();\nstate.inertia.data[0][0] = 20000;   // Ixx\nstate.inertia.data[1][1] = 100000;  // Iyy\nstate.inertia.data[2][2] = 110000;  // Izz\n\n// Query derived values\nReal pitch = state.get_pitch() * RAD_TO_DEG;\nstd::cout &lt;&lt; \"Pitch: \" &lt;&lt; pitch &lt;&lt; \" degrees\\n\";\n</code></pre>"},{"location":"api/physics/#entityforces","title":"EntityForces","text":"<p>Accumulated forces and torques acting on an entity.</p> <pre><code>struct EntityForces {\n    Vec3 force{0, 0, 0};    // Total force (N)\n    Vec3 torque{0, 0, 0};   // Total torque (N\u00b7m)\n\n    void clear();\n    void add_force(const Vec3&amp; f);\n    void add_torque(const Vec3&amp; t);\n    void add_force_at_point(const Vec3&amp; f, const Vec3&amp; point, const Vec3&amp; cg);\n};\n</code></pre>"},{"location":"api/physics/#methods","title":"Methods","text":""},{"location":"api/physics/#clear","title":"<code>clear()</code>","text":"<p>Reset forces and torques to zero.</p>"},{"location":"api/physics/#add_forceconst-vec3-f","title":"<code>add_force(const Vec3&amp; f)</code>","text":"<p>Add a force vector (in world coordinates).</p>"},{"location":"api/physics/#add_torqueconst-vec3-t","title":"<code>add_torque(const Vec3&amp; t)</code>","text":"<p>Add a torque vector (in world coordinates).</p>"},{"location":"api/physics/#add_force_at_pointconst-vec3-f-const-vec3-point-const-vec3-cg","title":"<code>add_force_at_point(const Vec3&amp; f, const Vec3&amp; point, const Vec3&amp; cg)</code>","text":"<p>Add a force at a specific point, automatically computing the resulting torque about the center of gravity.</p>"},{"location":"api/physics/#example_1","title":"Example","text":"<pre><code>physics::EntityForces forces;\nforces.clear();\n\n// Gravity (world frame)\nVec3 gravity{0.0, 0.0, state.mass * constants::G0};\nforces.add_force(gravity);\n\n// Thrust (body frame, converted to world)\nVec3 thrust_body{50000.0, 0.0, 0.0};  // 50 kN forward\nVec3 thrust_world = state.orientation.rotate(thrust_body);\nforces.add_force(thrust_world);\n\n// Force at point (creates torque)\nVec3 wing_force{0.0, 0.0, -5000.0};  // 5 kN lift on right wing\nVec3 wing_position{0.0, 5.0, 0.0};   // 5m right of CG\nVec3 cg{0.0, 0.0, 0.0};\nforces.add_force_at_point(wing_force, wing_position, cg);\n\n// Apply to entity\nengine.apply_forces(entity_id, forces);\n</code></pre>"},{"location":"api/physics/#entitymanager","title":"EntityManager","text":"<p>Manages entity creation, destruction, and state access.</p> <pre><code>class EntityManager {\npublic:\n    // Entity lifecycle\n    EntityId create_entity(const std::string&amp; name, Domain domain);\n    void destroy_entity(EntityId id);\n    bool entity_exists(EntityId id) const;\n\n    // State access\n    EntityState get_state(EntityId id) const;\n    void set_state(EntityId id, const EntityState&amp; state);\n\n    // Properties\n    Domain get_domain(EntityId id) const;\n    std::string get_name(EntityId id) const;\n\n    // Queries\n    SizeT entity_count() const;\n    std::vector&lt;EntityId&gt; get_all_entities() const;\n    std::vector&lt;EntityId&gt; get_entities_by_domain(Domain domain) const;\n};\n</code></pre>"},{"location":"api/physics/#example_2","title":"Example","text":"<pre><code>// Get entity manager from engine\nauto&amp; manager = engine.get_entity_manager();\n\n// Create entities\nEntityId fighter = manager.create_entity(\"F-16\", Domain::Air);\nEntityId tank = manager.create_entity(\"M1A2\", Domain::Land);\n\n// Query entities\nstd::cout &lt;&lt; \"Total entities: \" &lt;&lt; manager.entity_count() &lt;&lt; \"\\n\";\n\n// Get all aircraft\nauto aircraft = manager.get_entities_by_domain(Domain::Air);\nfor (EntityId id : aircraft) {\n    std::cout &lt;&lt; \"Aircraft: \" &lt;&lt; manager.get_name(id) &lt;&lt; \"\\n\";\n}\n\n// Check existence\nif (manager.entity_exists(fighter)) {\n    auto state = manager.get_state(fighter);\n    // ...\n}\n\n// Destroy entity\nmanager.destroy_entity(tank);\n</code></pre>"},{"location":"api/physics/#integrators","title":"Integrators","text":"<p>Numerical integration methods for state propagation.</p>"},{"location":"api/physics/#istatepropagator-interface","title":"IStatePropagator Interface","text":"<pre><code>class IStatePropagator {\npublic:\n    virtual void propagate(EntityState&amp; state,\n                           const EntityForces&amp; forces,\n                           Real dt) = 0;\n};\n</code></pre>"},{"location":"api/physics/#rk4integrator","title":"RK4Integrator","text":"<p>Fourth-order Runge-Kutta integrator.</p> <pre><code>class RK4Integrator : public IStatePropagator {\npublic:\n    void propagate(EntityState&amp; state,\n                   const EntityForces&amp; forces,\n                   Real dt) override;\n};\n</code></pre> <p>Characteristics: - Fourth-order accuracy - Good stability - Requires 4 derivative evaluations per step - Recommended for general use</p>"},{"location":"api/physics/#abm4integrator","title":"ABM4Integrator","text":"<p>Adams-Bashforth-Moulton predictor-corrector.</p> <pre><code>class ABM4Integrator : public IStatePropagator {\npublic:\n    void propagate(EntityState&amp; state,\n                   const EntityForces&amp; forces,\n                   Real dt) override;\n\n    void reset();  // Clear history for new simulation\n};\n</code></pre> <p>Characteristics: - Fourth-order accuracy - More efficient than RK4 (fewer evaluations) - Requires startup phase - Good for long simulations with constant dt</p>"},{"location":"api/physics/#example_3","title":"Example","text":"<pre><code>// Create integrator\nauto integrator = std::make_unique&lt;RK4Integrator&gt;();\n\n// Simulation loop\nphysics::EntityState state;\nphysics::EntityForces forces;\nReal dt = 0.01;\n\nfor (Real t = 0; t &lt; 100.0; t += dt) {\n    // Compute forces\n    forces.clear();\n    compute_forces(state, forces);\n\n    // Propagate state\n    integrator-&gt;propagate(state, forces, dt);\n}\n</code></pre>"},{"location":"api/physics/#force-generator-interface","title":"Force Generator Interface","text":"<p>Base interface for all force generators.</p> <pre><code>class IForceGenerator {\npublic:\n    virtual void compute_forces(const EntityState&amp; state,\n                                const environment::Environment&amp; env,\n                                Real dt,\n                                EntityForces&amp; forces) = 0;\n};\n</code></pre>"},{"location":"api/physics/#domain-specific-interfaces","title":"Domain-Specific Interfaces","text":""},{"location":"api/physics/#iaerodynamicsmodel","title":"IAerodynamicsModel","text":"<pre><code>class IAerodynamicsModel : public IForceGenerator {\npublic:\n    virtual Real get_cl() const = 0;      // Lift coefficient\n    virtual Real get_cd() const = 0;      // Drag coefficient\n    virtual Real get_cm() const = 0;      // Pitching moment coeff\n    virtual Real get_alpha() const = 0;   // Angle of attack (rad)\n    virtual Real get_beta() const = 0;    // Sideslip angle (rad)\n    virtual Real get_mach() const = 0;    // Mach number\n    virtual Real get_qbar() const = 0;    // Dynamic pressure (Pa)\n};\n</code></pre>"},{"location":"api/physics/#ipropulsionmodel","title":"IPropulsionModel","text":"<pre><code>class IPropulsionModel : public IForceGenerator {\npublic:\n    virtual Real get_thrust() const = 0;          // Current thrust (N)\n    virtual Real get_fuel_flow() const = 0;       // Fuel flow (kg/s)\n    virtual Real get_fuel_remaining() const = 0;  // Remaining fuel (kg)\n    virtual bool is_running() const = 0;          // Engine running\n};\n</code></pre>"},{"location":"api/physics/#iterramechanicsmodel","title":"ITerramechanicsModel","text":"<pre><code>class ITerramechanicsModel : public IForceGenerator {\npublic:\n    virtual Real get_sinkage() const = 0;           // Sinkage depth (m)\n    virtual Real get_motion_resistance() const = 0; // Resistance (N)\n    virtual Real get_traction() const = 0;          // Traction force (N)\n    virtual Real get_slip_ratio() const = 0;        // Slip ratio\n};\n</code></pre>"},{"location":"api/physics/#ihydrodynamicsmodel","title":"IHydrodynamicsModel","text":"<pre><code>class IHydrodynamicsModel : public IForceGenerator {\npublic:\n    virtual Real get_buoyancy() const = 0;  // Buoyancy force (N)\n    virtual Real get_draft() const = 0;     // Draft depth (m)\n    virtual Real get_heel() const = 0;      // Heel angle (rad)\n    virtual Real get_trim() const = 0;      // Trim angle (rad)\n};\n</code></pre>"},{"location":"api/physics/#example-custom-force-generator","title":"Example: Custom Force Generator","text":"<pre><code>class SimpleDragModel : public IForceGenerator {\npublic:\n    void set_drag_coefficient(Real cd) { cd_ = cd; }\n    void set_reference_area(Real area) { area_ = area; }\n\n    void compute_forces(const EntityState&amp; state,\n                        const Environment&amp; env,\n                        Real dt,\n                        EntityForces&amp; forces) override {\n        Real speed = state.velocity.norm();\n        if (speed &lt; 0.001) return;\n\n        // Drag = 0.5 * rho * V^2 * Cd * A\n        Real qbar = 0.5 * env.atmosphere.density * speed * speed;\n        Real drag_mag = qbar * cd_ * area_;\n\n        // Drag opposes velocity\n        Vec3 drag = state.velocity.normalized() * (-drag_mag);\n        forces.add_force(drag);\n    }\n\nprivate:\n    Real cd_{1.0};\n    Real area_{1.0};\n};\n</code></pre>"},{"location":"api/physics/#see-also","title":"See Also","text":"<ul> <li>Core API - Basic types and vectors</li> <li>Air Domain API - Aerodynamics models</li> <li>Land Domain API - Terramechanics models</li> <li>Sea Domain API - Hydrodynamics models</li> <li>Concepts: Integration - Integration methods</li> </ul>"},{"location":"api/python/","title":"Python API Reference","text":"<p>Python bindings for JaguarEngine using pybind11 with full NumPy interoperability.</p>"},{"location":"api/python/#installation","title":"Installation","text":""},{"location":"api/python/#from-package-coming-soon","title":"From Package (Coming Soon)","text":"<pre><code>pip install jaguar-engine\n</code></pre>"},{"location":"api/python/#build-from-source","title":"Build from Source","text":"<pre><code>cd JaguarEngine\n\n# Configure with Python bindings enabled\ncmake -B build -DJAGUAR_BUILD_PYTHON=ON\n\n# Build\ncmake --build build --parallel\n\n# Install the module\npip install -e .\n</code></pre> <p>Requirements: - Python 3.8+ - NumPy (for array interoperability) - pybind11 (auto-fetched by CMake)</p>"},{"location":"api/python/#quick-start","title":"Quick Start","text":"<pre><code>import jaguar\n\n# Create and initialize engine\nengine = jaguar.Engine()\nengine.initialize()\n\n# Create an aircraft\naircraft = engine.create_entity(\"F-16\", jaguar.Domain.Air)\n\n# Set initial state\nstate = jaguar.EntityState()\nstate.position = jaguar.Vec3(0, 0, -5000)  # 5 km altitude\nstate.velocity = jaguar.Vec3(200, 0, 0)    # 200 m/s\nstate.mass = 12000\nengine.set_entity_state(aircraft, state)\n\n# Simulation loop\ndt = 0.01\nfor t in range(10000):  # 100 seconds\n    engine.step(dt)\n\n    # Get current state\n    state = engine.get_entity_state(aircraft)\n    if t % 100 == 0:\n        print(f\"Time: {t*dt:.1f}s, Alt: {-state.position.z:.0f}m\")\n\nengine.shutdown()\n</code></pre>"},{"location":"api/python/#core-types","title":"Core Types","text":""},{"location":"api/python/#vec3","title":"Vec3","text":"<pre><code># Construction\nv = jaguar.Vec3()           # (0, 0, 0)\nv = jaguar.Vec3(1, 2, 3)    # (1, 2, 3)\nv = jaguar.Vec3([1, 2, 3])  # From list\n\n# Properties\nx, y, z = v.x, v.y, v.z\n\n# Methods\nlength = v.norm()\nunit = v.normalized()\ndot = v.dot(other)\ncross = v.cross(other)\n\n# Operators\nv3 = v1 + v2\nv3 = v1 - v2\nv3 = v * 2.0\nv3 = v / 2.0\n\n# NumPy interop\nimport numpy as np\narr = v.to_numpy()           # To NumPy array\nv = jaguar.Vec3.from_numpy(arr)  # From NumPy array\n</code></pre>"},{"location":"api/python/#numpy-integration","title":"NumPy Integration","text":"<p>JaguarEngine provides seamless NumPy integration for efficient array operations:</p> <pre><code>import numpy as np\nimport jaguar\n\n# Vector batch operations\npositions = np.array([\n    [0, 0, -1000],\n    [100, 0, -1000],\n    [200, 0, -1000]\n], dtype=np.float64)\n\n# Create Vec3 from NumPy row\nv = jaguar.Vec3.from_numpy(positions[0])\n\n# Convert back to NumPy\narr = v.to_numpy()  # [0, 0, -1000]\n\n# Matrix interop\nm = jaguar.Mat3x3.Identity()\nnp_matrix = m.to_numpy()  # 3x3 NumPy array\n</code></pre>"},{"location":"api/python/#quaternion","title":"Quaternion","text":"<pre><code># Construction\nq = jaguar.Quaternion()                    # Identity\nq = jaguar.Quaternion(w, x, y, z)\nq = jaguar.Quaternion.from_euler(roll, pitch, yaw)\nq = jaguar.Quaternion.from_axis_angle(axis, angle)\n\n# Methods\nq_norm = q.normalized()\nq_conj = q.conjugate()\nv_rot = q.rotate(v)\nroll, pitch, yaw = q.to_euler()\n\n# Operators\nq3 = q1 * q2  # Rotation composition\n</code></pre>"},{"location":"api/python/#mat3x3","title":"Mat3x3","text":"<pre><code># Construction\nm = jaguar.Mat3x3()                     # Identity\nm = jaguar.Mat3x3.from_euler(r, p, y)\n\n# Access\nvalue = m[i, j]\nm[i, j] = value\n\n# Methods\nv_out = m * v_in\nm_out = m1 * m2\nm_t = m.transpose()\n\n# NumPy interop\nimport numpy as np\narr = np.array(m)        # 3x3 NumPy array\nm = jaguar.Mat3x3(arr)   # From NumPy\n</code></pre>"},{"location":"api/python/#engine","title":"Engine","text":"<pre><code>class Engine:\n    def initialize(self, config: EngineConfig = None) -&gt; bool\n    def shutdown(self) -&gt; None\n\n    # Entity management\n    def create_entity(self, name: str, domain: Domain) -&gt; int\n    def destroy_entity(self, entity_id: int) -&gt; None\n    def entity_exists(self, entity_id: int) -&gt; bool\n\n    # State access\n    def get_entity_state(self, entity_id: int) -&gt; EntityState\n    def set_entity_state(self, entity_id: int, state: EntityState) -&gt; None\n    def apply_forces(self, entity_id: int, forces: EntityForces) -&gt; None\n\n    # Environment\n    def get_environment(self, entity_id: int) -&gt; Environment\n    def get_environment_at(self, position: Vec3) -&gt; Environment\n\n    # Simulation\n    def step(self, dt: float) -&gt; None\n    def run_for(self, duration: float) -&gt; None\n\n    # Time\n    def get_time(self) -&gt; float\n    def set_time(self, time: float) -&gt; None\n\n    # Properties\n    def entity_count(self) -&gt; int\n</code></pre>"},{"location":"api/python/#example","title":"Example","text":"<pre><code>import jaguar\n\n# Configure engine\nconfig = jaguar.EngineConfig()\nconfig.time_step = 0.01\nconfig.terrain_enabled = True\nconfig.terrain_data_paths = [\"/data/dted/\"]\n\n# Initialize\nengine = jaguar.Engine()\nif not engine.initialize(config):\n    raise RuntimeError(\"Failed to initialize engine\")\n\ntry:\n    # Create entities\n    aircraft = engine.create_entity(\"Aircraft\", jaguar.Domain.Air)\n\n    # Run simulation\n    while engine.get_time() &lt; 60.0:\n        engine.step(0.01)\n\nfinally:\n    engine.shutdown()\n</code></pre>"},{"location":"api/python/#entitystate","title":"EntityState","text":"<pre><code>class EntityState:\n    position: Vec3          # m (ECEF)\n    velocity: Vec3          # m/s\n    orientation: Quaternion\n    angular_velocity: Vec3  # rad/s\n    mass: float            # kg\n    inertia: Mat3x3        # kg\u00b7m\u00b2\n\n    # Derived properties\n    def get_roll(self) -&gt; float    # rad\n    def get_pitch(self) -&gt; float   # rad\n    def get_yaw(self) -&gt; float     # rad\n    def get_euler(self) -&gt; tuple   # (roll, pitch, yaw)\n</code></pre>"},{"location":"api/python/#example_1","title":"Example","text":"<pre><code>state = jaguar.EntityState()\n\n# Set position (geodetic to ECEF)\nlat, lon, alt = 37.0, -122.0, 10000.0\nstate.position = jaguar.transforms.geodetic_to_ecef(\n    lat * jaguar.DEG_TO_RAD,\n    lon * jaguar.DEG_TO_RAD,\n    alt\n)\n\n# Set velocity\nstate.velocity = jaguar.Vec3(200, 0, 0)\n\n# Set orientation\nstate.orientation = jaguar.Quaternion.from_euler(\n    0.0,                    # roll\n    5.0 * jaguar.DEG_TO_RAD, # pitch\n    90.0 * jaguar.DEG_TO_RAD # heading (east)\n)\n\n# Set mass properties\nstate.mass = 15000.0\nstate.inertia = jaguar.Mat3x3()\nstate.inertia[0, 0] = 20000   # Ixx\nstate.inertia[1, 1] = 100000  # Iyy\nstate.inertia[2, 2] = 110000  # Izz\n\nengine.set_entity_state(entity_id, state)\n</code></pre>"},{"location":"api/python/#entityforces","title":"EntityForces","text":"<pre><code>class EntityForces:\n    force: Vec3    # N\n    torque: Vec3   # N\u00b7m\n\n    def clear(self) -&gt; None\n    def add_force(self, f: Vec3) -&gt; None\n    def add_torque(self, t: Vec3) -&gt; None\n    def add_force_at_point(self, f: Vec3, point: Vec3, cg: Vec3) -&gt; None\n</code></pre>"},{"location":"api/python/#example_2","title":"Example","text":"<pre><code>forces = jaguar.EntityForces()\nforces.clear()\n\n# Gravity\ngravity = jaguar.Vec3(0, 0, state.mass * jaguar.G0)\nforces.add_force(gravity)\n\n# Thrust (in body frame, convert to world)\nthrust_body = jaguar.Vec3(50000, 0, 0)\nthrust_world = state.orientation.rotate(thrust_body)\nforces.add_force(thrust_world)\n\nengine.apply_forces(entity_id, forces)\n</code></pre>"},{"location":"api/python/#environment","title":"Environment","text":"<pre><code>class Environment:\n    latitude: float        # rad\n    longitude: float       # rad\n    altitude: float        # m\n    position_ecef: Vec3\n\n    atmosphere: AtmosphereState\n    terrain: TerrainQuery\n    terrain_elevation: float\n    ocean: OceanState\n    over_water: bool\n    gravity: Vec3\n\nclass AtmosphereState:\n    temperature: float     # K\n    pressure: float        # Pa\n    density: float         # kg/m\u00b3\n    speed_of_sound: float  # m/s\n    wind: Vec3             # m/s (NED)\n\nclass TerrainQuery:\n    elevation: float       # m\n    normal: Vec3\n    slope_angle: float     # rad\n    valid: bool\n</code></pre>"},{"location":"api/python/#example_3","title":"Example","text":"<pre><code>env = engine.get_environment(aircraft)\n\nprint(f\"Altitude: {env.altitude:.0f} m\")\nprint(f\"Temperature: {env.atmosphere.temperature:.1f} K\")\nprint(f\"Density: {env.atmosphere.density:.4f} kg/m\u00b3\")\nprint(f\"Terrain elevation: {env.terrain_elevation:.0f} m\")\n\n# Height above terrain\nhat = env.altitude - env.terrain_elevation\nprint(f\"Height above terrain: {hat:.0f} m\")\n</code></pre>"},{"location":"api/python/#domain-models","title":"Domain Models","text":""},{"location":"api/python/#air-domain","title":"Air Domain","text":"<pre><code>from jaguar.domain import air\n\n# Aerodynamics\naero = air.AerodynamicsModel()\naero.set_reference_area(28.0)\naero.set_reference_chord(3.5)\naero.set_reference_span(10.0)\n\naero.set_elevator(elevator_deg)\naero.compute_forces(state, env, dt, forces)\n\nprint(f\"CL: {aero.get_cl():.3f}\")\nprint(f\"Alpha: {aero.get_alpha() * jaguar.RAD_TO_DEG:.1f} deg\")\n\n# Propulsion\nengine_model = air.PropulsionModel()\nengine_model.set_max_thrust(75000)\nengine_model.set_fuel_capacity(3000)\nengine_model.set_throttle(0.8)\nengine_model.compute_forces(state, env, dt, forces)\n</code></pre>"},{"location":"api/python/#land-domain","title":"Land Domain","text":"<pre><code>from jaguar.domain import land\n\n# Soil\nsoil = land.SoilProperties.DrySand()\n\n# Terramechanics\nterra = land.TerramechanicsModel()\nterra.set_contact_area(0.63, 4.6)\nterra.set_vehicle_weight(62000 * jaguar.G0)\nterra.set_soil(soil)\nterra.compute_forces(state, env, dt, forces)\n\nprint(f\"Sinkage: {terra.get_sinkage():.3f} m\")\n</code></pre>"},{"location":"api/python/#sea-domain","title":"Sea Domain","text":"<pre><code>from jaguar.domain import sea\n\n# Sea state\nsea_state = sea.SeaState.FromNATOSeaState(4)\n\n# Buoyancy\nbuoyancy = sea.BuoyancyModel()\nbuoyancy.set_displaced_volume(8390)\nbuoyancy.set_metacentric_height(2.5)\nbuoyancy.compute_forces(state, env, dt, forces)\n\nprint(f\"Draft: {buoyancy.get_draft():.2f} m\")\nprint(f\"Heel: {buoyancy.get_heel() * jaguar.RAD_TO_DEG:.1f} deg\")\n</code></pre>"},{"location":"api/python/#space-domain","title":"Space Domain","text":"<pre><code>from jaguar.domain import space\n\n# Orbital elements\norbit = space.OrbitalElements()\norbit.semi_major_axis = jaguar.EARTH_RADIUS + 420000\norbit.eccentricity = 0.0001\norbit.inclination = 51.6 * jaguar.DEG_TO_RAD\n\npos, vel = orbit.to_cartesian()\nprint(f\"Period: {orbit.period() / 60:.1f} minutes\")\n\n# SGP4 propagator\ntle = space.TLE()\ntle.parse(line1, line2)\n\nsgp4 = space.SGP4Propagator()\nsgp4.initialize(tle)\n\nfor minutes in range(0, 24*60, 10):\n    pos_km, vel_kms = sgp4.propagate(minutes)\n    pos_m = pos_km * 1000\n</code></pre>"},{"location":"api/python/#coordinate-transforms","title":"Coordinate Transforms","text":"<pre><code>from jaguar import transforms\n\n# Geodetic &lt;-&gt; ECEF\necef = transforms.geodetic_to_ecef(lat_rad, lon_rad, alt_m)\nlat, lon, alt = transforms.ecef_to_geodetic(ecef)\n\n# ECEF &lt;-&gt; ECI\neci = transforms.ecef_to_eci(ecef, julian_date)\necef = transforms.eci_to_ecef(eci, julian_date)\n\n# Julian date\njd = transforms.julian_date(2024, 1, 1, 12, 0, 0.0)\n</code></pre>"},{"location":"api/python/#constants","title":"Constants","text":"<pre><code>import jaguar\n\n# Mathematical\njaguar.PI\njaguar.TWO_PI\njaguar.DEG_TO_RAD\njaguar.RAD_TO_DEG\n\n# Physical\njaguar.G0              # Standard gravity (9.80665 m/s\u00b2)\njaguar.EARTH_RADIUS    # WGS84 equatorial radius\njaguar.EARTH_MU        # Earth gravitational parameter\n\n# Enumerations\njaguar.Domain.Air\njaguar.Domain.Land\njaguar.Domain.Sea\njaguar.Domain.Space\n</code></pre>"},{"location":"api/python/#see-also","title":"See Also","text":"<ul> <li>API Overview - Complete API index</li> <li>Lua API - Lua bindings</li> <li>Getting Started - Quick start guide</li> </ul>"},{"location":"api/sea/","title":"Sea Domain API Reference","text":"<p>Hydrodynamics, buoyancy, waves, and ship maneuvering APIs.</p> <p>Header: <code>jaguar/domain/sea.h</code></p>"},{"location":"api/sea/#seastate","title":"SeaState","text":"<p>Ocean wave conditions.</p> <pre><code>enum class WaveSpectrum {\n    PiersonMoskowitz,  // Fully developed sea\n    JONSWAP,           // Fetch-limited sea\n    Bretschneider      // Two-parameter spectrum\n};\n\nstruct SeaState {\n    Real significant_height{1.0};  // H_s (m)\n    Real peak_period{6.0};         // T_p (s)\n    Real direction{0.0};           // Primary wave direction (rad from N)\n    WaveSpectrum spectrum{WaveSpectrum::PiersonMoskowitz};\n    Real spreading{0.0};           // Directional spreading (rad)\n\n    // Create from NATO sea state code (0-8)\n    static SeaState FromNATOSeaState(int sea_state);\n\n    // Derived quantities\n    Real mean_wave_length() const;\n    Real mean_wave_period() const;\n};\n</code></pre>"},{"location":"api/sea/#nato-sea-state-scale","title":"NATO Sea State Scale","text":"Code Significant Height Description 0 0 m Calm (glassy) 1 0 - 0.1 m Calm (rippled) 2 0.1 - 0.5 m Smooth 3 0.5 - 1.25 m Slight 4 1.25 - 2.5 m Moderate 5 2.5 - 4 m Rough 6 4 - 6 m Very rough 7 6 - 9 m High 8 9+ m Very high"},{"location":"api/sea/#example","title":"Example","text":"<pre><code>// From NATO sea state\nauto sea = domain::sea::SeaState::FromNATOSeaState(4);  // Moderate\n\n// Or specify directly\ndomain::sea::SeaState sea;\nsea.significant_height = 2.0;\nsea.peak_period = 8.0;\nsea.direction = 45.0 * DEG_TO_RAD;  // NE swell\nsea.spectrum = WaveSpectrum::JONSWAP;\n</code></pre>"},{"location":"api/sea/#wavemodel","title":"WaveModel","text":"<p>Wave surface simulation.</p> <pre><code>class WaveModel {\npublic:\n    // Configuration\n    void set_sea_state(const SeaState&amp; state);\n    void set_component_count(int count);  // Number of wave components\n    void seed_random(UInt32 seed);        // For reproducibility\n\n    // Query wave surface\n    Real get_elevation(Real x, Real y, Real time) const;\n    Vec3 get_slope(Real x, Real y, Real time) const;\n\n    // Subsurface kinematics\n    Vec3 get_particle_velocity(Real x, Real y, Real z, Real time) const;\n    Vec3 get_particle_acceleration(Real x, Real y, Real z, Real time) const;\n    Real get_pressure(Real x, Real y, Real z, Real time) const;\n\n    // Update internal state\n    void update(Real dt);\n};\n</code></pre>"},{"location":"api/sea/#example_1","title":"Example","text":"<pre><code>domain::sea::WaveModel waves;\n\n// Set sea state\nauto sea = domain::sea::SeaState::FromNATOSeaState(5);\nwaves.set_sea_state(sea);\nwaves.set_component_count(50);\n\n// Query wave height at ship location\nReal eta = waves.get_elevation(ship_x, ship_y, sim_time);\n\n// Get wave slope for ship orientation\nVec3 slope = waves.get_slope(ship_x, ship_y, sim_time);\n\n// Subsurface velocity (for hydrofoil or sonar)\nVec3 particle_vel = waves.get_particle_velocity(x, y, -10.0, sim_time);\n</code></pre>"},{"location":"api/sea/#buoyancymodel","title":"BuoyancyModel","text":"<p>Static and dynamic buoyancy forces.</p> <pre><code>class BuoyancyModel : public physics::IHydrodynamicsModel {\npublic:\n    // Configuration\n    void set_displaced_volume(Real volume);       // m\u00b3\n    void set_metacentric_height(Real gm);         // GM (m)\n    void set_center_of_buoyancy(const Vec3&amp; cb);  // Relative to CG\n    void set_waterplane_area(Real area);          // m\u00b2\n\n    // Hull shape (optional, for detailed calculation)\n    void set_length(Real length);\n    void set_beam(Real beam);\n    void set_draft(Real draft);\n\n    // IForceGenerator\n    void compute_forces(const physics::EntityState&amp; state,\n                        const environment::Environment&amp; env,\n                        Real dt,\n                        physics::EntityForces&amp; forces) override;\n\n    // IHydrodynamicsModel queries\n    Real get_buoyancy() const override;   // N\n    Real get_draft() const override;      // m\n    Real get_heel() const override;       // rad\n    Real get_trim() const override;       // rad\n\n    // Additional queries\n    Real get_reserve_buoyancy() const;    // N\n    Real get_gm_transverse() const;       // m\n    Real get_gm_longitudinal() const;     // m\n};\n</code></pre>"},{"location":"api/sea/#example_2","title":"Example","text":"<pre><code>domain::sea::BuoyancyModel buoyancy;\n\n// Configure for destroyer\nbuoyancy.set_displaced_volume(8390.0);      // m\u00b3\nbuoyancy.set_metacentric_height(2.5);       // GM = 2.5 m\nbuoyancy.set_center_of_buoyancy(Vec3{0.0, 0.0, -4.7});\nbuoyancy.set_waterplane_area(2500.0);\n\n// In simulation loop\nphysics::EntityForces forces;\nbuoyancy.compute_forces(state, env, dt, forces);\n\n// Check stability\nReal heel = buoyancy.get_heel() * RAD_TO_DEG;\nif (std::abs(heel) &gt; 20.0) {\n    std::cout &lt;&lt; \"Warning: Excessive heel angle!\\n\";\n}\n</code></pre>"},{"location":"api/sea/#hydrodynamicsmodel","title":"HydrodynamicsModel","text":"<p>MMG (Maneuvering Modeling Group) ship maneuvering model.</p> <pre><code>class HydrodynamicsModel : public physics::IHydrodynamicsModel {\npublic:\n    // Hull coefficients (non-dimensional)\n    void set_hull_coefficients(Real x_vv, Real x_rr,\n                               Real y_v, Real y_r,\n                               Real n_v, Real n_r);\n\n    // Cross-coupling coefficients\n    void set_cross_coefficients(Real y_vvr, Real y_vrr,\n                                Real n_vvr, Real n_vrr);\n\n    // Added mass coefficients\n    void set_added_mass(Real x_udot, Real y_vdot, Real n_rdot);\n\n    // Hull dimensions\n    void set_length(Real lpp);        // Length between perpendiculars (m)\n    void set_beam(Real beam);         // Beam (m)\n    void set_draft(Real draft);       // Draft (m)\n    void set_displacement(Real disp); // Displacement (kg)\n\n    // Rudder parameters\n    void set_rudder_area(Real area);           // m\u00b2\n    void set_rudder_aspect_ratio(Real ar);\n    void set_rudder_position(const Vec3&amp; pos); // Relative to CG\n\n    // Propeller parameters\n    void set_propeller_diameter(Real d);       // m\n    void set_propeller_pitch_ratio(Real pr);\n    void set_propeller_position(const Vec3&amp; pos);\n\n    // Control\n    void set_rudder_angle(Real angle_rad);\n    void set_propeller_rpm(Real rpm);\n\n    // IForceGenerator\n    void compute_forces(const physics::EntityState&amp; state,\n                        const environment::Environment&amp; env,\n                        Real dt,\n                        physics::EntityForces&amp; forces) override;\n\n    // Queries\n    Real get_ship_speed() const;        // m/s\n    Real get_drift_angle() const;       // rad\n    Real get_turn_rate() const;         // rad/s\n    Real get_advance() const;           // m (in turning)\n    Real get_transfer() const;          // m (in turning)\n    Real get_tactical_diameter() const; // m\n};\n</code></pre>"},{"location":"api/sea/#example_3","title":"Example","text":"<pre><code>domain::sea::HydrodynamicsModel hydro;\n\n// Set hull coefficients (from model tests or CFD)\nhydro.set_hull_coefficients(\n    -0.04,   // X_vv\n    -0.01,   // X_rr\n    -0.4,    // Y_v\n    0.05,    // Y_r\n    -0.1,    // N_v\n    -0.05    // N_r\n);\n\n// Hull dimensions\nhydro.set_length(154.0);\nhydro.set_beam(20.0);\nhydro.set_draft(9.4);\nhydro.set_displacement(8600000.0);\n\n// Rudder\nhydro.set_rudder_area(18.0);\nhydro.set_rudder_aspect_ratio(1.6);\n\n// Propeller\nhydro.set_propeller_diameter(5.2);\nhydro.set_propeller_pitch_ratio(1.0);\n\n// Control\nhydro.set_propeller_rpm(120.0);\nhydro.set_rudder_angle(rudder_cmd * 35.0 * DEG_TO_RAD);\n\n// Compute forces\nphysics::EntityForces forces;\nhydro.compute_forces(state, env, dt, forces);\n</code></pre>"},{"location":"api/sea/#raomodel","title":"RAOModel","text":"<p>Response Amplitude Operators for seakeeping.</p> <pre><code>class RAOModel {\npublic:\n    // Set RAO for each DOF\n    // DOF: 0=surge, 1=sway, 2=heave, 3=roll, 4=pitch, 5=yaw\n    void set_rao(int dof,\n                 const std::vector&lt;Real&gt;&amp; frequencies,  // rad/s\n                 const std::vector&lt;Real&gt;&amp; amplitudes,   // m/m or rad/m\n                 const std::vector&lt;Real&gt;&amp; phases);      // rad\n\n    // Load from file\n    bool load_from_file(const std::string&amp; path);\n\n    // Query RAO at specific frequency\n    void get_response(Real omega, Real wave_amp,\n                      Real&amp; out_amplitude, Real&amp; out_phase, int dof) const;\n\n    // Calculate total response from wave spectrum\n    void calculate_response(const WaveModel&amp; waves, Real time,\n                            Vec3&amp; out_displacement,   // surge, sway, heave\n                            Vec3&amp; out_rotation);      // roll, pitch, yaw\n\n    // Statistical predictions\n    Real get_significant_response(int dof, const SeaState&amp; sea) const;\n    Real get_rms_response(int dof, const SeaState&amp; sea) const;\n};\n</code></pre>"},{"location":"api/sea/#example_4","title":"Example","text":"<pre><code>domain::sea::RAOModel rao;\n\n// Set heave RAO\nstd::vector&lt;Real&gt; freqs = {0.3, 0.5, 0.7, 1.0, 1.5};\nstd::vector&lt;Real&gt; heave_amp = {0.9, 1.0, 0.95, 0.7, 0.4};\nstd::vector&lt;Real&gt; heave_phase = {0.0, 0.1, 0.2, 0.4, 0.6};\nrao.set_rao(2, freqs, heave_amp, heave_phase);  // DOF 2 = heave\n\n// Set roll RAO\nstd::vector&lt;Real&gt; roll_amp = {0.02, 0.05, 0.08, 0.04, 0.02};\nstd::vector&lt;Real&gt; roll_phase = {0.0, 0.2, 0.5, 0.8, 1.0};\nrao.set_rao(3, freqs, roll_amp, roll_phase);  // DOF 3 = roll\n\n// Calculate response\nVec3 displacement, rotation;\nrao.calculate_response(waves, sim_time, displacement, rotation);\n\n// Apply to ship motion\nstate.position += displacement;\n// Apply rotation to orientation...\n\n// Predict performance\nReal sig_roll = rao.get_significant_response(3, sea);\nstd::cout &lt;&lt; \"Significant roll: \" &lt;&lt; sig_roll * RAD_TO_DEG &lt;&lt; \" deg\\n\";\n</code></pre>"},{"location":"api/sea/#current-model","title":"Current Model","text":"<p>Ocean current effects.</p> <pre><code>class CurrentModel {\npublic:\n    // Set uniform current\n    void set_surface_current(const Vec3&amp; velocity);  // m/s\n\n    // Set depth-varying current\n    void set_current_profile(const std::vector&lt;Real&gt;&amp; depths,\n                             const std::vector&lt;Vec3&gt;&amp; velocities);\n\n    // Query\n    Vec3 get_current(Real depth) const;\n\n    // For relative velocity calculations\n    Vec3 get_relative_velocity(const physics::EntityState&amp; state,\n                               Real depth) const;\n};\n</code></pre>"},{"location":"api/sea/#see-also","title":"See Also","text":"<ul> <li>Physics API - Force generator interfaces</li> <li>Environment API - Ocean system</li> <li>Sea Domain Concepts - Domain overview</li> <li>Sea Domain Tutorial - Step-by-step guide</li> </ul>"},{"location":"api/sensors/","title":"Sensors API Reference","text":"<p>Sensors module (<code>jaguar_sensors</code>) provides high-fidelity sensor simulation with realistic noise models based on MIL-SPEC standards, including Dryden and Von Karman turbulence models.</p>"},{"location":"api/sensors/#overview","title":"Overview","text":"<p>The Sensors module enables: - Sensor Base: Generic sensor interface with configurable noise - IMU Sensor: MIL-SPEC IMU with grade-appropriate noise characteristics - Noise Models: White noise, bias instability, random walk</p>"},{"location":"api/sensors/#sensor-framework","title":"Sensor Framework","text":""},{"location":"api/sensors/#header","title":"Header","text":"<pre><code>#include &lt;jaguar/sensors/sensor.h&gt;\n</code></pre>"},{"location":"api/sensors/#sensor-types","title":"Sensor Types","text":"<pre><code>namespace jaguar::sensors {\n\n// Supported sensor types\nenum class SensorType {\n    IMU,                // Inertial Measurement Unit\n    GPS,                // Global Positioning System\n    Radar,              // Radio Detection and Ranging\n    LIDAR,              // Light Detection and Ranging\n    Camera,             // Visual camera\n    Altimeter,          // Altitude sensor (barometric, radar)\n    Airspeed,           // Pitot-static airspeed\n    MagneticCompass,    // Magnetometer\n    StarTracker,        // Celestial navigation\n    Sonar,              // Underwater acoustic\n    FLIR,               // Forward Looking Infrared\n    RWR,                // Radar Warning Receiver\n    Custom              // User-defined\n};\n\n// Sensor operational states\nenum class SensorState {\n    Off,                // Powered off\n    Initializing,       // Warming up / calibrating\n    Ready,              // Operational\n    Degraded,           // Reduced accuracy\n    Failed              // Non-functional\n};\n\n// Sensor failure modes\nenum class FailureMode {\n    None,               // Normal operation\n    Bias,               // Constant offset\n    Drift,              // Time-varying offset\n    Noise,              // Increased noise\n    Stuck,              // Frozen output\n    Intermittent,       // Random failures\n    Total               // Complete failure\n};\n\n}  // namespace jaguar::sensors\n</code></pre>"},{"location":"api/sensors/#noise-model-types","title":"Noise Model Types","text":"<pre><code>namespace jaguar::sensors {\n\n// White noise parameters\nstruct WhiteNoiseParams {\n    double power_spectral_density;  // PSD (units^2/Hz)\n    double bandwidth;               // Noise bandwidth (Hz)\n\n    // Compute standard deviation\n    double std_dev() const {\n        return std::sqrt(power_spectral_density * bandwidth);\n    }\n};\n\n// Bias instability parameters (Allan variance)\nstruct BiasInstabilityParams {\n    double bias_instability;        // 1-sigma value (units)\n    double correlation_time;        // Correlation time (seconds)\n};\n\n// Random walk parameters\nstruct RandomWalkParams {\n    double random_walk;             // Random walk coefficient (units/sqrt(Hz))\n};\n\n// Combined axis noise model\nstruct AxisNoiseModel {\n    WhiteNoiseParams white_noise;\n    BiasInstabilityParams bias_instability;\n    RandomWalkParams random_walk;\n\n    // Scale factor error (ppm)\n    double scale_factor_error = 0.0;\n\n    // Misalignment (radians)\n    double misalignment = 0.0;\n\n    // Nonlinearity (ppm)\n    double nonlinearity = 0.0;\n};\n\n// 3-axis noise model\nstruct Vec3NoiseModel {\n    AxisNoiseModel x;\n    AxisNoiseModel y;\n    AxisNoiseModel z;\n\n    // Cross-axis sensitivity matrix\n    std::array&lt;std::array&lt;double, 3&gt;, 3&gt; cross_axis = {{{1,0,0},{0,1,0},{0,0,1}}};\n};\n\n}  // namespace jaguar::sensors\n</code></pre>"},{"location":"api/sensors/#sensor-configuration","title":"Sensor Configuration","text":"<pre><code>namespace jaguar::sensors {\n\n// Generic sensor configuration\nstruct SensorConfig {\n    std::string name;\n    SensorType type;\n    double sample_rate;             // Hz\n    double latency;                 // seconds\n    bool enabled = true;\n\n    // Mounting offset (body frame)\n    Vec3 position_offset = {0, 0, 0};\n    Quaternion orientation_offset = {1, 0, 0, 0};\n\n    // Failure configuration\n    double mtbf = 10000.0;          // Mean time between failures (hours)\n    FailureMode failure_mode = FailureMode::None;\n    double failure_probability = 0.0;\n\n    // Environmental limits\n    double min_temperature = -40.0; // Celsius\n    double max_temperature = 85.0;\n    double max_vibration = 20.0;    // g\n    double max_shock = 100.0;       // g\n};\n\n// Sensor measurement template\ntemplate&lt;typename T&gt;\nstruct SensorMeasurement {\n    T value;\n    std::chrono::nanoseconds timestamp;\n    bool valid = true;\n    double confidence = 1.0;        // 0.0 - 1.0\n    SensorState state = SensorState::Ready;\n};\n\n}  // namespace jaguar::sensors\n</code></pre>"},{"location":"api/sensors/#isensor-interface","title":"ISensor Interface","text":"<pre><code>namespace jaguar::sensors {\n\nclass ISensor {\npublic:\n    virtual ~ISensor() = default;\n\n    // Lifecycle\n    virtual bool initialize(const SensorConfig&amp; config) = 0;\n    virtual void shutdown() = 0;\n    virtual void reset() = 0;\n\n    // State\n    virtual SensorState get_state() const = 0;\n    virtual SensorType get_type() const = 0;\n    virtual std::string get_name() const = 0;\n\n    // Update\n    virtual void update(double dt) = 0;\n\n    // Configuration\n    virtual void set_enabled(bool enabled) = 0;\n    virtual bool is_enabled() const = 0;\n    virtual double get_sample_rate() const = 0;\n    virtual void set_sample_rate(double rate) = 0;\n\n    // Failure injection\n    virtual void inject_failure(FailureMode mode, double magnitude = 1.0) = 0;\n    virtual void clear_failure() = 0;\n    virtual FailureMode get_failure_mode() const = 0;\n\n    // Statistics\n    virtual double get_uptime() const = 0;  // seconds\n    virtual size_t get_sample_count() const = 0;\n};\n\n}  // namespace jaguar::sensors\n</code></pre>"},{"location":"api/sensors/#sensormanager","title":"SensorManager","text":"<pre><code>namespace jaguar::sensors {\n\nclass SensorManager {\npublic:\n    // Add sensor\n    void add_sensor(std::unique_ptr&lt;ISensor&gt; sensor);\n\n    // Get sensor by name\n    ISensor* get_sensor(const std::string&amp; name);\n\n    // Get sensors by type\n    std::vector&lt;ISensor*&gt; get_sensors_by_type(SensorType type);\n\n    // Update all sensors\n    void update_all(double dt);\n\n    // Enable/disable all sensors\n    void enable_all();\n    void disable_all();\n\n    // Get all sensor states\n    std::map&lt;std::string, SensorState&gt; get_all_states() const;\n\n    // Bulk failure injection (for testing)\n    void inject_failure_all(FailureMode mode);\n    void clear_all_failures();\n};\n\n}  // namespace jaguar::sensors\n</code></pre>"},{"location":"api/sensors/#imu-sensor","title":"IMU Sensor","text":""},{"location":"api/sensors/#header_1","title":"Header","text":"<pre><code>#include &lt;jaguar/sensors/imu_sensor.h&gt;\n</code></pre>"},{"location":"api/sensors/#imu-grades","title":"IMU Grades","text":"<pre><code>namespace jaguar::sensors {\n\n// IMU grade levels (based on MIL-STD specifications)\nenum class IMUGrade {\n    Consumer,           // Commercial MEMS\n    Industrial,         // Industrial MEMS\n    Tactical,           // Tactical grade\n    Navigation,         // Navigation grade\n    Strategic           // Strategic/Marine grade\n};\n\n// Typical specifications by grade (1-sigma values)\n//\n// Grade        | Gyro Bias    | Gyro ARW     | Accel Bias  | Accel VRW\n// -------------|--------------|--------------|-------------|-------------\n// Consumer     | 100 deg/h    | 0.5 deg/\u221ah   | 10 mg       | 0.1 m/s/\u221ah\n// Industrial   | 10 deg/h     | 0.1 deg/\u221ah   | 1 mg        | 0.05 m/s/\u221ah\n// Tactical     | 1 deg/h      | 0.01 deg/\u221ah  | 0.1 mg      | 0.01 m/s/\u221ah\n// Navigation   | 0.01 deg/h   | 0.001 deg/\u221ah | 0.01 mg     | 0.003 m/s/\u221ah\n// Strategic    | 0.001 deg/h  | 0.0003 deg/\u221ah| 0.001 mg    | 0.001 m/s/\u221ah\n\n}  // namespace jaguar::sensors\n</code></pre>"},{"location":"api/sensors/#imu-configuration","title":"IMU Configuration","text":"<pre><code>namespace jaguar::sensors {\n\n// Accelerometer configuration\nstruct AccelerometerConfig {\n    Vec3NoiseModel noise_model;\n\n    // Range\n    double max_acceleration = 16.0 * 9.80665;  // m/s^2 (16g)\n\n    // Resolution\n    double resolution = 0.001;      // m/s^2\n\n    // Bandwidth\n    double bandwidth = 100.0;       // Hz\n\n    // Temperature sensitivity\n    double temp_bias_coeff = 0.0;   // (m/s^2)/degC\n    double temp_scale_coeff = 0.0;  // ppm/degC\n};\n\n// Gyroscope configuration\nstruct GyroscopeConfig {\n    Vec3NoiseModel noise_model;\n\n    // Range\n    double max_rate = 2000.0 * M_PI / 180.0;  // rad/s (2000 deg/s)\n\n    // Resolution\n    double resolution = 0.0001;     // rad/s\n\n    // Bandwidth\n    double bandwidth = 100.0;       // Hz\n\n    // Temperature sensitivity\n    double temp_bias_coeff = 0.0;   // (rad/s)/degC\n    double temp_scale_coeff = 0.0;  // ppm/degC\n\n    // G-sensitivity\n    double g_sensitivity = 0.0;     // (rad/s)/g\n};\n\n// Complete IMU configuration\nstruct IMUConfig : SensorConfig {\n    AccelerometerConfig accelerometer;\n    GyroscopeConfig gyroscope;\n    IMUGrade grade = IMUGrade::Tactical;\n\n    // Alignment errors (radians)\n    Vec3 gyro_misalignment = {0, 0, 0};\n    Vec3 accel_misalignment = {0, 0, 0};\n\n    // Internal temperature\n    double operating_temperature = 25.0;  // Celsius\n\n    // Vibration rectification coefficient\n    double vibration_rectification = 0.0;\n\n    // Factory to create grade-appropriate config\n    static IMUConfig from_grade(IMUGrade grade);\n};\n\n}  // namespace jaguar::sensors\n</code></pre>"},{"location":"api/sensors/#imu-measurement","title":"IMU Measurement","text":"<pre><code>namespace jaguar::sensors {\n\n// IMU measurement output\nstruct IMUMeasurement {\n    Vec3 specific_force;            // m/s^2 (body frame)\n    Vec3 angular_velocity;          // rad/s (body frame)\n    std::chrono::nanoseconds timestamp;\n    double temperature;             // Celsius\n    bool valid = true;\n    SensorState state = SensorState::Ready;\n};\n\n}  // namespace jaguar::sensors\n</code></pre>"},{"location":"api/sensors/#imusensor-class","title":"IMUSensor Class","text":"<pre><code>namespace jaguar::sensors {\n\nclass IMUSensor : public ISensor {\npublic:\n    // Initialize with configuration\n    bool initialize(const IMUConfig&amp; config);\n\n    // Set true values (from simulation)\n    void set_true_specific_force(const Vec3&amp; force);\n    void set_true_angular_velocity(const Vec3&amp; rate);\n    void set_true_state(const Vec3&amp; force, const Vec3&amp; rate);\n\n    // Get measurement (with noise applied)\n    IMUMeasurement get_measurement();\n\n    // Get raw (noiseless) measurement\n    IMUMeasurement get_true_measurement() const;\n\n    // Get individual components\n    Vec3 get_accelerometer_output() const;\n    Vec3 get_gyroscope_output() const;\n\n    // Temperature effects\n    void set_temperature(double celsius);\n    double get_temperature() const;\n\n    // Calibration\n    void calibrate(double duration_seconds);\n    bool is_calibrating() const;\n    Vec3 get_accelerometer_bias() const;\n    Vec3 get_gyroscope_bias() const;\n\n    // Allan variance analysis (for validation)\n    struct AllanVarianceResult {\n        std::vector&lt;double&gt; tau;            // Averaging times\n        std::vector&lt;double&gt; adev_gyro_x;    // Allan deviation\n        std::vector&lt;double&gt; adev_gyro_y;\n        std::vector&lt;double&gt; adev_gyro_z;\n        std::vector&lt;double&gt; adev_accel_x;\n        std::vector&lt;double&gt; adev_accel_y;\n        std::vector&lt;double&gt; adev_accel_z;\n    };\n    AllanVarianceResult compute_allan_variance(double duration_seconds,\n                                               double sample_rate);\n\n    // From ISensor\n    bool initialize(const SensorConfig&amp; config) override;\n    void shutdown() override;\n    void reset() override;\n    SensorState get_state() const override;\n    SensorType get_type() const override { return SensorType::IMU; }\n    std::string get_name() const override;\n    void update(double dt) override;\n    void set_enabled(bool enabled) override;\n    bool is_enabled() const override;\n    double get_sample_rate() const override;\n    void set_sample_rate(double rate) override;\n    void inject_failure(FailureMode mode, double magnitude) override;\n    void clear_failure() override;\n    FailureMode get_failure_mode() const override;\n    double get_uptime() const override;\n    size_t get_sample_count() const override;\n\nprivate:\n    // Internal noise generation\n    Vec3 apply_accelerometer_noise(const Vec3&amp; true_value);\n    Vec3 apply_gyroscope_noise(const Vec3&amp; true_value);\n    double generate_white_noise(double std_dev);\n    double generate_bias_instability(double&amp; state, const BiasInstabilityParams&amp; params, double dt);\n    double generate_random_walk(double&amp; state, const RandomWalkParams&amp; params, double dt);\n};\n\n// Factory functions\nstd::unique_ptr&lt;IMUSensor&gt; create_imu_sensor(const IMUConfig&amp; config);\nstd::unique_ptr&lt;IMUSensor&gt; create_consumer_imu();\nstd::unique_ptr&lt;IMUSensor&gt; create_industrial_imu();\nstd::unique_ptr&lt;IMUSensor&gt; create_tactical_imu();\nstd::unique_ptr&lt;IMUSensor&gt; create_navigation_imu();\nstd::unique_ptr&lt;IMUSensor&gt; create_strategic_imu();\n\n}  // namespace jaguar::sensors\n</code></pre>"},{"location":"api/sensors/#usage-examples","title":"Usage Examples","text":""},{"location":"api/sensors/#basic-imu-simulation","title":"Basic IMU Simulation","text":"<pre><code>#include &lt;jaguar/sensors/imu_sensor.h&gt;\n\nusing namespace jaguar::sensors;\n\n// Create tactical-grade IMU\nauto imu = create_tactical_imu();\n\n// Or configure manually\nIMUConfig config = IMUConfig::from_grade(IMUGrade::Tactical);\nconfig.name = \"Main_IMU\";\nconfig.sample_rate = 100.0;  // 100 Hz\n\n// Customize accelerometer noise\nconfig.accelerometer.noise_model.x.white_noise.power_spectral_density = 1e-6;\nconfig.accelerometer.noise_model.x.bias_instability.bias_instability = 0.001 * 9.80665;\n\nauto custom_imu = create_imu_sensor(config);\ncustom_imu-&gt;initialize(config);\n\n// Simulation loop\nwhile (running) {\n    // Get true values from simulation\n    auto state = engine.get_entity_state(aircraft);\n\n    // Compute specific force (acceleration - gravity in body frame)\n    Vec3 gravity_body = rotate_to_body(Vec3{0, 0, 9.80665}, state.orientation);\n    Vec3 specific_force = state.acceleration - gravity_body;\n\n    // Set true values\n    imu-&gt;set_true_state(specific_force, state.angular_velocity);\n\n    // Update sensor (applies noise)\n    imu-&gt;update(dt);\n\n    // Get noisy measurement\n    auto measurement = imu-&gt;get_measurement();\n\n    if (measurement.valid) {\n        // Use in navigation filter\n        navigation_filter.process_imu(\n            measurement.specific_force,\n            measurement.angular_velocity,\n            measurement.timestamp\n        );\n    }\n\n    engine.step(dt);\n}\n</code></pre>"},{"location":"api/sensors/#multi-sensor-fusion","title":"Multi-Sensor Fusion","text":"<pre><code>#include &lt;jaguar/sensors/imu_sensor.h&gt;\n#include &lt;jaguar/sensors/sensor.h&gt;\n\nusing namespace jaguar::sensors;\n\n// Create sensor manager\nSensorManager sensor_mgr;\n\n// Add multiple IMUs (redundancy)\nauto imu1 = create_navigation_imu();\nimu1-&gt;initialize(make_config(\"IMU_1\", Vec3{0.5, 0, 0}));\n\nauto imu2 = create_navigation_imu();\nimu2-&gt;initialize(make_config(\"IMU_2\", Vec3{-0.5, 0, 0}));\n\nauto imu3 = create_navigation_imu();\nimu3-&gt;initialize(make_config(\"IMU_3\", Vec3{0, 0.5, 0}));\n\nsensor_mgr.add_sensor(std::move(imu1));\nsensor_mgr.add_sensor(std::move(imu2));\nsensor_mgr.add_sensor(std::move(imu3));\n\n// Simulation loop\nwhile (running) {\n    // Update all sensors\n    sensor_mgr.update_all(dt);\n\n    // Get all IMU sensors\n    auto imus = sensor_mgr.get_sensors_by_type(SensorType::IMU);\n\n    std::vector&lt;IMUMeasurement&gt; measurements;\n    for (auto* sensor : imus) {\n        auto* imu = static_cast&lt;IMUSensor*&gt;(sensor);\n        if (imu-&gt;get_state() == SensorState::Ready) {\n            measurements.push_back(imu-&gt;get_measurement());\n        }\n    }\n\n    // Sensor fusion\n    if (measurements.size() &gt;= 2) {\n        auto fused = fuse_imu_measurements(measurements);\n        navigation_filter.process_fused_imu(fused);\n    }\n\n    engine.step(dt);\n}\n</code></pre>"},{"location":"api/sensors/#failure-injection-testing","title":"Failure Injection Testing","text":"<pre><code>#include &lt;jaguar/sensors/imu_sensor.h&gt;\n\nusing namespace jaguar::sensors;\n\n// Create IMU for testing\nauto imu = create_tactical_imu();\n\n// Normal operation\nfor (int i = 0; i &lt; 1000; ++i) {\n    imu-&gt;update(dt);\n    auto m = imu-&gt;get_measurement();\n    log_measurement(m);\n}\n\n// Inject bias failure\nstd::cout &lt;&lt; \"Injecting bias failure...\\n\";\nimu-&gt;inject_failure(FailureMode::Bias, 0.01);  // 0.01 rad/s bias\n\nfor (int i = 0; i &lt; 1000; ++i) {\n    imu-&gt;update(dt);\n    auto m = imu-&gt;get_measurement();\n    log_measurement(m);\n\n    // Navigation filter should detect degraded performance\n}\n\n// Inject stuck failure\nstd::cout &lt;&lt; \"Injecting stuck failure...\\n\";\nimu-&gt;inject_failure(FailureMode::Stuck);\n\nfor (int i = 0; i &lt; 100; ++i) {\n    imu-&gt;update(dt);\n    auto m = imu-&gt;get_measurement();\n\n    // Output will be frozen at last valid value\n    assert(m.angular_velocity == last_valid_rate);\n}\n\n// Clear failures\nimu-&gt;clear_failure();\n\n// Verify recovery\nfor (int i = 0; i &lt; 100; ++i) {\n    imu-&gt;update(dt);\n    auto m = imu-&gt;get_measurement();\n    assert(m.valid);\n}\n</code></pre>"},{"location":"api/sensors/#allan-variance-analysis","title":"Allan Variance Analysis","text":"<pre><code>#include &lt;jaguar/sensors/imu_sensor.h&gt;\n#include &lt;fstream&gt;\n\nusing namespace jaguar::sensors;\n\n// Create IMU\nIMUConfig config = IMUConfig::from_grade(IMUGrade::Navigation);\nauto imu = create_imu_sensor(config);\nimu-&gt;initialize(config);\n\n// Set constant input (for Allan variance test)\nimu-&gt;set_true_state(Vec3{0, 0, 9.80665}, Vec3{0, 0, 0});\n\n// Collect data and compute Allan variance\ndouble test_duration = 3600.0;  // 1 hour\ndouble sample_rate = 100.0;     // 100 Hz\n\nstd::cout &lt;&lt; \"Running Allan variance test for \" &lt;&lt; test_duration &lt;&lt; \" seconds...\\n\";\n\nauto result = imu-&gt;compute_allan_variance(test_duration, sample_rate);\n\n// Output results\nstd::ofstream csv(\"allan_variance.csv\");\ncsv &lt;&lt; \"tau,adev_gyro_x,adev_gyro_y,adev_gyro_z,\"\n    &lt;&lt; \"adev_accel_x,adev_accel_y,adev_accel_z\\n\";\n\nfor (size_t i = 0; i &lt; result.tau.size(); ++i) {\n    csv &lt;&lt; result.tau[i] &lt;&lt; \",\"\n        &lt;&lt; result.adev_gyro_x[i] &lt;&lt; \",\"\n        &lt;&lt; result.adev_gyro_y[i] &lt;&lt; \",\"\n        &lt;&lt; result.adev_gyro_z[i] &lt;&lt; \",\"\n        &lt;&lt; result.adev_accel_x[i] &lt;&lt; \",\"\n        &lt;&lt; result.adev_accel_y[i] &lt;&lt; \",\"\n        &lt;&lt; result.adev_accel_z[i] &lt;&lt; \"\\n\";\n}\n\n// Verify noise parameters match specification\ndouble expected_arw = 0.001 * M_PI / 180.0;  // 0.001 deg/sqrt(hr)\ndouble measured_arw = result.adev_gyro_x[0] * std::sqrt(result.tau[0]);\n\nstd::cout &lt;&lt; \"Expected ARW: \" &lt;&lt; expected_arw &lt;&lt; \" rad/sqrt(s)\\n\";\nstd::cout &lt;&lt; \"Measured ARW: \" &lt;&lt; measured_arw &lt;&lt; \" rad/sqrt(s)\\n\";\nstd::cout &lt;&lt; \"Error: \" &lt;&lt; std::abs(measured_arw - expected_arw) / expected_arw * 100 &lt;&lt; \"%\\n\";\n</code></pre>"},{"location":"api/sensors/#insgps-integration","title":"INS/GPS Integration","text":"<pre><code>#include &lt;jaguar/sensors/imu_sensor.h&gt;\n\nusing namespace jaguar::sensors;\n\nclass INSGPSNavigator {\n    std::unique_ptr&lt;IMUSensor&gt; imu_;\n\n    // Navigation state\n    Vec3 position_;\n    Vec3 velocity_;\n    Quaternion attitude_;\n\n    // Kalman filter state\n    Eigen::VectorXd x_;  // 15-state INS error model\n    Eigen::MatrixXd P_;  // Covariance\n\npublic:\n    void initialize() {\n        // Create navigation-grade IMU\n        imu_ = create_navigation_imu();\n\n        // Initialize Kalman filter\n        x_ = Eigen::VectorXd::Zero(15);  // pos, vel, att, gyro_bias, accel_bias\n        P_ = Eigen::MatrixXd::Identity(15, 15);\n\n        // Set initial uncertainties based on IMU specifications\n        auto config = IMUConfig::from_grade(IMUGrade::Navigation);\n        double gyro_bias_std = config.gyroscope.noise_model.x.bias_instability.bias_instability;\n        double accel_bias_std = config.accelerometer.noise_model.x.bias_instability.bias_instability;\n\n        P_.block&lt;3,3&gt;(9, 9) = Eigen::Matrix3d::Identity() * gyro_bias_std * gyro_bias_std;\n        P_.block&lt;3,3&gt;(12, 12) = Eigen::Matrix3d::Identity() * accel_bias_std * accel_bias_std;\n    }\n\n    void process_imu(double dt) {\n        auto meas = imu_-&gt;get_measurement();\n\n        // Remove estimated biases\n        Vec3 corrected_gyro = meas.angular_velocity - get_gyro_bias_estimate();\n        Vec3 corrected_accel = meas.specific_force - get_accel_bias_estimate();\n\n        // Mechanization: integrate navigation equations\n        attitude_ = integrate_attitude(attitude_, corrected_gyro, dt);\n        Vec3 accel_nav = rotate_to_nav(corrected_accel, attitude_);\n        velocity_ = velocity_ + (accel_nav + gravity_) * dt;\n        position_ = position_ + velocity_ * dt;\n\n        // Propagate covariance\n        propagate_covariance(dt, corrected_gyro, corrected_accel);\n    }\n\n    void process_gps(const Vec3&amp; gps_position, const Vec3&amp; gps_velocity) {\n        // Kalman update with GPS measurement\n        Eigen::VectorXd z(6);\n        z &lt;&lt; (position_.x - gps_position.x),\n             (position_.y - gps_position.y),\n             (position_.z - gps_position.z),\n             (velocity_.x - gps_velocity.x),\n             (velocity_.y - gps_velocity.y),\n             (velocity_.z - gps_velocity.z);\n\n        // Update state and covariance\n        kalman_update(z);\n\n        // Apply corrections\n        apply_corrections();\n    }\n\n    Vec3 get_position() const { return position_; }\n    Vec3 get_velocity() const { return velocity_; }\n    Quaternion get_attitude() const { return attitude_; }\n\nprivate:\n    Vec3 get_gyro_bias_estimate() const {\n        return Vec3{x_(9), x_(10), x_(11)};\n    }\n\n    Vec3 get_accel_bias_estimate() const {\n        return Vec3{x_(12), x_(13), x_(14)};\n    }\n\n    // ... Kalman filter implementation ...\n};\n</code></pre>"},{"location":"api/sensors/#see-also","title":"See Also","text":"<ul> <li>Architecture - System architecture overview</li> <li>Air Domain - Aircraft-specific sensors</li> <li>Configuration - Engine configuration</li> </ul>"},{"location":"api/space/","title":"Space Domain API Reference","text":"<p>Orbital mechanics, propagators, gravity models, and spacecraft APIs.</p> <p>Header: <code>jaguar/domain/space.h</code></p>"},{"location":"api/space/#orbitalelements","title":"OrbitalElements","text":"<p>Classical Keplerian orbital elements.</p> <pre><code>struct OrbitalElements {\n    Real semi_major_axis{0.0};  // a (m)\n    Real eccentricity{0.0};     // e (0 &lt;= e &lt; 1 for ellipse)\n    Real inclination{0.0};      // i (rad)\n    Real raan{0.0};             // \u03a9 - Right Ascension of Ascending Node (rad)\n    Real arg_periapsis{0.0};    // \u03c9 - Argument of Periapsis (rad)\n    Real mean_anomaly{0.0};     // M (rad)\n    Real epoch{0.0};            // Epoch time (Julian date)\n\n    // Conversion methods\n    static OrbitalElements from_cartesian(const Vec3&amp; position,\n                                          const Vec3&amp; velocity,\n                                          Real mu = constants::EARTH_MU);\n    void to_cartesian(Vec3&amp; position, Vec3&amp; velocity,\n                      Real mu = constants::EARTH_MU) const;\n\n    // Derived quantities\n    Real period() const;              // Orbital period (s)\n    Real apoapsis() const;            // Apoapsis radius (m)\n    Real periapsis() const;           // Periapsis radius (m)\n    Real apoapsis_altitude() const;   // Above Earth surface (m)\n    Real periapsis_altitude() const;  // Above Earth surface (m)\n    Real mean_motion() const;         // n (rad/s)\n    Real specific_energy() const;     // J/kg\n    Real specific_angular_momentum() const;  // m\u00b2/s\n\n    // Anomaly conversions\n    Real eccentric_anomaly() const;   // E (rad)\n    Real true_anomaly() const;        // \u03bd (rad)\n\n    // Orbit classification\n    OrbitType classify() const;\n};\n\nenum class OrbitType {\n    LEO,      // Low Earth Orbit (&lt; 2000 km)\n    MEO,      // Medium Earth Orbit (2000-35786 km)\n    GEO,      // Geostationary (35786 km)\n    HEO,      // Highly Elliptical Orbit\n    Escape,   // e &gt;= 1\n    Invalid\n};\n</code></pre>"},{"location":"api/space/#example","title":"Example","text":"<pre><code>// Create ISS-like orbit\ndomain::space::OrbitalElements orbit;\norbit.semi_major_axis = constants::EARTH_RADIUS + 420000.0;  // 420 km\norbit.eccentricity = 0.0001;\norbit.inclination = 51.6 * DEG_TO_RAD;\norbit.raan = 0.0;\norbit.arg_periapsis = 0.0;\norbit.mean_anomaly = 0.0;\n\n// Get orbital characteristics\nstd::cout &lt;&lt; \"Period: \" &lt;&lt; orbit.period() / 60.0 &lt;&lt; \" minutes\\n\";\nstd::cout &lt;&lt; \"Type: \" &lt;&lt; (orbit.classify() == OrbitType::LEO ? \"LEO\" : \"other\") &lt;&lt; \"\\n\";\n\n// Convert to state vectors\nVec3 position, velocity;\norbit.to_cartesian(position, velocity);\n\n// Convert from state vectors\nauto elements = OrbitalElements::from_cartesian(position, velocity);\n</code></pre>"},{"location":"api/space/#tle","title":"TLE","text":"<p>Two-Line Element set parsing.</p> <pre><code>struct TLE {\n    std::string name;\n    int catalog_number{0};\n    char classification{'U'};\n    std::string intl_designator;\n    int epoch_year{0};\n    Real epoch_day{0.0};\n    Real mean_motion_dot{0.0};      // rev/day\u00b2\n    Real mean_motion_ddot{0.0};     // rev/day\u00b3\n    Real bstar{0.0};                // drag term\n    Real inclination{0.0};          // rad\n    Real raan{0.0};                 // rad\n    Real eccentricity{0.0};\n    Real arg_perigee{0.0};          // rad\n    Real mean_anomaly{0.0};         // rad\n    Real mean_motion{0.0};          // rev/day\n    int revolution_number{0};\n\n    // Parse TLE lines\n    bool parse(const std::string&amp; line1, const std::string&amp; line2);\n    bool parse(const std::string&amp; name,\n               const std::string&amp; line1, const std::string&amp; line2);\n\n    // Convert to classical elements\n    OrbitalElements to_elements() const;\n\n    // Get epoch as Julian date\n    Real epoch_jd() const;\n};\n</code></pre>"},{"location":"api/space/#example_1","title":"Example","text":"<pre><code>// Parse ISS TLE\nstd::string line1 = \"1 25544U 98067A   21275.52422453  .00001234  00000-0  28888-4 0  9990\";\nstd::string line2 = \"2 25544  51.6442  27.4345 0003542 211.7212 148.3510 15.48919914305213\";\n\ndomain::space::TLE tle;\nif (tle.parse(\"ISS (ZARYA)\", line1, line2)) {\n    std::cout &lt;&lt; \"Satellite: \" &lt;&lt; tle.name &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Inclination: \" &lt;&lt; tle.inclination * RAD_TO_DEG &lt;&lt; \" deg\\n\";\n    std::cout &lt;&lt; \"Period: \" &lt;&lt; 1440.0 / tle.mean_motion &lt;&lt; \" minutes\\n\";\n}\n</code></pre>"},{"location":"api/space/#sgp4propagator","title":"SGP4Propagator","text":"<p>Simplified General Perturbations propagator.</p> <pre><code>class SGP4Propagator {\npublic:\n    // Initialize from TLE\n    bool initialize(const TLE&amp; tle);\n\n    // Propagate to time since epoch\n    void propagate(Real minutes_since_epoch,\n                   Vec3&amp; position_km,    // TEME frame\n                   Vec3&amp; velocity_km_s) const;\n\n    // Propagate to Julian date\n    void propagate_to_jd(Real jd,\n                         Vec3&amp; position_km,\n                         Vec3&amp; velocity_km_s) const;\n\n    // Get epoch\n    Real get_epoch_jd() const;\n\n    // Error status\n    int get_error_code() const;\n    std::string get_error_message() const;\n};\n</code></pre>"},{"location":"api/space/#example_2","title":"Example","text":"<pre><code>domain::space::SGP4Propagator sgp4;\n\n// Initialize\nif (!sgp4.initialize(tle)) {\n    std::cerr &lt;&lt; \"SGP4 error: \" &lt;&lt; sgp4.get_error_message() &lt;&lt; \"\\n\";\n    return;\n}\n\n// Propagate for 24 hours\nfor (Real minutes = 0; minutes &lt; 24 * 60; minutes += 1.0) {\n    Vec3 pos_km, vel_kms;\n    sgp4.propagate(minutes, pos_km, vel_kms);\n\n    // Convert to SI\n    Vec3 pos_m = pos_km * 1000.0;\n    Vec3 vel_ms = vel_kms * 1000.0;\n\n    // Convert TEME to ECEF\n    Real jd = sgp4.get_epoch_jd() + minutes / 1440.0;\n    Vec3 pos_ecef = transforms::teme_to_ecef(pos_m, jd);\n\n    // Get geodetic position\n    Real lat, lon, alt;\n    transforms::ecef_to_geodetic(pos_ecef, lat, lon, alt);\n\n    std::cout &lt;&lt; \"Lat: \" &lt;&lt; lat * RAD_TO_DEG\n              &lt;&lt; \", Lon: \" &lt;&lt; lon * RAD_TO_DEG\n              &lt;&lt; \", Alt: \" &lt;&lt; alt / 1000.0 &lt;&lt; \" km\\n\";\n}\n</code></pre>"},{"location":"api/space/#gravitymodel","title":"GravityModel","text":"<p>Earth gravity with perturbations.</p> <pre><code>enum class GravityFidelity {\n    PointMass,  // Simple 1/r\u00b2 gravity\n    J2,         // Include J2 (oblateness)\n    J4,         // Include J2 through J4\n    Full        // Full geopotential (EGM96)\n};\n\nclass GravityModel {\npublic:\n    // Configuration\n    void set_fidelity(GravityFidelity fidelity);\n    void set_fidelity(int degree);  // For full model\n    void set_central_body(Real mu, Real radius);\n\n    // Load gravity field\n    bool load_egm96();\n    bool load_from_file(const std::string&amp; path);\n\n    // Compute acceleration\n    Vec3 compute_acceleration(const Vec3&amp; position_ecef) const;\n\n    // IForceGenerator interface\n    void compute_forces(const physics::EntityState&amp; state,\n                        const environment::Environment&amp; env,\n                        Real dt,\n                        physics::EntityForces&amp; forces);\n\n    // Get potential\n    Real get_potential(const Vec3&amp; position_ecef) const;\n};\n</code></pre>"},{"location":"api/space/#example_3","title":"Example","text":"<pre><code>domain::space::GravityModel gravity;\n\n// Simple J2 model\ngravity.set_fidelity(GravityFidelity::J2);\n\n// Or higher fidelity\ngravity.set_fidelity(GravityFidelity::Full);\ngravity.load_egm96();\n\n// Compute acceleration\nVec3 position_eci = /* satellite position */;\nVec3 accel = gravity.compute_acceleration(position_eci);\n\n// Apply to satellite\nphysics::EntityForces forces;\nforces.add_force(accel * satellite_mass);\n</code></pre>"},{"location":"api/space/#atmosphericdragmodel","title":"AtmosphericDragModel","text":"<p>Atmospheric drag for LEO satellites.</p> <pre><code>class AtmosphericDragModel {\npublic:\n    // Configuration\n    void set_drag_coefficient(Real cd);  // Typically 2.0-2.5\n    void set_area(Real area);            // Cross-section (m\u00b2)\n    void set_mass(Real mass);            // For A/m ratio\n\n    // Compute forces\n    void compute_forces(const physics::EntityState&amp; state,\n                        const environment::Environment&amp; env,\n                        Real dt,\n                        physics::EntityForces&amp; forces);\n\n    // Queries\n    Real get_drag_force() const;         // N\n    Real get_density() const;            // kg/m\u00b3 (last computed)\n    Real get_ballistic_coefficient() const;  // kg/m\u00b2\n};\n</code></pre>"},{"location":"api/space/#jb08atmospheremodel","title":"JB08AtmosphereModel","text":"<p>Jacchia-Bowman 2008 upper atmosphere model.</p> <pre><code>class JB08AtmosphereModel {\npublic:\n    // Space weather inputs\n    void set_space_weather(Real f107,      // 10.7 cm flux\n                           Real f107_avg,   // 81-day average\n                           Real ap);        // Geomagnetic index\n\n    // Load space weather from file\n    bool load_space_weather(const std::string&amp; path);\n\n    // Query density\n    Real get_density(const Vec3&amp; position_ecef, Real jd) const;\n\n    // Query temperature\n    Real get_temperature(const Vec3&amp; position_ecef, Real jd) const;\n};\n</code></pre>"},{"location":"api/space/#example_4","title":"Example","text":"<pre><code>domain::space::JB08AtmosphereModel atmosphere;\n\n// Set space weather (moderate activity)\natmosphere.set_space_weather(150.0,   // F10.7\n                              145.0,   // F10.7 avg\n                              15.0);   // Ap\n\n// Get density at satellite\nReal rho = atmosphere.get_density(pos_ecef, jd);\n\n// Configure drag model\ndomain::space::AtmosphericDragModel drag;\ndrag.set_drag_coefficient(2.2);\ndrag.set_area(10.0);  // m\u00b2\ndrag.set_mass(1000.0);  // kg\n\n// Compute drag\nphysics::EntityForces forces;\ndrag.compute_forces(state, env, dt, forces);\n</code></pre>"},{"location":"api/space/#solarradiationpressure","title":"SolarRadiationPressure","text":"<p>Solar radiation pressure model.</p> <pre><code>class SRPModel {\npublic:\n    // Configuration\n    void set_area(Real area);           // m\u00b2\n    void set_reflectivity(Real cr);     // 0=absorb, 1=reflect\n    void set_mass(Real mass);           // kg\n\n    // Shadow calculation\n    enum class ShadowModel { None, Cylindrical, Conical };\n    void set_shadow_model(ShadowModel model);\n\n    // Compute forces\n    void compute_forces(const physics::EntityState&amp; state,\n                        const environment::Environment&amp; env,\n                        Real dt,\n                        physics::EntityForces&amp; forces);\n\n    // Queries\n    bool in_shadow() const;\n    Real get_shadow_factor() const;  // 0=full shadow, 1=full sun\n};\n</code></pre>"},{"location":"api/space/#coordinate-transforms-space","title":"Coordinate Transforms (Space)","text":"<pre><code>namespace transforms {\n    // TEME &lt;-&gt; ECI (J2000)\n    Vec3 teme_to_eci(const Vec3&amp; teme, Real jd);\n    Vec3 eci_to_teme(const Vec3&amp; eci, Real jd);\n\n    // TEME &lt;-&gt; ECEF\n    Vec3 teme_to_ecef(const Vec3&amp; teme, Real jd);\n    Vec3 ecef_to_teme(const Vec3&amp; ecef, Real jd);\n\n    // Time systems\n    Real utc_to_tt(Real jd_utc);\n    Real tt_to_utc(Real jd_tt);\n    Real greenwich_sidereal_time(Real jd_ut1);\n\n    // Julian date\n    Real julian_date(int year, int month, int day,\n                     int hour, int min, Real sec);\n    void calendar_date(Real jd, int&amp; year, int&amp; month, int&amp; day,\n                       int&amp; hour, int&amp; min, Real&amp; sec);\n}\n</code></pre>"},{"location":"api/space/#see-also","title":"See Also","text":"<ul> <li>Physics API - Force generator interfaces</li> <li>Core API - Coordinate transforms</li> <li>Space Domain Concepts - Domain overview</li> <li>Space Domain Tutorial - Step-by-step guide</li> </ul>"},{"location":"api/thread/","title":"Digital Thread API Reference","text":"<p>Digital Thread module (<code>jaguar_thread</code>) provides lifecycle tracking, history management, and predictive degradation modeling for digital twin applications.</p>"},{"location":"api/thread/#overview","title":"Overview","text":"<p>The Digital Thread module enables: - History Store: State snapshots, delta tracking, and time-travel debugging - Degradation Model: Physics-based failure prediction and maintenance scheduling</p>"},{"location":"api/thread/#history-store","title":"History Store","text":""},{"location":"api/thread/#header","title":"Header","text":"<pre><code>#include &lt;jaguar/thread/history_store.h&gt;\n</code></pre>"},{"location":"api/thread/#core-types","title":"Core Types","text":"<pre><code>namespace jaguar::thread {\n\n// Snapshot types\nenum class SnapshotType {\n    Full,           // Complete state capture\n    Delta,          // Changes since last snapshot\n    Checkpoint,     // Recoverable checkpoint\n    Incremental     // Streaming incremental updates\n};\n\n// Export formats\nenum class ExportFormat {\n    Parquet,        // Apache Parquet (columnar)\n    CSV,            // Comma-separated values\n    JSON,           // JSON format\n    Binary          // Native binary format\n};\n\n// State snapshot\nstruct StateSnapshot {\n    uint64_t snapshot_id;\n    uint64_t version;\n    SnapshotType type;\n    std::chrono::system_clock::time_point timestamp;\n    std::chrono::nanoseconds simulation_time;\n    std::vector&lt;uint8_t&gt; state_data;\n    std::vector&lt;uint8_t&gt; metadata;\n    size_t compressed_size;\n    size_t uncompressed_size;\n    std::string checksum;\n};\n\n// History query\nstruct HistoryQuery {\n    std::optional&lt;uint64_t&gt; entity_id;\n    std::optional&lt;std::chrono::system_clock::time_point&gt; start_time;\n    std::optional&lt;std::chrono::system_clock::time_point&gt; end_time;\n    std::optional&lt;std::chrono::nanoseconds&gt; sim_time_start;\n    std::optional&lt;std::chrono::nanoseconds&gt; sim_time_end;\n    std::optional&lt;SnapshotType&gt; snapshot_type;\n    size_t limit = 1000;\n    size_t offset = 0;\n    bool include_data = true;\n    bool ascending = true;\n};\n\n// Retention policy\nstruct RetentionPolicy {\n    std::chrono::hours max_age{24 * 30};          // 30 days default\n    size_t max_snapshots = 10000;\n    size_t max_storage_bytes = 10ULL * 1024 * 1024 * 1024;  // 10 GB\n    bool auto_compact = true;\n    std::chrono::hours compact_interval{24};\n    std::vector&lt;SnapshotType&gt; preserve_types = {SnapshotType::Checkpoint};\n};\n\n// History result\nstruct HistoryResult {\n    bool success;\n    std::string error_message;\n    uint64_t snapshot_id;\n    size_t snapshots_affected;\n    std::chrono::microseconds duration;\n};\n\n// Configuration\nstruct HistoryStoreConfig {\n    std::string storage_path = \"./history\";\n    SnapshotType default_snapshot_type = SnapshotType::Delta;\n    std::chrono::milliseconds snapshot_interval{1000};\n    bool compression_enabled = true;\n    int compression_level = 6;\n    bool async_writes = true;\n    size_t write_buffer_size = 1024 * 1024;  // 1 MB\n    RetentionPolicy retention;\n};\n\n}  // namespace jaguar::thread\n</code></pre>"},{"location":"api/thread/#historystore-class","title":"HistoryStore Class","text":"<pre><code>class HistoryStore {\npublic:\n    // Initialize history store\n    HistoryResult initialize(const HistoryStoreConfig&amp; config);\n\n    // Shutdown\n    void shutdown();\n\n    // Capture current state\n    HistoryResult capture_snapshot(const void* state_data, size_t size,\n                                   SnapshotType type = SnapshotType::Delta);\n\n    // Capture entity-specific state\n    HistoryResult capture_entity_snapshot(uint64_t entity_id,\n                                          const void* state_data, size_t size);\n\n    // Retrieve snapshot by ID\n    std::optional&lt;StateSnapshot&gt; get_snapshot(uint64_t snapshot_id) const;\n\n    // Query snapshots\n    std::vector&lt;StateSnapshot&gt; query_snapshots(const HistoryQuery&amp; query) const;\n\n    // Get latest snapshot\n    std::optional&lt;StateSnapshot&gt; get_latest_snapshot() const;\n\n    // Get snapshot at simulation time\n    std::optional&lt;StateSnapshot&gt; get_snapshot_at_time(\n        std::chrono::nanoseconds sim_time) const;\n\n    // Get snapshots in time range\n    std::vector&lt;StateSnapshot&gt; get_snapshots_in_range(\n        std::chrono::nanoseconds start,\n        std::chrono::nanoseconds end) const;\n\n    // Restore from snapshot\n    HistoryResult restore_snapshot(uint64_t snapshot_id);\n\n    // Create checkpoint (guaranteed recoverable)\n    HistoryResult create_checkpoint(const std::string&amp; name = \"\");\n\n    // List checkpoints\n    std::vector&lt;StateSnapshot&gt; list_checkpoints() const;\n\n    // Delete snapshot\n    HistoryResult delete_snapshot(uint64_t snapshot_id);\n\n    // Compact history (apply retention policy)\n    HistoryResult compact();\n\n    // Export history\n    HistoryResult export_history(const std::string&amp; output_path,\n                                 ExportFormat format,\n                                 const HistoryQuery&amp; query = {});\n\n    // Import history\n    HistoryResult import_history(const std::string&amp; input_path);\n\n    // Get storage statistics\n    struct StorageStats {\n        size_t total_snapshots;\n        size_t total_bytes;\n        size_t compressed_bytes;\n        double compression_ratio;\n        std::chrono::system_clock::time_point oldest_snapshot;\n        std::chrono::system_clock::time_point newest_snapshot;\n        size_t checkpoints_count;\n    };\n    StorageStats get_storage_stats() const;\n};\n\n// Factory functions\nstd::unique_ptr&lt;HistoryStore&gt; create_history_store(\n    const HistoryStoreConfig&amp; config);\nstd::unique_ptr&lt;IHistoryBackend&gt; create_memory_backend();\nstd::unique_ptr&lt;IHistoryBackend&gt; create_file_backend(const std::string&amp; path);\nstd::unique_ptr&lt;IHistoryExporter&gt; create_parquet_exporter();\nstd::unique_ptr&lt;IHistoryExporter&gt; create_csv_exporter();\n</code></pre>"},{"location":"api/thread/#degradation-model","title":"Degradation Model","text":""},{"location":"api/thread/#header_1","title":"Header","text":"<pre><code>#include &lt;jaguar/thread/degradation_model.h&gt;\n</code></pre>"},{"location":"api/thread/#core-types_1","title":"Core Types","text":"<pre><code>namespace jaguar::thread {\n\n// Degradation mechanisms\nenum class DegradationType {\n    Wear,           // Mechanical wear\n    Fatigue,        // Cyclic fatigue\n    Corrosion,      // Environmental corrosion\n    Thermal,        // Thermal degradation\n    Electrical,     // Electrical aging\n    Chemical,       // Chemical degradation\n    Radiation,      // Radiation damage\n    Creep,          // Material creep\n    Erosion         // Surface erosion\n};\n\n// Component types\nenum class ComponentType {\n    Structural,     // Airframe, hull, chassis\n    Propulsion,     // Engine, motor, thruster\n    Avionics,       // Electronics, sensors\n    Hydraulic,      // Hydraulic systems\n    Electrical,     // Electrical systems\n    Fuel,           // Fuel systems\n    Landing,        // Landing gear, wheels\n    Control,        // Control surfaces, actuators\n    Environmental,  // HVAC, pressurization\n    Weapon          // Weapon systems\n};\n\n// Health status\nenum class HealthStatus {\n    Excellent,      // 90-100% health\n    Good,           // 70-90% health\n    Fair,           // 50-70% health\n    Poor,           // 30-50% health\n    Critical,       // 10-30% health\n    Failed          // 0-10% health\n};\n\n// Maintenance action types\nenum class MaintenanceAction {\n    Inspect,        // Visual/instrument inspection\n    Service,        // Routine service\n    Repair,         // Component repair\n    Replace,        // Component replacement\n    Overhaul,       // Major overhaul\n    Condemn         // Remove from service\n};\n\n// Component health\nstruct ComponentHealth {\n    std::string component_id;\n    std::string component_name;\n    ComponentType type;\n    HealthStatus status;\n    double health_percentage;       // 0.0 - 100.0\n    double degradation_rate;        // % per hour\n    std::chrono::hours operating_hours;\n    std::chrono::hours hours_since_maintenance;\n    size_t cycle_count;\n    std::vector&lt;DegradationType&gt; active_degradation_modes;\n};\n\n// Operating conditions\nstruct OperatingConditions {\n    double temperature_celsius;\n    double humidity_percent;\n    double altitude_meters;\n    double speed_mps;\n    double load_factor;             // g-force\n    double vibration_level;         // m/s^2\n    bool is_combat;\n    bool is_extreme_environment;\n    std::chrono::hours continuous_operation;\n};\n\n// Wear factor\nstruct WearFactor {\n    DegradationType type;\n    double base_rate;               // Base degradation rate\n    double environment_multiplier;\n    double load_multiplier;\n    double cumulative_damage;\n};\n\n// Failure prediction\nstruct FailurePrediction {\n    std::string component_id;\n    double failure_probability;     // 0.0 - 1.0\n    std::chrono::hours time_to_failure_mean;\n    std::chrono::hours time_to_failure_std;\n    std::chrono::hours time_to_failure_p10;   // 10th percentile\n    std::chrono::hours time_to_failure_p90;   // 90th percentile\n    DegradationType likely_failure_mode;\n    double confidence;              // 0.0 - 1.0\n};\n\n// Maintenance recommendation\nstruct MaintenanceRecommendation {\n    std::string component_id;\n    MaintenanceAction action;\n    std::string description;\n    std::chrono::hours recommended_within;\n    double urgency;                 // 0.0 - 1.0\n    double estimated_cost;\n    double estimated_downtime_hours;\n    double risk_if_deferred;        // 0.0 - 1.0\n    std::vector&lt;std::string&gt; required_parts;\n    std::vector&lt;std::string&gt; required_tools;\n};\n\n// Degradation result\nstruct DegradationResult {\n    bool success;\n    std::string error_message;\n    ComponentHealth health;\n    std::chrono::microseconds computation_time;\n};\n\n// Configuration\nstruct DegradationConfig {\n    bool enable_wear = true;\n    bool enable_fatigue = true;\n    bool enable_corrosion = true;\n    bool enable_thermal = true;\n    double base_wear_rate = 0.001;          // % per hour\n    double fatigue_exponent = 3.0;          // Paris law exponent\n    double corrosion_rate_base = 0.0001;    // % per hour\n    double thermal_activation_energy = 50000;  // J/mol\n    std::chrono::hours prediction_horizon{1000};\n    size_t monte_carlo_samples = 10000;\n};\n\n}  // namespace jaguar::thread\n</code></pre>"},{"location":"api/thread/#degradationmodel-class","title":"DegradationModel Class","text":"<pre><code>class DegradationModel {\npublic:\n    // Initialize degradation model\n    DegradationResult initialize(const DegradationConfig&amp; config);\n\n    // Shutdown\n    void shutdown();\n\n    // Register component\n    DegradationResult register_component(\n        const std::string&amp; component_id,\n        const std::string&amp; name,\n        ComponentType type,\n        double initial_health = 100.0);\n\n    // Update component state\n    DegradationResult update_component(\n        const std::string&amp; component_id,\n        const OperatingConditions&amp; conditions,\n        std::chrono::hours delta_time);\n\n    // Get component health\n    ComponentHealth get_component_health(const std::string&amp; component_id) const;\n\n    // Get all component healths\n    std::vector&lt;ComponentHealth&gt; get_all_component_healths() const;\n\n    // Get components by status\n    std::vector&lt;ComponentHealth&gt; get_components_by_status(\n        HealthStatus status) const;\n\n    // Calculate wear factors\n    std::vector&lt;WearFactor&gt; calculate_wear_factors(\n        const std::string&amp; component_id,\n        const OperatingConditions&amp; conditions) const;\n\n    // Predict failure\n    FailurePrediction predict_failure(const std::string&amp; component_id) const;\n\n    // Predict all failures\n    std::vector&lt;FailurePrediction&gt; predict_all_failures() const;\n\n    // Get maintenance recommendations\n    MaintenanceRecommendation get_maintenance_recommendation(\n        const std::string&amp; component_id) const;\n\n    // Get all maintenance recommendations\n    std::vector&lt;MaintenanceRecommendation&gt; get_all_maintenance_recommendations() const;\n\n    // Get maintenance schedule\n    struct MaintenanceSchedule {\n        std::vector&lt;MaintenanceRecommendation&gt; immediate;   // Within 24 hours\n        std::vector&lt;MaintenanceRecommendation&gt; soon;        // Within 7 days\n        std::vector&lt;MaintenanceRecommendation&gt; scheduled;   // Within 30 days\n        std::vector&lt;MaintenanceRecommendation&gt; planned;     // Within 90 days\n    };\n    MaintenanceSchedule get_maintenance_schedule() const;\n\n    // Record maintenance action\n    DegradationResult record_maintenance(\n        const std::string&amp; component_id,\n        MaintenanceAction action,\n        double health_restored = 100.0);\n\n    // Simulate degradation over time\n    std::vector&lt;ComponentHealth&gt; simulate_degradation(\n        const std::string&amp; component_id,\n        const OperatingConditions&amp; conditions,\n        std::chrono::hours duration,\n        std::chrono::hours step_size) const;\n\n    // Get fleet statistics (multiple entities)\n    struct FleetHealth {\n        size_t total_components;\n        size_t excellent_count;\n        size_t good_count;\n        size_t fair_count;\n        size_t poor_count;\n        size_t critical_count;\n        size_t failed_count;\n        double average_health;\n        std::vector&lt;std::string&gt; components_needing_attention;\n    };\n    FleetHealth get_fleet_health() const;\n};\n\n// Factory functions\nstd::unique_ptr&lt;DegradationModel&gt; create_degradation_model(\n    const DegradationConfig&amp; config);\nstd::unique_ptr&lt;IDegradationCalculator&gt; create_linear_calculator();\nstd::unique_ptr&lt;IDegradationCalculator&gt; create_paris_law_calculator(\n    double exponent);\nstd::unique_ptr&lt;IFailurePredictor&gt; create_weibull_predictor();\nstd::unique_ptr&lt;IMaintenanceAdvisor&gt; create_rule_based_advisor();\nstd::unique_ptr&lt;IMaintenanceAdvisor&gt; create_ml_based_advisor(\n    const std::string&amp; model_path);\n</code></pre>"},{"location":"api/thread/#usage-examples","title":"Usage Examples","text":""},{"location":"api/thread/#history-store-for-time-travel-debugging","title":"History Store for Time-Travel Debugging","text":"<pre><code>#include &lt;jaguar/thread/history_store.h&gt;\n\nusing namespace jaguar::thread;\n\n// Configure history store\nHistoryStoreConfig config;\nconfig.storage_path = \"./simulation_history\";\nconfig.default_snapshot_type = SnapshotType::Delta;\nconfig.snapshot_interval = std::chrono::milliseconds{100};\nconfig.compression_enabled = true;\n\nconfig.retention.max_age = std::chrono::hours{24 * 7};  // 1 week\nconfig.retention.max_storage_bytes = 50ULL * 1024 * 1024 * 1024;  // 50 GB\nconfig.retention.auto_compact = true;\n\nauto history = create_history_store(config);\nhistory-&gt;initialize(config);\n\n// Simulation loop with automatic snapshots\nwhile (running) {\n    engine.step(dt);\n\n    // Capture snapshot every 100ms\n    auto state = engine.serialize_state();\n    history-&gt;capture_snapshot(state.data(), state.size());\n\n    // Create checkpoint at mission waypoints\n    if (reached_waypoint) {\n        history-&gt;create_checkpoint(\"waypoint_\" + std::to_string(waypoint_id));\n    }\n}\n\n// Time-travel debugging: restore to specific time\nauto sim_time = std::chrono::nanoseconds{5000000000};  // 5 seconds\nauto snapshot = history-&gt;get_snapshot_at_time(sim_time);\nif (snapshot) {\n    history-&gt;restore_snapshot(snapshot-&gt;snapshot_id);\n    std::cout &lt;&lt; \"Restored to simulation time: \"\n              &lt;&lt; snapshot-&gt;simulation_time.count() &lt;&lt; \" ns\\n\";\n}\n\n// Query history for analysis\nHistoryQuery query;\nquery.start_time = start;\nquery.end_time = end;\nquery.entity_id = aircraft_id;\n\nauto snapshots = history-&gt;query_snapshots(query);\nfor (const auto&amp; snap : snapshots) {\n    analyze_state(snap.state_data);\n}\n\n// Export for offline analysis\nhistory-&gt;export_history(\"./analysis/mission_data.parquet\",\n                       ExportFormat::Parquet);\n</code></pre>"},{"location":"api/thread/#predictive-maintenance","title":"Predictive Maintenance","text":"<pre><code>#include &lt;jaguar/thread/degradation_model.h&gt;\n\nusing namespace jaguar::thread;\n\n// Configure degradation model\nDegradationConfig config;\nconfig.enable_wear = true;\nconfig.enable_fatigue = true;\nconfig.enable_thermal = true;\nconfig.prediction_horizon = std::chrono::hours{2000};\nconfig.monte_carlo_samples = 50000;\n\nauto model = create_degradation_model(config);\nmodel-&gt;initialize(config);\n\n// Register aircraft components\nmodel-&gt;register_component(\"engine-1\", \"Port Engine\", ComponentType::Propulsion);\nmodel-&gt;register_component(\"engine-2\", \"Starboard Engine\", ComponentType::Propulsion);\nmodel-&gt;register_component(\"landing-gear\", \"Main Landing Gear\", ComponentType::Landing);\nmodel-&gt;register_component(\"avionics-suite\", \"Avionics Suite\", ComponentType::Avionics);\nmodel-&gt;register_component(\"airframe\", \"Airframe Structure\", ComponentType::Structural);\n\n// During simulation, update with operating conditions\nOperatingConditions conditions;\nconditions.temperature_celsius = 35.0;\nconditions.altitude_meters = 10000;\nconditions.speed_mps = 250;\nconditions.load_factor = 1.5;\nconditions.vibration_level = 2.0;\nconditions.is_combat = false;\n\nmodel-&gt;update_component(\"engine-1\", conditions, std::chrono::hours{1});\nmodel-&gt;update_component(\"engine-2\", conditions, std::chrono::hours{1});\n\n// Check component health\nauto engine_health = model-&gt;get_component_health(\"engine-1\");\nstd::cout &lt;&lt; \"Engine 1 health: \" &lt;&lt; engine_health.health_percentage &lt;&lt; \"%\\n\";\nstd::cout &lt;&lt; \"Status: \" &lt;&lt; static_cast&lt;int&gt;(engine_health.status) &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Operating hours: \" &lt;&lt; engine_health.operating_hours.count() &lt;&lt; \"\\n\";\n\n// Get failure prediction\nauto prediction = model-&gt;predict_failure(\"engine-1\");\nstd::cout &lt;&lt; \"Failure probability (next 1000h): \"\n          &lt;&lt; prediction.failure_probability * 100 &lt;&lt; \"%\\n\";\nstd::cout &lt;&lt; \"Mean time to failure: \"\n          &lt;&lt; prediction.time_to_failure_mean.count() &lt;&lt; \" hours\\n\";\n\n// Get maintenance recommendations\nauto schedule = model-&gt;get_maintenance_schedule();\n\nstd::cout &lt;&lt; \"\\n=== IMMEDIATE MAINTENANCE ===\\n\";\nfor (const auto&amp; rec : schedule.immediate) {\n    std::cout &lt;&lt; rec.component_id &lt;&lt; \": \" &lt;&lt; rec.description &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"  Urgency: \" &lt;&lt; rec.urgency &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"  Est. cost: $\" &lt;&lt; rec.estimated_cost &lt;&lt; \"\\n\";\n}\n\nstd::cout &lt;&lt; \"\\n=== SCHEDULED MAINTENANCE ===\\n\";\nfor (const auto&amp; rec : schedule.scheduled) {\n    std::cout &lt;&lt; rec.component_id &lt;&lt; \": \" &lt;&lt; rec.description &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"  Due within: \" &lt;&lt; rec.recommended_within.count() &lt;&lt; \" hours\\n\";\n}\n\n// Record maintenance performed\nmodel-&gt;record_maintenance(\"engine-1\", MaintenanceAction::Service, 95.0);\n\n// Fleet-level health summary\nauto fleet = model-&gt;get_fleet_health();\nstd::cout &lt;&lt; \"\\n=== FLEET HEALTH ===\\n\";\nstd::cout &lt;&lt; \"Average health: \" &lt;&lt; fleet.average_health &lt;&lt; \"%\\n\";\nstd::cout &lt;&lt; \"Components needing attention: \"\n          &lt;&lt; fleet.components_needing_attention.size() &lt;&lt; \"\\n\";\n</code></pre>"},{"location":"api/thread/#digital-twin-integration","title":"Digital Twin Integration","text":"<pre><code>#include &lt;jaguar/thread/history_store.h&gt;\n#include &lt;jaguar/thread/degradation_model.h&gt;\n\nusing namespace jaguar::thread;\n\n// Integrated digital twin\nclass DigitalTwin {\n    std::unique_ptr&lt;HistoryStore&gt; history_;\n    std::unique_ptr&lt;DegradationModel&gt; degradation_;\n\npublic:\n    void initialize() {\n        // Initialize history store\n        HistoryStoreConfig hist_cfg;\n        hist_cfg.storage_path = \"./digital_twin/history\";\n        history_ = create_history_store(hist_cfg);\n        history_-&gt;initialize(hist_cfg);\n\n        // Initialize degradation model\n        DegradationConfig deg_cfg;\n        degradation_ = create_degradation_model(deg_cfg);\n        degradation_-&gt;initialize(deg_cfg);\n    }\n\n    void update(const SimulationState&amp; state,\n                const OperatingConditions&amp; conditions,\n                std::chrono::hours delta) {\n        // Capture state history\n        auto serialized = serialize(state);\n        history_-&gt;capture_snapshot(serialized.data(), serialized.size());\n\n        // Update degradation for all components\n        for (const auto&amp; component : state.components) {\n            degradation_-&gt;update_component(component.id, conditions, delta);\n        }\n    }\n\n    MaintenanceSchedule get_maintenance_schedule() const {\n        return degradation_-&gt;get_maintenance_schedule();\n    }\n\n    void replay_from(std::chrono::nanoseconds sim_time) {\n        auto snapshot = history_-&gt;get_snapshot_at_time(sim_time);\n        if (snapshot) {\n            restore_state(snapshot-&gt;state_data);\n        }\n    }\n};\n</code></pre>"},{"location":"api/thread/#see-also","title":"See Also","text":"<ul> <li>Architecture - System architecture overview</li> <li>Cloud Burst API - Distributed simulation</li> <li>Machine Learning API - Neural networks for prediction</li> <li>Configuration - Engine configuration</li> </ul>"},{"location":"api/xr/","title":"XR API Reference","text":"<p>Extended Reality (VR/AR) integration for immersive simulation experiences.</p>"},{"location":"api/xr/#overview","title":"Overview","text":"<p>The XR module provides: - OpenXR Integration: Cross-platform VR/AR headset support - Session Management: Multi-platform XR runtime abstraction - Tracking: Head, hand, eye, and controller tracking - Spatial Audio: HRTF-based 3D positional audio - Haptic Feedback: Controller vibration, vest, motion platform, and G-force simulation - Input Handling: Controller and hand gesture input - Training Modules: Professional simulation training systems</p>"},{"location":"api/xr/#namespaces","title":"Namespaces","text":"<pre><code>namespace jaguar::xr;        // XR session and tracking\nnamespace jaguar::audio;     // Spatial audio system\nnamespace jaguar::haptics;   // Haptic feedback system\nnamespace jaguar::training;  // Training modules\n</code></pre>"},{"location":"api/xr/#xr-session-types","title":"XR Session Types","text":""},{"location":"api/xr/#xrresult","title":"XRResult","text":"<p>Result codes for XR operations.</p> <pre><code>enum class XRResult : Int32 {\n    Success = 0,\n    NotInitialized = -1,\n    RuntimeUnavailable = -2,\n    SessionNotRunning = -3,\n    SessionLost = -4,\n    FrameDiscarded = -5,\n    InvalidParameter = -6,\n    DeviceNotConnected = -7,\n    FeatureNotSupported = -8,\n    TrackingLost = -9,\n    CalibrationRequired = -10,\n    PermissionDenied = -11,\n    OutOfMemory = -12,\n    InternalError = -99\n};\n\n// Helper functions\nconst char* xr_result_to_string(XRResult result);\nbool xr_succeeded(XRResult result);\n</code></pre>"},{"location":"api/xr/#xrsessionstate","title":"XRSessionState","text":"<pre><code>enum class XRSessionState : UInt8 {\n    Unknown = 0,\n    Idle = 1,           // Session created, not running\n    Ready = 2,          // Session ready to begin\n    Synchronized = 3,   // Synchronized with runtime\n    Visible = 4,        // Content visible but not focused\n    Focused = 5,        // Fully focused and interactive\n    Stopping = 6,       // Session stopping\n    Exiting = 7,        // Session exiting\n    LossPending = 8     // Session loss imminent\n};\n</code></pre>"},{"location":"api/xr/#xrpose","title":"XRPose","text":"<p>6-DOF pose representation.</p> <pre><code>struct XRPose {\n    Vec3 position{Vec3::Zero()};\n    Quat orientation{Quat::Identity()};\n    TrackingConfidence position_confidence{TrackingConfidence::None};\n    TrackingConfidence orientation_confidence{TrackingConfidence::None};\n    bool is_valid{false};\n\n    bool has_tracking() const;\n    bool has_full_tracking() const;\n    Vec3 forward() const;\n    Vec3 up() const;\n    Vec3 right() const;\n    Vec3 transform_point(const Vec3&amp; local_point) const;\n    Vec3 transform_direction(const Vec3&amp; local_dir) const;\n\n    static XRPose lerp(const XRPose&amp; a, const XRPose&amp; b, Real t);\n    static XRPose Identity();\n};\n</code></pre>"},{"location":"api/xr/#xrtrackedpose","title":"XRTrackedPose","text":"<p>Complete tracked pose with velocity.</p> <pre><code>struct XRTrackedPose {\n    XRPose pose;\n    XRVelocity velocity;\n    Int64 timestamp_ns{0};\n};\n</code></pre>"},{"location":"api/xr/#xrheadstate","title":"XRHeadState","text":"<p>HMD tracking state.</p> <pre><code>struct XRHeadState {\n    XRTrackedPose head_pose;\n    std::array&lt;XRViewState, 2&gt; views;  // Per-eye view states\n    bool is_user_present{false};\n    Real ipd{0.063f};                  // Interpupillary distance\n};\n</code></pre>"},{"location":"api/xr/#xrcontrollerstate","title":"XRControllerState","text":"<p>Controller input state.</p> <pre><code>struct XRControllerState {\n    XRTrackedPose pose;\n    XRTrackedPose aim_pose;\n    XRTrackedPose grip_pose;\n\n    std::bitset&lt;13&gt; buttons_pressed;\n    std::bitset&lt;13&gt; buttons_touched;\n    std::array&lt;Real, 6&gt; axes;\n\n    bool is_connected{false};\n    bool is_active{false};\n\n    bool is_pressed(XRButton button) const;\n    bool is_touched(XRButton button) const;\n    Real get_axis(XRAxis axis) const;\n    Real trigger() const;\n    Real grip() const;\n    Vec3 thumbstick() const;\n};\n</code></pre>"},{"location":"api/xr/#xrhandstate","title":"XRHandState","text":"<p>Hand tracking state.</p> <pre><code>struct XRHandState {\n    XRHand hand{XRHand::Left};\n    std::array&lt;XRHandJointData, 26&gt; joints;\n    TrackingConfidence confidence{TrackingConfidence::None};\n    bool is_active{false};\n\n    XRHandGesture detected_gesture{XRHandGesture::None};\n    Real gesture_confidence{0.0f};\n    Real pinch_strength{0.0f};\n    Vec3 pinch_point{Vec3::Zero()};\n\n    const XRHandJointData&amp; get_joint(XRHandJoint joint) const;\n    bool is_valid() const;\n    Vec3 index_tip() const;\n    Vec3 thumb_tip() const;\n    Vec3 palm_position() const;\n    Quat palm_orientation() const;\n};\n</code></pre>"},{"location":"api/xr/#spatial-audio-types","title":"Spatial Audio Types","text":""},{"location":"api/xr/#audioresult","title":"AudioResult","text":"<p>Result codes for audio operations.</p> <pre><code>enum class AudioResult : Int32 {\n    Success = 0,\n    NotInitialized = -1,\n    DeviceUnavailable = -2,\n    InvalidParameter = -3,\n    SourceLimitReached = -4,\n    BufferOverflow = -5,\n    FormatNotSupported = -6,\n    HRTFLoadFailed = -7,\n    FileNotFound = -8,\n    DecodingError = -9,\n    OutOfMemory = -10,\n    InternalError = -99\n};\n\nconst char* audio_result_to_string(AudioResult result);\nbool audio_succeeded(AudioResult result);\n</code></pre>"},{"location":"api/xr/#audioformat","title":"AudioFormat","text":"<p>Audio format specification.</p> <pre><code>struct AudioFormat {\n    UInt32 sample_rate{48000};\n    AudioSampleFormat sample_format{AudioSampleFormat::Float32};\n    AudioChannelLayout channel_layout{AudioChannelLayout::Stereo};\n    UInt8 channel_count{2};\n    UInt32 buffer_size{1024};\n};\n</code></pre>"},{"location":"api/xr/#distanceattenuation","title":"DistanceAttenuation","text":"<p>Distance-based gain attenuation.</p> <pre><code>enum class AttenuationModel : UInt8 {\n    None = 0,           // No attenuation\n    Linear = 1,         // Linear falloff\n    Inverse = 2,        // Inverse distance\n    InverseSquare = 3,  // Inverse square (physically accurate)\n    Logarithmic = 4,    // Logarithmic falloff\n    Custom = 5          // User-defined curve\n};\n\nstruct DistanceAttenuation {\n    AttenuationModel model{AttenuationModel::InverseSquare};\n    Real reference_distance{1.0};   // Distance at gain = 1.0\n    Real max_distance{1000.0};      // Maximum audible distance\n    Real rolloff_factor{1.0};       // Rolloff rate multiplier\n    Real min_gain{0.0};\n    Real max_gain{1.0};\n\n    Real calculate_gain(Real distance) const noexcept;\n\n    static DistanceAttenuation Indoor();\n    static DistanceAttenuation Outdoor();\n    static DistanceAttenuation OpenField();\n};\n</code></pre>"},{"location":"api/xr/#audiocone","title":"AudioCone","text":"<p>Directional audio cone.</p> <pre><code>struct AudioCone {\n    Real inner_angle{PI / 3.0};    // Full gain cone angle\n    Real outer_angle{PI};          // Zero gain cone angle\n    Real outer_gain{0.0};          // Gain outside outer cone\n\n    bool is_valid() const noexcept;\n    Real calculate_gain(Real angle) const noexcept;\n};\n</code></pre>"},{"location":"api/xr/#audiosourceconfig","title":"AudioSourceConfig","text":"<p>Complete audio source configuration.</p> <pre><code>struct AudioSourceConfig {\n    std::string name;\n    EntityId entity_id{INVALID_ENTITY_ID};\n\n    AudioSourceType source_type{AudioSourceType::Point};\n    AudioPriority priority{AudioPriority::Normal};\n\n    Vec3 position{Vec3::Zero()};\n    Quat orientation{Quat::Identity()};\n    Vec3 velocity{Vec3::Zero()};\n\n    Real gain{1.0};\n    Real pitch{1.0};\n    bool muted{false};\n\n    DistanceAttenuation attenuation;\n    AudioCone cone;\n\n    bool looping{false};\n    bool auto_play{true};\n\n    bool enable_doppler{true};\n    bool enable_occlusion{true};\n    bool enable_reverb{true};\n    Real air_absorption{0.0};\n\n    Real cull_distance{0.0};\n    bool virtualize_when_culled{true};\n};\n</code></pre>"},{"location":"api/xr/#roomacousticsconfig","title":"RoomAcousticsConfig","text":"<p>Room acoustics and reverb configuration.</p> <pre><code>enum class RoomPreset : UInt8 {\n    None = 0,\n    SmallRoom = 1,\n    MediumRoom = 2,\n    LargeRoom = 3,\n    Cathedral = 4,\n    Cave = 5,\n    Outdoor = 6,\n    Underwater = 7,\n    Aircraft = 8,\n    Cockpit = 9,\n    Custom = 255\n};\n\nstruct ReverbParameters {\n    Real decay_time{1.5};\n    Real pre_delay{0.02};\n    Real diffusion{0.85};\n    Real density{0.85};\n    Real hf_decay_ratio{0.8};\n    Real lf_decay_ratio{1.0};\n    Real wet_dry_mix{0.3};\n    Real gain{1.0};\n};\n\nstruct RoomAcousticsConfig {\n    RoomPreset preset{RoomPreset::MediumRoom};\n    RoomGeometry geometry;\n    ReverbParameters reverb;\n    UInt32 ray_count{1024};\n    UInt32 bounce_count{8};\n    bool enable_diffraction{true};\n\n    static RoomAcousticsConfig FromPreset(RoomPreset preset);\n};\n</code></pre>"},{"location":"api/xr/#dopplerconfig","title":"DopplerConfig","text":"<p>Doppler effect configuration.</p> <pre><code>struct DopplerConfig {\n    bool enabled{true};\n    Real factor{1.0};\n    Real speed_of_sound{343.0};   // m/s\n    Real max_pitch_shift{4.0};\n    Real smoothing_factor{0.1};\n\n    Real calculate_pitch_shift(\n        const Vec3&amp; source_velocity,\n        const Vec3&amp; listener_velocity,\n        const Vec3&amp; direction\n    ) const noexcept;\n};\n</code></pre>"},{"location":"api/xr/#spatial-audio-interfaces","title":"Spatial Audio Interfaces","text":""},{"location":"api/xr/#ispatialaudiosource","title":"ISpatialAudioSource","text":"<p>Interface for spatial audio sources.</p> <pre><code>class ISpatialAudioSource {\npublic:\n    virtual ~ISpatialAudioSource() = default;\n\n    // Identity\n    virtual UInt32 get_id() const = 0;\n    virtual const std::string&amp; get_name() const = 0;\n    virtual EntityId get_entity_id() const = 0;\n\n    // State\n    virtual bool is_playing() const = 0;\n    virtual bool is_paused() const = 0;\n    virtual bool is_virtualized() const = 0;\n\n    // Playback control\n    virtual AudioResult play() = 0;\n    virtual AudioResult pause() = 0;\n    virtual AudioResult stop() = 0;\n    virtual AudioResult seek(Real time_seconds) = 0;\n\n    // Properties\n    virtual void set_position(const Vec3&amp; position) = 0;\n    virtual Vec3 get_position() const = 0;\n    virtual void set_orientation(const Quat&amp; orientation) = 0;\n    virtual void set_velocity(const Vec3&amp; velocity) = 0;\n\n    // Volume\n    virtual void set_gain(Real gain) = 0;\n    virtual Real get_gain() const = 0;\n    virtual void set_pitch(Real pitch) = 0;\n    virtual void set_muted(bool muted) = 0;\n\n    // Effects\n    virtual void set_doppler_enabled(bool enabled) = 0;\n    virtual void set_occlusion_enabled(bool enabled) = 0;\n    virtual void set_reverb_enabled(bool enabled) = 0;\n\n    // Queries\n    virtual Real get_playback_time() const = 0;\n    virtual Real get_effective_gain() const = 0;\n    virtual OcclusionState get_occlusion_state() const = 0;\n};\n</code></pre>"},{"location":"api/xr/#ispatialaudiolistener","title":"ISpatialAudioListener","text":"<p>Interface for the audio listener.</p> <pre><code>class ISpatialAudioListener {\npublic:\n    virtual ~ISpatialAudioListener() = default;\n\n    virtual void set_position(const Vec3&amp; position) = 0;\n    virtual Vec3 get_position() const = 0;\n    virtual void set_orientation(const Quat&amp; orientation) = 0;\n    virtual void set_velocity(const Vec3&amp; velocity) = 0;\n\n    virtual void set_master_gain(Real gain) = 0;\n    virtual Real get_master_gain() const = 0;\n\n    // XR integration\n    virtual void set_xr_tracking(const xr::XRTrackedPose&amp; head_pose) = 0;\n    virtual bool is_xr_tracking_active() const = 0;\n};\n</code></pre>"},{"location":"api/xr/#ispatialaudiorenderer","title":"ISpatialAudioRenderer","text":"<p>Main spatial audio renderer interface.</p> <pre><code>class ISpatialAudioRenderer {\npublic:\n    virtual ~ISpatialAudioRenderer() = default;\n\n    // Lifecycle\n    virtual AudioResult initialize(\n        const AudioFormat&amp; format,\n        const HRTFConfig&amp; hrtf_config\n    ) = 0;\n    virtual void shutdown() = 0;\n    virtual bool is_initialized() const = 0;\n\n    // Source management\n    virtual std::shared_ptr&lt;ISpatialAudioSource&gt; create_source(\n        const AudioSourceConfig&amp; config\n    ) = 0;\n    virtual AudioResult destroy_source(UInt32 source_id) = 0;\n    virtual std::shared_ptr&lt;ISpatialAudioSource&gt; get_source(UInt32 source_id) = 0;\n    virtual UInt32 get_active_source_count() const = 0;\n    virtual UInt32 get_max_source_count() const = 0;\n\n    // Listener\n    virtual ISpatialAudioListener* get_listener() = 0;\n\n    // Room acoustics\n    virtual AudioResult set_room_acoustics(const RoomAcousticsConfig&amp; config) = 0;\n    virtual const RoomAcousticsConfig&amp; get_room_acoustics() const = 0;\n\n    // Configuration\n    virtual AudioResult set_occlusion_config(const OcclusionConfig&amp; config) = 0;\n    virtual AudioResult set_doppler_config(const DopplerConfig&amp; config) = 0;\n\n    // Processing\n    virtual AudioResult update(Real delta_time) = 0;\n    virtual AudioResult render(void* output_buffer, UInt32 frame_count) = 0;\n\n    // HRTF\n    virtual AudioResult load_hrtf_dataset(const std::string&amp; path) = 0;\n    virtual const HRTFDataset&amp; get_hrtf_info() const = 0;\n\n    // Statistics\n    virtual Real get_cpu_usage() const = 0;\n    virtual UInt32 get_virtualized_source_count() const = 0;\n};\n\n// Factory function\nstd::unique_ptr&lt;ISpatialAudioRenderer&gt; create_spatial_audio_renderer();\n</code></pre>"},{"location":"api/xr/#usage-examples","title":"Usage Examples","text":""},{"location":"api/xr/#basic-xr-session","title":"Basic XR Session","text":"<pre><code>#include &lt;jaguar/xr/xr_session.h&gt;\n\nusing namespace jaguar::xr;\n\n// Create session with mock runtime\nauto runtime = create_mock_xr_runtime();\nXRSession session(std::move(runtime));\n\n// Initialize for VR\nauto result = session.initialize(XRSessionConfig::VR_Default());\nif (!xr_succeeded(result)) {\n    std::cerr &lt;&lt; xr_result_to_string(result) &lt;&lt; std::endl;\n    return;\n}\n\n// Main loop\nwhile (session.is_running()) {\n    // Begin frame\n    XRFrameTiming timing;\n    session.begin_frame(timing);\n\n    // Get tracking data\n    XRHeadState head = session.get_head_state();\n    XRControllerState left = session.get_controller_state(XRHand::Left);\n    XRControllerState right = session.get_controller_state(XRHand::Right);\n\n    // Use head position for camera\n    Vec3 camera_pos = head.head_pose.pose.position;\n    Quat camera_rot = head.head_pose.pose.orientation;\n\n    // Check controller input\n    if (right.is_pressed(XRButton::A)) {\n        // Handle button press\n    }\n\n    // End frame\n    session.end_frame();\n}\n\nsession.shutdown();\n</code></pre>"},{"location":"api/xr/#spatial-audio-with-xr","title":"Spatial Audio with XR","text":"<pre><code>#include &lt;jaguar/xr/spatial_audio.h&gt;\n#include &lt;jaguar/xr/xr_session.h&gt;\n\nusing namespace jaguar::audio;\nusing namespace jaguar::xr;\n\n// Create audio renderer\nauto renderer = create_spatial_audio_renderer();\n\nAudioFormat format;\nformat.sample_rate = 48000;\nformat.channel_layout = AudioChannelLayout::Binaural;\n\nHRTFConfig hrtf;\nhrtf.quality = HRTFQuality::High;\nhrtf.max_sources = 64;\n\nrenderer-&gt;initialize(format, hrtf);\n\n// Set room acoustics\nauto room = RoomAcousticsConfig::FromPreset(RoomPreset::Cockpit);\nrenderer-&gt;set_room_acoustics(room);\n\n// Create audio sources\nAudioSourceConfig engine_config;\nengine_config.name = \"engine\";\nengine_config.position = {0.0, 0.0, -2.0};  // Behind player\nengine_config.looping = true;\nengine_config.enable_doppler = false;  // Engine moves with listener\n\nauto engine_sound = renderer-&gt;create_source(engine_config);\nengine_sound-&gt;play();\n\nAudioSourceConfig missile_config;\nmissile_config.name = \"missile\";\nmissile_config.position = {100.0, 50.0, 200.0};\nmissile_config.velocity = {-50.0, 0.0, -100.0};  // Approaching\nmissile_config.enable_doppler = true;\n\nauto missile_sound = renderer-&gt;create_source(missile_config);\nmissile_sound-&gt;play();\n\n// Main loop with XR integration\nwhile (running) {\n    // Get XR head tracking\n    XRHeadState head = xr_session.get_head_state();\n\n    // Update listener from XR tracking\n    renderer-&gt;get_listener()-&gt;set_xr_tracking(head.head_pose);\n\n    // Update missile position\n    Vec3 pos = missile_sound-&gt;get_position();\n    pos += missile_config.velocity * delta_time;\n    missile_sound-&gt;set_position(pos);\n\n    // Process audio\n    renderer-&gt;update(delta_time);\n\n    // Render to audio buffer\n    std::vector&lt;float&gt; audio_buffer(1024 * 2);\n    renderer-&gt;render(audio_buffer.data(), 1024);\n\n    // Send to audio device...\n}\n\nrenderer-&gt;shutdown();\n</code></pre>"},{"location":"api/xr/#hand-tracking","title":"Hand Tracking","text":"<pre><code>#include &lt;jaguar/xr/xr_session.h&gt;\n\nusing namespace jaguar::xr;\n\n// Enable hand tracking\nXRSessionConfig config = XRSessionConfig::VR_Default();\nconfig.enable_hand_tracking = true;\n\nXRSession session(create_mock_xr_runtime());\nsession.initialize(config);\n\nwhile (session.is_running()) {\n    session.begin_frame(timing);\n\n    // Get hand tracking data\n    XRHandState left_hand = session.get_hand_state(XRHand::Left);\n    XRHandState right_hand = session.get_hand_state(XRHand::Right);\n\n    if (right_hand.is_valid()) {\n        // Check pinch gesture\n        if (right_hand.pinch_strength &gt; 0.8) {\n            Vec3 pinch_pos = right_hand.pinch_point;\n            // Handle pinch at position\n        }\n\n        // Get fingertip positions\n        Vec3 index_tip = right_hand.index_tip();\n        Vec3 thumb_tip = right_hand.thumb_tip();\n\n        // Check detected gesture\n        if (right_hand.detected_gesture == XRHandGesture::Point) {\n            // Handle pointing gesture\n        }\n    }\n\n    session.end_frame();\n}\n</code></pre>"},{"location":"api/xr/#room-material-presets","title":"Room Material Presets","text":"<pre><code>// Acoustic material properties\nRoomMaterial concrete = RoomMaterial::Concrete();  // Low absorption\nRoomMaterial carpet = RoomMaterial::Carpet();      // High HF absorption\nRoomMaterial glass = RoomMaterial::Glass();        // Low scattering\nRoomMaterial fabric = RoomMaterial::Fabric();      // High scattering\nRoomMaterial wood = RoomMaterial::Wood();          // Balanced\n\n// Occluder materials\nOccluderMaterial wall = OccluderMaterial::SolidWall();\nOccluderMaterial door = OccluderMaterial::Door();\nOccluderMaterial window = OccluderMaterial::GlassWindow();\nOccluderMaterial foliage = OccluderMaterial::Foliage();\n</code></pre>"},{"location":"api/xr/#haptic-feedback-types","title":"Haptic Feedback Types","text":""},{"location":"api/xr/#hapticresult","title":"HapticResult","text":"<p>Result codes for haptic operations.</p> <pre><code>enum class HapticResult : Int32 {\n    Success = 0,\n    NotInitialized = -1,\n    DeviceNotConnected = -2,\n    DeviceNotSupported = -3,\n    InvalidParameter = -4,\n    EffectNotSupported = -5,\n    EffectQueueFull = -6,\n    SafetyLimitExceeded = -9,\n    InternalError = -99\n};\n\nconst char* haptic_result_to_string(HapticResult result);\nbool haptic_succeeded(HapticResult result);\n</code></pre>"},{"location":"api/xr/#hapticdevicetype","title":"HapticDeviceType","text":"<p>Types of haptic devices.</p> <pre><code>enum class HapticDeviceType : UInt8 {\n    Unknown = 0,\n    Controller = 1,       // VR/XR controller\n    Vest = 2,             // Haptic vest\n    Glove = 3,            // Haptic glove\n    MotionPlatform = 4,   // Motion platform\n    SteeringWheel = 5,    // Force feedback wheel\n    FlightControls = 6,   // Force feedback flight stick\n    Exoskeleton = 7       // Full body haptic\n};\n</code></pre>"},{"location":"api/xr/#hapticwaveform","title":"HapticWaveform","text":"<p>Basic haptic effect waveform types.</p> <pre><code>enum class HapticWaveform : UInt8 {\n    None = 0,\n    Constant = 1,   // Constant amplitude\n    Sine = 2,       // Sinusoidal oscillation\n    Square = 3,     // Square wave\n    Triangle = 4,   // Triangle wave\n    Sawtooth = 5,   // Sawtooth wave\n    Noise = 6,      // Random noise\n    Custom = 7      // Custom waveform\n};\n</code></pre>"},{"location":"api/xr/#hapticenvelope","title":"HapticEnvelope","text":"<p>ADSR-style envelope for haptic effects.</p> <pre><code>struct HapticEnvelope {\n    Real attack_time{0.0};\n    Real attack_level{1.0};\n    Real decay_time{0.0};\n    Real sustain_level{1.0};\n    Real release_time{0.0};\n\n    static HapticEnvelope Instant();\n    static HapticEnvelope FadeIn(Real attack_seconds);\n    static HapticEnvelope FadeOut(Real release_seconds);\n    static HapticEnvelope ADSR(Real attack, Real decay, Real sustain, Real release);\n};\n</code></pre>"},{"location":"api/xr/#hapticeffect","title":"HapticEffect","text":"<p>Core haptic effect definition.</p> <pre><code>struct HapticEffect {\n    HapticWaveform waveform{HapticWaveform::Constant};\n    Real frequency{160.0};      // Hz\n    Real amplitude{0.5};        // 0-1\n    Real duration{0.1};         // seconds (0 = infinite)\n    HapticEnvelope envelope;\n    Int32 repeat_count{1};\n    Real repeat_delay{0.0};\n\n    // Factory methods\n    static HapticEffect Vibration(Real amplitude, Real duration, Real frequency = 160.0);\n    static HapticEffect Pulse(Real amplitude, Real on_time, Real off_time, Int32 pulses);\n    static HapticEffect Rumble(Real intensity, Real duration);\n    static HapticEffect Impact(Real intensity);\n};\n</code></pre>"},{"location":"api/xr/#vestzone","title":"VestZone","text":"<p>Haptic vest zone identifiers.</p> <pre><code>enum class VestZone : UInt8 {\n    ChestLeft = 0, ChestCenter = 1, ChestRight = 2,\n    AbdomenLeft = 3, AbdomenCenter = 4, AbdomenRight = 5,\n    UpperBackLeft = 6, UpperBackCenter = 7, UpperBackRight = 8,\n    LowerBackLeft = 9, LowerBackCenter = 10, LowerBackRight = 11,\n    LeftSide = 12, RightSide = 13,\n    LeftShoulder = 14, RightShoulder = 15,\n    ZoneCount = 16\n};\n</code></pre>"},{"location":"api/xr/#motiondof","title":"MotionDOF","text":"<p>Motion platform degrees of freedom.</p> <pre><code>enum class MotionDOF : UInt8 {\n    Surge = 0,    // Forward/backward\n    Sway = 1,     // Left/right\n    Heave = 2,    // Up/down\n    Roll = 3,     // Rotation around longitudinal\n    Pitch = 4,    // Rotation around lateral\n    Yaw = 5,      // Rotation around vertical\n    DOFCount = 6\n};\n</code></pre>"},{"location":"api/xr/#motioncueingparams","title":"MotionCueingParams","text":"<p>Motion cueing filter parameters.</p> <pre><code>struct MotionCueingParams {\n    WashoutAlgorithm algorithm;\n    std::array&lt;Real, 6&gt; hp_cutoff_freq;    // High-pass cutoff\n    std::array&lt;Real, 6&gt; hp_damping;\n    std::array&lt;Real, 3&gt; lp_cutoff_freq;    // Low-pass for tilt\n    std::array&lt;Real, 6&gt; scaling;\n    Real tilt_coordination_gain{0.6};\n    Real max_tilt_rate{0.5};\n\n    // Factory methods\n    static MotionCueingParams AircraftDefault();\n    static MotionCueingParams GroundVehicleDefault();\n    static MotionCueingParams ShipDefault();\n};\n</code></pre>"},{"location":"api/xr/#gforceconfig","title":"GForceConfig","text":"<p>G-force feedback configuration.</p> <pre><code>struct GForceConfig {\n    Real longitudinal_scale{1.0};\n    Real lateral_scale{1.0};\n    Real vertical_scale{1.0};\n    Real max_sustained_g{3.0};\n    Real max_onset_rate{6.0};\n    bool use_tilt_coordination{true};\n    bool simulate_gsuit{false};\n    Real gsuit_threshold{2.0};\n\n    // Presets\n    static GForceConfig FighterJet();\n    static GForceConfig CivilAircraft();\n    static GForceConfig GroundVehicle();\n};\n</code></pre>"},{"location":"api/xr/#haptic-interfaces","title":"Haptic Interfaces","text":""},{"location":"api/xr/#ihapticrenderer","title":"IHapticRenderer","text":"<p>Main haptic renderer interface.</p> <pre><code>class IHapticRenderer {\npublic:\n    virtual HapticResult initialize(const HapticRendererConfig&amp; config) = 0;\n    virtual HapticResult shutdown() = 0;\n    virtual HapticResult update(Real delta_time) = 0;\n\n    // Devices\n    virtual std::shared_ptr&lt;IHapticController&gt; get_controller() const = 0;\n    virtual std::shared_ptr&lt;IHapticVest&gt; get_vest() const = 0;\n    virtual std::shared_ptr&lt;IMotionPlatform&gt; get_motion_platform() const = 0;\n\n    // Controller shortcuts\n    virtual HapticEffectId play_controller_effect(xr::XRHand hand, const HapticEffect&amp; effect) = 0;\n    virtual HapticResult play_controller_vibration(xr::XRHand hand, Real low_freq, Real high_freq, Real duration) = 0;\n\n    // Vest shortcuts\n    virtual HapticEffectId play_vest_pattern(const VestHapticPattern&amp; pattern) = 0;\n    virtual HapticResult play_vest_impact(const Vec3&amp; direction, Real intensity) = 0;\n\n    // Motion platform\n    virtual HapticResult apply_motion_cueing(const Vec3&amp; linear_accel, const Vec3&amp; angular_vel, const Vec3&amp; angular_accel) = 0;\n\n    // Engine vibration\n    virtual HapticResult set_engine_vibration(const EngineVibrationParams&amp; params) = 0;\n\n    // G-force\n    virtual HapticResult apply_g_force(const GForceState&amp; g_state) = 0;\n    virtual GForceState calculate_g_force(const Vec3&amp; body_accel, const Vec3&amp; gravity_body) const = 0;\n\n    // Emergency\n    virtual HapticResult emergency_stop_all() = 0;\n};\n\n// Factory functions\nstd::unique_ptr&lt;IHapticRenderer&gt; create_haptic_renderer();\nstd::unique_ptr&lt;IHapticRenderer&gt; create_haptic_renderer(const HapticRendererConfig&amp; config);\nstd::unique_ptr&lt;IHapticRenderer&gt; create_mock_haptic_renderer();\n</code></pre>"},{"location":"api/xr/#haptic-presets","title":"Haptic Presets","text":""},{"location":"api/xr/#aircraft-presets","title":"Aircraft Presets","text":"<pre><code>namespace presets::aircraft {\n    HapticEffect StallBuffet(Real intensity);\n    HapticEffect GearTransition(bool extending);\n    HapticEffect FlapMovement(Real deflection);\n    HapticEffect SpeedBrake(Real deployment);\n    HapticEffect Touchdown(Real vertical_speed);\n    HapticEffect EngineStart(Real progress);\n    HapticEffect AfterburnerIgnition();\n    HapticEffect WeaponsRelease();\n    HapticEffect RefuelingContact();\n    HapticEffect OverspeedWarning();\n}\n</code></pre>"},{"location":"api/xr/#vehicle-presets","title":"Vehicle Presets","text":"<pre><code>namespace presets::vehicle {\n    HapticEffect RoadTexture(Real roughness);\n    HapticEffect BrakeApply(Real pressure);\n    HapticEffect ABSPulse();\n    HapticEffect GearShift();\n    HapticEffect Collision(Real severity, const Vec3&amp; direction);\n    HapticEffect TrackRumble(Real speed);\n    HapticEffect FiringRecoil(Real caliber);\n}\n</code></pre>"},{"location":"api/xr/#naval-presets","title":"Naval Presets","text":"<pre><code>namespace presets::naval {\n    HapticEffect WaveMotion(Real sea_state);\n    HapticEffect HullVibration(Real speed);\n    HapticEffect AnchorDrop();\n    HapticEffect NavalGunFiring(Real caliber);\n    HapticEffect TorpedoLaunch();\n    HapticEffect DepthCharge(Real distance);\n}\n</code></pre>"},{"location":"api/xr/#helicopter-presets","title":"Helicopter Presets","text":"<pre><code>namespace presets::helicopter {\n    HapticEffect RotorVibration(Real rpm);\n    HapticEffect GroundResonance();\n    HapticEffect VortexRingState();\n    HapticEffect Autorotation();\n    HapticEffect HardLanding(Real vertical_speed);\n}\n</code></pre>"},{"location":"api/xr/#haptic-usage-example","title":"Haptic Usage Example","text":"<pre><code>using namespace jaguar::haptics;\n\n// Create and initialize renderer\nauto haptics = create_haptic_renderer();\nHapticRendererConfig config;\nconfig.auto_connect_devices = true;\nconfig.g_force_config = GForceConfig::FighterJet();\nconfig.motion_cueing_params = MotionCueingParams::AircraftDefault();\nhaptics-&gt;initialize(config);\n\n// Main loop\nwhile (running) {\n    // Apply flight dynamics to motion platform\n    Vec3 accel = aircraft.get_body_acceleration();\n    Vec3 ang_vel = aircraft.get_angular_velocity();\n    Vec3 ang_accel = aircraft.get_angular_acceleration();\n    haptics-&gt;apply_motion_cueing(accel, ang_vel, ang_accel);\n\n    // Calculate and apply G-force\n    Vec3 gravity_body = aircraft.get_gravity_body_frame();\n    auto g_state = haptics-&gt;calculate_g_force(accel, gravity_body);\n    haptics-&gt;apply_g_force(g_state);\n\n    // Engine vibration\n    EngineVibrationParams engine;\n    engine.source = EngineVibrationSource::Turbine;\n    engine.rpm = aircraft.get_n1_percent() * 150.0;\n    engine.throttle = aircraft.get_throttle();\n    haptics-&gt;set_engine_vibration(engine);\n\n    // Stall buffet\n    if (aircraft.is_approaching_stall()) {\n        auto buffet = presets::aircraft::StallBuffet(aircraft.get_stall_intensity());\n        haptics-&gt;play_controller_effect(xr::XRHand::Left, buffet);\n        haptics-&gt;play_controller_effect(xr::XRHand::Right, buffet);\n    }\n\n    // Touchdown\n    if (aircraft.just_touched_down()) {\n        auto touchdown = presets::aircraft::Touchdown(aircraft.get_vertical_speed());\n        haptics-&gt;play_controller_effect(xr::XRHand::Left, touchdown);\n        haptics-&gt;play_vest_impact(Vec3{0, -1, 0}, 0.8);\n    }\n\n    haptics-&gt;update(delta_time);\n}\n\nhaptics-&gt;shutdown();\n</code></pre>"},{"location":"api/xr/#training-module-types","title":"Training Module Types","text":""},{"location":"api/xr/#trainingresult","title":"TrainingResult","text":"<p>Result codes for training operations.</p> <pre><code>enum class TrainingResult : Int32 {\n    Success = 0,\n    NotInitialized = -1,\n    SessionNotActive = -2,\n    ScenarioNotLoaded = -3,\n    InvalidParameter = -4,\n    ModuleNotAvailable = -5,\n    InstrumentNotFound = -6,\n    ObjectiveNotFound = -7,\n    RecordingNotStarted = -8,\n    PlaybackError = -9,\n    ScriptError = -10,\n    ResourceNotFound = -11,\n    PermissionDenied = -12,\n    OutOfMemory = -13,\n    InternalError = -99\n};\n\nconst char* training_result_to_string(TrainingResult result);\nbool training_succeeded(TrainingResult result);\n</code></pre>"},{"location":"api/xr/#trainingdomain","title":"TrainingDomain","text":"<p>Training domain categories.</p> <pre><code>enum class TrainingDomain : UInt8 {\n    Aviation = 0,           // Fixed-wing aircraft\n    Rotorcraft = 1,         // Helicopters\n    Naval = 2,              // Ships and submarines\n    GroundVehicle = 3,      // Tanks, APCs, trucks\n    AirTrafficControl = 4,  // ATC operations\n    Maritime = 5,           // Port operations\n    Emergency = 6,          // Emergency response\n    Custom = 255\n};\n</code></pre>"},{"location":"api/xr/#difficultylevel","title":"DifficultyLevel","text":"<pre><code>enum class DifficultyLevel : UInt8 {\n    Tutorial = 0,\n    Beginner = 1,\n    Intermediate = 2,\n    Advanced = 3,\n    Expert = 4,\n    Instructor = 5\n};\n</code></pre>"},{"location":"api/xr/#instrumenttype","title":"InstrumentType","text":"<p>Cockpit instrument categories (60+ types).</p> <pre><code>enum class InstrumentType : UInt8 {\n    // Primary Flight Display\n    Airspeed = 0, Altitude = 1, AttitudeIndicator = 2,\n    HeadingIndicator = 3, VerticalSpeed = 4, TurnCoordinator = 5,\n\n    // Navigation\n    HSI = 10, RMI = 11, DME = 12, ADF = 13, GPS = 14, FMS = 15,\n\n    // Engine\n    Tachometer = 20, Manifold = 21, FuelFlow = 22, FuelQuantity = 23,\n    OilPressure = 24, OilTemperature = 25, EGT = 26, CHT = 27, N1 = 28, N2 = 29,\n\n    // Systems\n    Electrical = 40, Hydraulic = 41, Warning = 45, Annunciator = 46,\n\n    // Radio\n    ComRadio = 50, NavRadio = 51, Transponder = 52, TCAS = 53, GPWS = 54,\n\n    // Autopilot &amp; Military\n    FlightDirector = 60, Autopilot = 61, WeaponsPanel = 70, HUD = 72, MFD = 73,\n\n    Custom = 255\n};\n</code></pre>"},{"location":"api/xr/#objectivetype","title":"ObjectiveType","text":"<p>Training objective types.</p> <pre><code>enum class ObjectiveType : UInt8 {\n    // Flight objectives\n    Takeoff = 0, Landing = 1, GoAround = 2, Approach = 3,\n    Holding = 4, Navigation = 5, Emergency = 6,\n\n    // Maneuvers\n    SteepTurn = 10, Stall = 11, SlowFlight = 12, Spin = 13, AcrobaticManeuver = 14,\n\n    // Procedures\n    Checklist = 20, Communication = 21, SystemsManagement = 22,\n    DecisionMaking = 23, CrewCoordination = 24,\n\n    // Navigation\n    VORNavigation = 30, ILSApproach = 31, VFRNavigation = 32, GPSNavigation = 33,\n\n    Custom = 255\n};\n</code></pre>"},{"location":"api/xr/#trainingeventtype","title":"TrainingEventType","text":"<p>Event types for after-action review recording.</p> <pre><code>enum class TrainingEventType : UInt8 {\n    // Session\n    SessionStart = 0, SessionEnd = 1, Checkpoint = 2, Bookmark = 3,\n\n    // Performance\n    ObjectiveStarted = 10, ObjectiveCompleted = 11, ObjectiveFailed = 12,\n    ErrorMade = 13, ExcellentPerformance = 14,\n\n    // Aircraft state\n    StateChange = 20, Stall = 21, Overspeed = 22, Exceedance = 23,\n    Collision = 24, Crash = 25,\n\n    // Systems &amp; Communication\n    SystemFailure = 30, RadioTransmission = 40, Instruction = 41,\n\n    // Custom\n    InstructorNote = 60, Custom = 255\n};\n</code></pre>"},{"location":"api/xr/#grade","title":"Grade","text":"<p>Performance grading levels.</p> <pre><code>enum class Grade : UInt8 {\n    Excellent = 0,      // 90-100%\n    Good = 1,           // 80-89%\n    Satisfactory = 2,   // 70-79%\n    Marginal = 3,       // 60-69%\n    Unsatisfactory = 4, // Below 60%\n    Incomplete = 5\n};\n</code></pre>"},{"location":"api/xr/#training-data-structures","title":"Training Data Structures","text":""},{"location":"api/xr/#instrumentstate","title":"InstrumentState","text":"<pre><code>struct InstrumentState {\n    InstrumentType type;\n    std::string name;\n    Real value;\n    Real min_value;\n    Real max_value;\n    bool is_active;\n    bool has_warning;\n    bool has_failure;\n    std::string units;\n};\n</code></pre>"},{"location":"api/xr/#controlstate","title":"ControlState","text":"<pre><code>struct ControlState {\n    ControlType type;\n    std::string name;\n    Real position;      // -1 to 1 for axes, 0 or 1 for switches\n    Real force;         // Force feedback (if supported)\n    bool is_switch;\n    bool is_momentary;\n    bool is_active;\n};\n</code></pre>"},{"location":"api/xr/#aircrafttrack","title":"AircraftTrack","text":"<p>Air traffic control radar track.</p> <pre><code>struct AircraftTrack {\n    std::string callsign;\n    std::string aircraft_type;\n    Vec3 position;\n    Vec3 velocity;\n    Real altitude;          // feet\n    Real heading;           // degrees\n    Real ground_speed;      // knots\n    Real vertical_rate;     // feet per minute\n    std::string squawk;\n    bool is_departing;\n    bool is_arriving;\n    bool is_vfr;\n    bool has_emergency;\n};\n</code></pre>"},{"location":"api/xr/#trainingobjective","title":"TrainingObjective","text":"<pre><code>struct TrainingObjective {\n    UInt32 id;\n    ObjectiveType type;\n    std::string name;\n    std::string description;\n    ObjectiveStatus status;\n    Real score;             // 0-100\n    Real weight;            // Weight in overall score\n    Real time_limit;        // seconds (0 = no limit)\n    Real elapsed_time;\n    std::vector&lt;std::string&gt; criteria;\n    std::vector&lt;std::string&gt; feedback;\n    bool is_mandatory;\n    bool is_graded;\n};\n</code></pre>"},{"location":"api/xr/#statesnapshot","title":"StateSnapshot","text":"<p>State snapshot for replay.</p> <pre><code>struct StateSnapshot {\n    Real timestamp;\n    Vec3 position;\n    Quat orientation;\n    Vec3 velocity;\n    Vec3 angular_velocity;\n    Real airspeed, altitude, heading;\n    Real pitch, roll;\n    Real vertical_speed;\n    Real elevator, aileron, rudder, throttle, flaps;\n    bool gear_down;\n    std::array&lt;Real, 4&gt; engine_rpm;\n    std::vector&lt;InstrumentState&gt; instruments;\n};\n</code></pre>"},{"location":"api/xr/#scenariodefinition","title":"ScenarioDefinition","text":"<p>Training scenario definition.</p> <pre><code>struct ScenarioDefinition {\n    std::string id;\n    std::string name;\n    std::string description;\n    TrainingDomain domain;\n    DifficultyLevel difficulty;\n\n    // Initial conditions\n    Vec3 start_position;\n    Quat start_orientation;\n    Real start_altitude, start_airspeed, start_heading;\n    WeatherPreset weather;\n    TimeOfDay time;\n\n    // Content\n    std::vector&lt;TrainingObjective&gt; objectives;\n    std::vector&lt;ScriptRule&gt; rules;\n    std::vector&lt;std::string&gt; checkpoints;\n\n    // Metadata\n    Real estimated_duration;\n    std::vector&lt;std::string&gt; prerequisites;\n    std::string author;\n};\n</code></pre>"},{"location":"api/xr/#gradereport","title":"GradeReport","text":"<p>Session grade report.</p> <pre><code>struct GradeReport {\n    Grade overall_grade;\n    Real overall_score;\n    Real total_time;\n    std::vector&lt;ScoringCriteria&gt; criteria;\n    std::vector&lt;TrainingObjective&gt; objectives;\n    std::vector&lt;TrainingEvent&gt; significant_events;\n    std::string instructor_comments;\n    std::vector&lt;std::string&gt; strengths;\n    std::vector&lt;std::string&gt; areas_for_improvement;\n    std::vector&lt;std::string&gt; recommendations;\n    bool is_passed;\n};\n</code></pre>"},{"location":"api/xr/#training-interfaces","title":"Training Interfaces","text":""},{"location":"api/xr/#icockpitmodule","title":"ICockpitModule","text":"<p>Cockpit simulator module interface.</p> <pre><code>class ICockpitModule : public ITrainingModule {\npublic:\n    // Instruments\n    virtual std::vector&lt;InstrumentState&gt; get_instruments() const = 0;\n    virtual std::optional&lt;InstrumentState&gt; get_instrument(InstrumentType type) const = 0;\n    virtual TrainingResult set_instrument_value(InstrumentType type, Real value) = 0;\n    virtual TrainingResult inject_instrument_failure(InstrumentType type) = 0;\n    virtual TrainingResult restore_instrument(InstrumentType type) = 0;\n\n    // Controls\n    virtual std::vector&lt;ControlState&gt; get_controls() const = 0;\n    virtual TrainingResult set_control_position(ControlType type, Real position) = 0;\n    virtual TrainingResult set_control_force(ControlType type, Real force) = 0;\n\n    // Flight state\n    virtual Real get_airspeed() const = 0;\n    virtual Real get_altitude() const = 0;\n    virtual Real get_heading() const = 0;\n    virtual Real get_vertical_speed() const = 0;\n    virtual Vec3 get_attitude() const = 0;\n\n    // Procedures\n    virtual TrainingResult start_checklist(const std::string&amp; checklist_id) = 0;\n    virtual TrainingResult complete_checklist_item(UInt32 item_index) = 0;\n\n    // Integration\n    virtual void bind_xr_session(std::shared_ptr&lt;xr::IXRRuntime&gt; xr_runtime) = 0;\n    virtual void bind_haptics(std::shared_ptr&lt;haptics::IHapticRenderer&gt; haptics) = 0;\n    virtual void bind_audio(std::shared_ptr&lt;audio::ISpatialAudioRenderer&gt; audio) = 0;\n};\n</code></pre>"},{"location":"api/xr/#ibridgemodule","title":"IBridgeModule","text":"<p>Ship bridge simulator module interface.</p> <pre><code>class IBridgeModule : public ITrainingModule {\npublic:\n    // Stations\n    virtual std::vector&lt;BridgeStation&gt; get_available_stations() const = 0;\n    virtual TrainingResult select_station(BridgeStation station) = 0;\n    virtual BridgeStation get_current_station() const = 0;\n\n    // Navigation\n    virtual Real get_heading() const = 0;\n    virtual Real get_speed() const = 0;  // knots\n    virtual Real get_depth() const = 0;  // meters\n    virtual Vec3 get_position() const = 0;\n    virtual std::vector&lt;AircraftTrack&gt; get_radar_contacts() const = 0;\n\n    // Controls\n    virtual TrainingResult set_helm(Real angle) = 0;  // -35 to +35 degrees\n    virtual TrainingResult set_throttle(Real power) = 0;  // -1 to 1\n    virtual TrainingResult set_thruster(ShipControlType thruster, Real power) = 0;\n\n    // Equipment\n    virtual TrainingResult activate_radar() = 0;\n    virtual TrainingResult deactivate_radar() = 0;\n};\n</code></pre>"},{"location":"api/xr/#icontroltowermodule","title":"IControlTowerModule","text":"<p>Air traffic control tower module interface.</p> <pre><code>class IControlTowerModule : public ITrainingModule {\npublic:\n    // Position\n    virtual ATCPosition get_position() const = 0;\n    virtual TrainingResult set_position(ATCPosition position) = 0;\n\n    // Traffic\n    virtual std::vector&lt;AircraftTrack&gt; get_traffic() const = 0;\n    virtual std::optional&lt;AircraftTrack&gt; get_aircraft(const std::string&amp; callsign) const = 0;\n    virtual UInt32 get_traffic_count() const = 0;\n\n    // Runways\n    virtual std::vector&lt;RunwayStatus&gt; get_runways() const = 0;\n    virtual TrainingResult set_active_runway(const std::string&amp; designator) = 0;\n    virtual TrainingResult close_runway(const std::string&amp; designator) = 0;\n\n    // Communications\n    virtual TrainingResult transmit(const std::string&amp; message) = 0;\n    virtual std::vector&lt;std::string&gt; get_pending_readbacks() const = 0;\n    virtual TrainingResult verify_readback(const std::string&amp; callsign, bool correct) = 0;\n\n    // Instructions\n    virtual TrainingResult issue_clearance(const std::string&amp; callsign, const std::string&amp; clearance) = 0;\n    virtual TrainingResult issue_hold(const std::string&amp; callsign, const std::string&amp; fix) = 0;\n    virtual TrainingResult issue_approach(const std::string&amp; callsign, const std::string&amp; approach) = 0;\n\n    // Sequencing\n    virtual std::vector&lt;std::string&gt; get_departure_sequence() const = 0;\n    virtual std::vector&lt;std::string&gt; get_arrival_sequence() const = 0;\n    virtual TrainingResult resequence(const std::string&amp; callsign, UInt32 new_position) = 0;\n};\n</code></pre>"},{"location":"api/xr/#iafteractionreview","title":"IAfterActionReview","text":"<p>After-action review interface for recording and analyzing training sessions.</p> <pre><code>class IAfterActionReview {\npublic:\n    // Recording\n    virtual TrainingResult start_recording() = 0;\n    virtual TrainingResult stop_recording() = 0;\n    virtual TrainingResult add_bookmark(const std::string&amp; name) = 0;\n    virtual TrainingResult add_instructor_note(const std::string&amp; note) = 0;\n    virtual bool is_recording() const = 0;\n\n    // Events\n    virtual TrainingResult record_event(const TrainingEvent&amp; event) = 0;\n    virtual std::vector&lt;TrainingEvent&gt; get_events() const = 0;\n    virtual std::vector&lt;TrainingEvent&gt; get_events_in_range(Real start, Real end) const = 0;\n\n    // State recording\n    virtual TrainingResult record_state(const StateSnapshot&amp; snapshot) = 0;\n    virtual std::optional&lt;StateSnapshot&gt; get_state_at_time(Real time) const = 0;\n    virtual Real get_recording_duration() const = 0;\n\n    // Playback\n    virtual TrainingResult start_playback() = 0;\n    virtual TrainingResult pause_playback() = 0;\n    virtual TrainingResult stop_playback() = 0;\n    virtual TrainingResult seek(Real time) = 0;\n    virtual TrainingResult set_playback_speed(Real speed) = 0;\n    virtual PlaybackState get_playback_state() const = 0;\n\n    // Analysis\n    virtual GradeReport generate_grade_report() const = 0;\n    virtual std::vector&lt;TrainingEvent&gt; get_errors() const = 0;\n    virtual std::vector&lt;TrainingEvent&gt; get_excellent_performance() const = 0;\n\n    // Export\n    virtual TrainingResult export_to_file(const std::string&amp; filepath) = 0;\n    virtual TrainingResult import_from_file(const std::string&amp; filepath) = 0;\n};\n</code></pre>"},{"location":"api/xr/#iscenarioengine","title":"IScenarioEngine","text":"<p>Scenario engine interface for scripted training scenarios.</p> <pre><code>class IScenarioEngine {\npublic:\n    // Scenario management\n    virtual TrainingResult load_scenario(const ScenarioDefinition&amp; scenario) = 0;\n    virtual TrainingResult load_scenario_from_file(const std::string&amp; filepath) = 0;\n    virtual TrainingResult unload_scenario() = 0;\n    virtual std::optional&lt;ScenarioDefinition&gt; get_current_scenario() const = 0;\n    virtual bool is_scenario_loaded() const = 0;\n\n    // Execution\n    virtual TrainingResult start_scenario() = 0;\n    virtual TrainingResult pause_scenario() = 0;\n    virtual TrainingResult resume_scenario() = 0;\n    virtual TrainingResult stop_scenario() = 0;\n    virtual TrainingResult reset_scenario() = 0;\n    virtual bool is_running() const = 0;\n\n    // Objectives\n    virtual std::vector&lt;TrainingObjective&gt; get_objectives() const = 0;\n    virtual std::optional&lt;TrainingObjective&gt; get_current_objective() const = 0;\n    virtual TrainingResult complete_objective(UInt32 objective_id) = 0;\n    virtual TrainingResult fail_objective(UInt32 objective_id, const std::string&amp; reason) = 0;\n    virtual TrainingResult skip_objective(UInt32 objective_id) = 0;\n\n    // Rules\n    virtual TrainingResult add_rule(const ScriptRule&amp; rule) = 0;\n    virtual TrainingResult remove_rule(UInt32 rule_id) = 0;\n    virtual TrainingResult enable_rule(UInt32 rule_id) = 0;\n    virtual TrainingResult disable_rule(UInt32 rule_id) = 0;\n\n    // Triggers\n    virtual TrainingResult fire_trigger(UInt32 trigger_id) = 0;\n    virtual TrainingResult evaluate_triggers() = 0;\n    virtual TrainingResult execute_action(const ScriptAction&amp; action) = 0;\n\n    // Checkpoints\n    virtual std::vector&lt;std::string&gt; get_checkpoints() const = 0;\n    virtual TrainingResult jump_to_checkpoint(const std::string&amp; checkpoint_id) = 0;\n    virtual TrainingResult save_checkpoint(const std::string&amp; checkpoint_id) = 0;\n\n    // Update\n    virtual TrainingResult update(Real delta_time) = 0;\n};\n</code></pre>"},{"location":"api/xr/#itrainingsession","title":"ITrainingSession","text":"<p>Training session interface that orchestrates all training modules.</p> <pre><code>class ITrainingSession {\npublic:\n    // Session lifecycle\n    virtual TrainingResult create_session(const std::string&amp; trainee_id, TrainingDomain domain) = 0;\n    virtual TrainingResult start_session() = 0;\n    virtual TrainingResult pause_session() = 0;\n    virtual TrainingResult resume_session() = 0;\n    virtual TrainingResult end_session() = 0;\n    virtual bool is_active() const = 0;\n    virtual Real get_session_time() const = 0;\n\n    // Modules\n    virtual std::shared_ptr&lt;ICockpitModule&gt; get_cockpit_module() = 0;\n    virtual std::shared_ptr&lt;IBridgeModule&gt; get_bridge_module() = 0;\n    virtual std::shared_ptr&lt;IControlTowerModule&gt; get_tower_module() = 0;\n    virtual std::shared_ptr&lt;IAfterActionReview&gt; get_aar() = 0;\n    virtual std::shared_ptr&lt;IScenarioEngine&gt; get_scenario_engine() = 0;\n\n    // Configuration\n    virtual TrainingResult set_difficulty(DifficultyLevel level) = 0;\n    virtual DifficultyLevel get_difficulty() const = 0;\n    virtual TrainingResult set_weather(WeatherPreset weather) = 0;\n    virtual TrainingResult set_time_of_day(TimeOfDay time) = 0;\n\n    // Statistics\n    virtual UInt32 get_total_objectives() const = 0;\n    virtual UInt32 get_completed_objectives() const = 0;\n    virtual Real get_current_score() const = 0;\n\n    // Update\n    virtual TrainingResult update(Real delta_time) = 0;\n};\n</code></pre>"},{"location":"api/xr/#training-factory-functions","title":"Training Factory Functions","text":"<pre><code>// Cockpit modules\nstd::unique_ptr&lt;ICockpitModule&gt; create_cockpit_module(const std::string&amp; aircraft_type);\nstd::unique_ptr&lt;ICockpitModule&gt; create_generic_cockpit_module();\n\n// Bridge modules\nstd::unique_ptr&lt;IBridgeModule&gt; create_bridge_module(const std::string&amp; ship_type);\nstd::unique_ptr&lt;IBridgeModule&gt; create_generic_bridge_module();\n\n// Control tower module\nstd::unique_ptr&lt;IControlTowerModule&gt; create_tower_module(const std::string&amp; airport_icao);\n\n// After-action review\nstd::unique_ptr&lt;IAfterActionReview&gt; create_aar();\n\n// Scenario engine\nstd::unique_ptr&lt;IScenarioEngine&gt; create_scenario_engine();\n\n// Training session\nstd::unique_ptr&lt;ITrainingSession&gt; create_training_session();\nstd::unique_ptr&lt;ITrainingSession&gt; create_mock_training_session();\n</code></pre>"},{"location":"api/xr/#training-usage-example","title":"Training Usage Example","text":"<pre><code>using namespace jaguar::training;\n\n// Create and configure training session\nauto session = create_training_session();\nsession-&gt;create_session(\"pilot_001\", TrainingDomain::Aviation);\nsession-&gt;set_difficulty(DifficultyLevel::Intermediate);\nsession-&gt;set_weather(WeatherPreset::Clear);\nsession-&gt;set_time_of_day(TimeOfDay::Morning);\n\n// Start session\nsession-&gt;start_session();\n\n// Get domain-specific module\nauto cockpit = session-&gt;get_cockpit_module();\nauto aar = session-&gt;get_aar();\nauto scenario = session-&gt;get_scenario_engine();\n\n// Create and load a scenario\nScenarioDefinition scenario_def;\nscenario_def.id = \"basic_flight\";\nscenario_def.name = \"Basic Flight Training\";\nscenario_def.domain = TrainingDomain::Aviation;\n\nTrainingObjective takeoff_obj;\ntakeoff_obj.id = 1;\ntakeoff_obj.type = ObjectiveType::Takeoff;\ntakeoff_obj.name = \"Complete Takeoff\";\ntakeoff_obj.is_mandatory = true;\nscenario_def.objectives.push_back(takeoff_obj);\n\nscenario-&gt;load_scenario(scenario_def);\nscenario-&gt;start_scenario();\n\n// Main training loop\nwhile (session-&gt;is_active()) {\n    // Update control inputs (from XR controllers or physical controls)\n    cockpit-&gt;set_control_position(ControlType::Throttle, throttle_input);\n    cockpit-&gt;set_control_position(ControlType::Yoke, yoke_pitch);\n\n    // Get flight state for visualization\n    Real airspeed = cockpit-&gt;get_airspeed();\n    Real altitude = cockpit-&gt;get_altitude();\n    Vec3 attitude = cockpit-&gt;get_attitude();\n\n    // Check for stall conditions\n    if (airspeed &lt; 60) {\n        TrainingEvent stall_warning;\n        stall_warning.type = TrainingEventType::Stall;\n        stall_warning.name = \"Approaching stall\";\n        stall_warning.severity = 0.8;\n        aar-&gt;record_event(stall_warning);\n    }\n\n    // Update session (handles modules, scenarios, recording)\n    session-&gt;update(delta_time);\n\n    // Check for objective completion\n    if (altitude &gt; 1000 &amp;&amp; !takeoff_completed) {\n        scenario-&gt;complete_objective(1);\n        takeoff_completed = true;\n    }\n}\n\n// End session\nsession-&gt;end_session();\n\n// Generate grade report\nGradeReport report = aar-&gt;generate_grade_report();\nstd::cout &lt;&lt; \"Overall Score: \" &lt;&lt; report.overall_score &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Grade: \" &lt;&lt; static_cast&lt;int&gt;(report.overall_grade) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Passed: \" &lt;&lt; (report.is_passed ? \"Yes\" : \"No\") &lt;&lt; std::endl;\n\nfor (const auto&amp; area : report.areas_for_improvement) {\n    std::cout &lt;&lt; \"Improve: \" &lt;&lt; area &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"api/xr/#see-also","title":"See Also","text":"<ul> <li>XR Session Header</li> <li>XR Types Header</li> <li>Spatial Audio Header</li> <li>Haptics Header</li> <li>Training Header</li> <li>XR Events Header</li> </ul>"},{"location":"concepts/coordinates/","title":"Coordinate Systems","text":"<p>JaguarEngine supports multiple coordinate frames for different applications. This guide covers coordinate systems, transformations, and conventions.</p>"},{"location":"concepts/coordinates/#supported-frames","title":"Supported Frames","text":"Frame Origin Axes Use Case ECEF Earth center Earth-fixed Global positioning ECI J2000 Earth center Inertial Orbital mechanics NED Local origin North-East-Down Aircraft, vehicles ENU Local origin East-North-Up Visualization Body Entity CG Entity-specific Local calculations"},{"location":"concepts/coordinates/#ecef-earth-centered-earth-fixed","title":"ECEF (Earth-Centered Earth-Fixed)","text":""},{"location":"concepts/coordinates/#definition","title":"Definition","text":"<ul> <li>Origin: Earth's center of mass</li> <li>X-axis: Through prime meridian at equator</li> <li>Y-axis: Through 90\u00b0E longitude at equator</li> <li>Z-axis: Through North Pole</li> </ul>"},{"location":"concepts/coordinates/#usage","title":"Usage","text":"<pre><code>// ECEF is the default frame in JaguarEngine\nVec3 position_ecef{6378137.0, 0.0, 0.0};  // On equator at prime meridian\n\n// Entity positions are stored in ECEF\nauto state = engine.get_entity_state(entity);\nVec3 ecef_pos = state.position;  // ECEF meters\n</code></pre>"},{"location":"concepts/coordinates/#advantages","title":"Advantages","text":"<ul> <li>Global reference frame</li> <li>No singularities</li> <li>Direct geodetic conversion</li> </ul>"},{"location":"concepts/coordinates/#eci-earth-centered-inertial","title":"ECI (Earth-Centered Inertial)","text":""},{"location":"concepts/coordinates/#definition_1","title":"Definition","text":"<ul> <li>Origin: Earth's center of mass</li> <li>X-axis: Toward vernal equinox (J2000)</li> <li>Y-axis: Completes right-hand system</li> <li>Z-axis: Toward North celestial pole</li> </ul>"},{"location":"concepts/coordinates/#usage_1","title":"Usage","text":"<pre><code>using namespace jaguar::transforms;\n\n// Convert ECI to ECEF\nVec3 pos_eci{6878000.0, 0.0, 0.0};\nReal julian_date = 2451545.0;  // J2000 epoch\nVec3 pos_ecef = eci_to_ecef(pos_eci, julian_date);\n\n// Convert ECEF to ECI\nVec3 pos_eci_back = ecef_to_eci(pos_ecef, julian_date);\n</code></pre>"},{"location":"concepts/coordinates/#space-domain","title":"Space Domain","text":"<pre><code>// SGP4 outputs ECI coordinates\nSGP4Propagator sgp4;\nsgp4.initialize(tle);\n\nVec3 pos_eci, vel_eci;\nsgp4.propagate(minutes, pos_eci, vel_eci);\n</code></pre>"},{"location":"concepts/coordinates/#ned-north-east-down","title":"NED (North-East-Down)","text":""},{"location":"concepts/coordinates/#definition_2","title":"Definition","text":"<ul> <li>Origin: Local reference point</li> <li>X-axis: True North</li> <li>Y-axis: True East</li> <li>Z-axis: Down (toward Earth center)</li> </ul>"},{"location":"concepts/coordinates/#usage_2","title":"Usage","text":"<pre><code>// Aircraft state often expressed in NED\n// Position: relative to local origin\n// Velocity: NED components\n\n// NED velocity example\nVec3 vel_ned{200.0, 0.0, -10.0};  // 200 m/s North, 10 m/s descent\n</code></pre>"},{"location":"concepts/coordinates/#air-domain-conventions","title":"Air Domain Conventions","text":"<p>In the Air domain, positions are often NED: - Positive X = North - Positive Y = East - Positive Z = Down (altitude is -Z)</p> <pre><code>// Altitude from NED position\nReal altitude = -state.position.z;\n</code></pre>"},{"location":"concepts/coordinates/#body-frame","title":"Body Frame","text":""},{"location":"concepts/coordinates/#definition_3","title":"Definition","text":"<ul> <li>Origin: Entity center of gravity (CG)</li> <li>X-axis: Forward</li> <li>Y-axis: Right</li> <li>Z-axis: Down</li> </ul>"},{"location":"concepts/coordinates/#domain-conventions","title":"Domain Conventions","text":"Domain X (Forward) Y (Right) Z (Down) Air Nose Starboard wing Belly Land Vehicle front Passenger side Ground Sea Bow Starboard Keel Space Primary thrust Secondary Nadir"},{"location":"concepts/coordinates/#body-to-ecef-transformation","title":"Body-to-ECEF Transformation","text":"<pre><code>// Orientation quaternion transforms body to ECEF\nQuaternion q = state.orientation;\n\n// Transform body vector to ECEF\nVec3 body_vec{1.0, 0.0, 0.0};  // Forward direction\nVec3 ecef_vec = q.rotate(body_vec);\n\n// Get rotation matrix\nMat3x3 dcm = q.to_rotation_matrix();\n</code></pre>"},{"location":"concepts/coordinates/#geodetic-coordinates","title":"Geodetic Coordinates","text":""},{"location":"concepts/coordinates/#definition_4","title":"Definition","text":"<ul> <li>Latitude: Angle from equatorial plane (-90\u00b0 to +90\u00b0)</li> <li>Longitude: Angle from prime meridian (-180\u00b0 to +180\u00b0)</li> <li>Altitude: Height above WGS84 ellipsoid</li> </ul>"},{"location":"concepts/coordinates/#conversions","title":"Conversions","text":"<pre><code>using namespace jaguar::transforms;\n\n// ECEF to Geodetic\nVec3 ecef{6378137.0, 0.0, 0.0};\nReal lat, lon, alt;\necef_to_geodetic(ecef, lat, lon, alt);\n// lat = 0, lon = 0, alt = 0\n\n// Geodetic to ECEF\nReal lat_rad = 37.0 * DEG_TO_RAD;\nReal lon_rad = -122.0 * DEG_TO_RAD;\nReal alt_m = 100.0;\nVec3 ecef_out = geodetic_to_ecef(lat_rad, lon_rad, alt_m);\n</code></pre>"},{"location":"concepts/coordinates/#euler-angles","title":"Euler Angles","text":""},{"location":"concepts/coordinates/#convention","title":"Convention","text":"<p>JaguarEngine uses aerospace Euler angles (3-2-1 rotation order):</p> <ol> <li>Yaw (\u03c8): Rotation about Z-axis</li> <li>Pitch (\u03b8): Rotation about Y-axis</li> <li>Roll (\u03c6): Rotation about X-axis</li> </ol>"},{"location":"concepts/coordinates/#usage_3","title":"Usage","text":"<pre><code>// Create quaternion from Euler angles\nReal roll = 10.0 * DEG_TO_RAD;\nReal pitch = 5.0 * DEG_TO_RAD;\nReal yaw = 45.0 * DEG_TO_RAD;\nQuaternion q = Quaternion::from_euler(roll, pitch, yaw);\n\n// Extract Euler angles from quaternion\nReal roll_out, pitch_out, yaw_out;\nq.to_euler(roll_out, pitch_out, yaw_out);\n\n// From entity state\nReal aircraft_roll = state.get_roll();\nReal aircraft_pitch = state.get_pitch();\nReal aircraft_yaw = state.get_yaw();\n</code></pre>"},{"location":"concepts/coordinates/#angular-rates","title":"Angular Rates","text":""},{"location":"concepts/coordinates/#body-frame-rates","title":"Body Frame Rates","text":"Symbol Axis Name p X Roll rate q Y Pitch rate r Z Yaw rate <pre><code>// Angular velocity is in body frame\nVec3 omega = state.angular_velocity;\nReal p = omega.x;  // Roll rate (rad/s)\nReal q = omega.y;  // Pitch rate (rad/s)\nReal r = omega.z;  // Yaw rate (rad/s)\n</code></pre>"},{"location":"concepts/coordinates/#quaternions","title":"Quaternions","text":""},{"location":"concepts/coordinates/#operations","title":"Operations","text":"<pre><code>// Create identity quaternion\nQuaternion q = Quaternion::identity();\n\n// From axis-angle\nVec3 axis{0.0, 0.0, 1.0};  // Z-axis\nReal angle = 45.0 * DEG_TO_RAD;\nQuaternion q = Quaternion::from_axis_angle(axis, angle);\n\n// Quaternion multiplication (composition)\nQuaternion q3 = q1 * q2;  // Apply q2, then q1\n\n// Rotate a vector\nVec3 v_rotated = q.rotate(v);\n\n// Inverse rotation\nVec3 v_original = q.conjugate().rotate(v_rotated);\n\n// Normalize (maintain unit quaternion)\nq = q.normalized();\n</code></pre>"},{"location":"concepts/coordinates/#integration","title":"Integration","text":"<pre><code>// Quaternion derivative\n// q_dot = 0.5 * q * omega_quat\nQuaternion omega_quat{0, omega.x, omega.y, omega.z};\nQuaternion q_dot = q * omega_quat * 0.5;\n\n// Integration step\nq = (q + q_dot * dt).normalized();\n</code></pre>"},{"location":"concepts/coordinates/#time-systems","title":"Time Systems","text":""},{"location":"concepts/coordinates/#julian-date","title":"Julian Date","text":"<pre><code>// Greenwich Mean Sidereal Time\nReal jd = 2451545.0;  // J2000 epoch\nReal gmst = transforms::greenwich_sidereal_time(jd);\n</code></pre>"},{"location":"concepts/coordinates/#simulation-time","title":"Simulation Time","text":"<pre><code>// Get current simulation time\nReal sim_time = engine.get_time();\n\n// Set simulation time\nengine.set_time(0.0);\n</code></pre>"},{"location":"concepts/coordinates/#best-practices","title":"Best Practices","text":""},{"location":"concepts/coordinates/#coordinate-consistency","title":"Coordinate Consistency","text":"<ol> <li>Document frame: Always specify which frame data is in</li> <li>Transform early: Convert to working frame at input</li> <li>Transform late: Convert to output frame only when needed</li> </ol>"},{"location":"concepts/coordinates/#numerical-precision","title":"Numerical Precision","text":"<ol> <li>Use double precision: Essential for geodetic calculations</li> <li>Normalize quaternions: Prevent drift in orientation</li> <li>Avoid singularities: Use quaternions instead of Euler angles for integration</li> </ol>"},{"location":"concepts/coordinates/#common-pitfalls","title":"Common Pitfalls","text":"<ul> <li>Forgetting frame: Mixing ECEF and NED positions</li> <li>Sign conventions: Down is positive Z in NED</li> <li>Angular units: Radians vs degrees</li> <li>Rotation order: Euler angle convention matters</li> </ul>"},{"location":"concepts/coordinates/#see-also","title":"See Also","text":"<ul> <li>Entities - Entity state management</li> <li>API Reference - Core types and math</li> <li>Space Domain - Orbital coordinate frames</li> </ul>"},{"location":"concepts/entities/","title":"Entities","text":"<p>Entities are the fundamental simulation objects in JaguarEngine. This guide covers entity creation, management, and state handling.</p>"},{"location":"concepts/entities/#what-is-an-entity","title":"What is an Entity?","text":"<p>An entity represents any simulated object in JaguarEngine:</p> <ul> <li>Aircraft: Fixed-wing, rotary-wing, missiles</li> <li>Ground Vehicles: Tanks, APCs, wheeled vehicles</li> <li>Naval Vessels: Surface ships, submarines</li> <li>Spacecraft: Satellites, space stations, launch vehicles</li> <li>Generic: Custom simulation objects</li> </ul>"},{"location":"concepts/entities/#entity-architecture","title":"Entity Architecture","text":"<p>Entities use a lightweight ID-based design:</p> <pre><code>struct Entity {\n    EntityId id;              // Unique identifier\n    ComponentMask components; // Bitfield of attached components\n    Domain primary_domain;    // Primary physics domain\n    PropertyNode* properties; // Property tree root\n};\n</code></pre> <p>Key Design Principles:</p> <ol> <li>Entities are just identifiers (lightweight)</li> <li>Data lives in contiguous arrays (cache-friendly)</li> <li>Components define behavior and capabilities</li> <li>Properties enable runtime configuration</li> </ol>"},{"location":"concepts/entities/#creating-entities","title":"Creating Entities","text":""},{"location":"concepts/entities/#basic-creation","title":"Basic Creation","text":"<pre><code>#include &lt;jaguar/jaguar.h&gt;\n\nusing namespace jaguar;\n\nEngine engine;\nengine.initialize();\n\n// Create entities by domain\nEntityId aircraft = engine.create_entity(\"F16\", Domain::Air);\nEntityId tank = engine.create_entity(\"M1A2\", Domain::Land);\nEntityId ship = engine.create_entity(\"DDG51\", Domain::Sea);\nEntityId satellite = engine.create_entity(\"GPS\", Domain::Space);\n</code></pre>"},{"location":"concepts/entities/#from-configuration","title":"From Configuration","text":"<pre><code>// Load entity from XML configuration\nconfig::EntityConfig cfg = config::EntityConfig::load(\"aircraft/f16.xml\");\nEntityId aircraft = engine.create_entity_from_config(cfg);\n</code></pre>"},{"location":"concepts/entities/#entity-state","title":"Entity State","text":""},{"location":"concepts/entities/#entitystate-structure","title":"EntityState Structure","text":"<pre><code>struct EntityState {\n    Vec3 position{0, 0, 0};           // Position (m)\n    Vec3 velocity{0, 0, 0};           // Velocity (m/s)\n    Quaternion orientation;            // Attitude quaternion\n    Vec3 angular_velocity{0, 0, 0};   // Angular velocity (rad/s)\n    Real mass{1.0};                   // Mass (kg)\n    Mat3x3 inertia;                   // Inertia tensor (kg\u00b7m\u00b2)\n};\n</code></pre>"},{"location":"concepts/entities/#getting-and-setting-state","title":"Getting and Setting State","text":"<pre><code>// Get current state\nphysics::EntityState state = engine.get_entity_state(aircraft);\n\n// Modify state\nstate.position = Vec3{1000.0, 0.0, -5000.0};\nstate.velocity = Vec3{200.0, 0.0, 0.0};\nstate.mass = 15000.0;\n\n// Update entity\nengine.set_entity_state(aircraft, state);\n</code></pre>"},{"location":"concepts/entities/#derived-quantities","title":"Derived Quantities","text":"<pre><code>// Get Euler angles from state\nReal roll = state.get_roll();\nReal pitch = state.get_pitch();\nReal yaw = state.get_yaw();\n\n// Or as a vector\nVec3 euler = state.get_euler_angles();\n\n// Get rotation matrix\nMat3x3 dcm = state.get_rotation_matrix();\n</code></pre>"},{"location":"concepts/entities/#entity-domains","title":"Entity Domains","text":""},{"location":"concepts/entities/#domain-types","title":"Domain Types","text":"<pre><code>enum class Domain : UInt8 {\n    Generic = 0,  // Custom/unspecified\n    Air = 1,      // Aircraft, missiles\n    Land = 2,     // Ground vehicles\n    Sea = 3,      // Ships, submarines\n    Space = 4     // Satellites, spacecraft\n};\n</code></pre>"},{"location":"concepts/entities/#domain-specific-behavior","title":"Domain-Specific Behavior","text":"<p>Each domain has specialized physics models:</p> Domain Physics Models Air Aerodynamics, Propulsion, FCS Land Terramechanics, Suspension Sea Hydrodynamics, Buoyancy, RAO Space Gravity, Drag, SGP4"},{"location":"concepts/entities/#entity-management","title":"Entity Management","text":""},{"location":"concepts/entities/#querying-entities","title":"Querying Entities","text":"<pre><code>// Check if entity exists\nbool exists = engine.entity_exists(aircraft);\n\n// Get entity count\nSizeT count = engine.entity_count();\n\n// Get all entities\nstd::vector&lt;EntityId&gt; all = engine.get_all_entities();\n\n// Get entities by domain\nstd::vector&lt;EntityId&gt; aircraft_list = engine.get_entities_by_domain(Domain::Air);\n</code></pre>"},{"location":"concepts/entities/#destroying-entities","title":"Destroying Entities","text":"<pre><code>// Remove entity from simulation\nengine.destroy_entity(aircraft);\n</code></pre>"},{"location":"concepts/entities/#entity-forces","title":"Entity Forces","text":""},{"location":"concepts/entities/#applying-forces","title":"Applying Forces","text":"<pre><code>physics::EntityForces forces;\nforces.clear();\n\n// Add force at CG\nforces.add_force(Vec3{1000.0, 0.0, 0.0});  // 1000 N forward\n\n// Add torque\nforces.add_torque(Vec3{0.0, 500.0, 0.0});  // 500 N\u00b7m pitch\n\n// Add force at specific point (creates torque)\nVec3 force = Vec3{0.0, 0.0, -1000.0};  // Lift\nVec3 point = Vec3{2.0, 0.0, 0.0};       // Point ahead of CG\nVec3 cg = Vec3{0.0, 0.0, 0.0};          // CG position\nforces.add_force_at_point(force, point, cg);\n\n// Apply to entity\nengine.apply_forces(aircraft, forces);\n</code></pre>"},{"location":"concepts/entities/#entity-environment","title":"Entity Environment","text":""},{"location":"concepts/entities/#getting-environment-data","title":"Getting Environment Data","text":"<pre><code>// Get environment at entity location\nenvironment::Environment env = engine.get_environment(aircraft);\n\n// Access atmospheric data\nReal density = env.atmosphere.density;\nReal temperature = env.atmosphere.temperature;\nReal wind_x = env.atmosphere.wind.x;\n\n// Access terrain data\nReal terrain_elevation = env.terrain_elevation;\nVec3 surface_normal = env.terrain.normal;\n\n// Access ocean data (if over water)\nif (env.over_water) {\n    Real wave_height = env.ocean.surface_elevation;\n    Real water_density = env.ocean.density;\n}\n</code></pre>"},{"location":"concepts/entities/#best-practices","title":"Best Practices","text":""},{"location":"concepts/entities/#entity-lifecycle","title":"Entity Lifecycle","text":"<ol> <li>Create entities before simulation starts</li> <li>Initialize state with valid values</li> <li>Update state through forces, not direct modification</li> <li>Query state for telemetry and logging</li> <li>Destroy entities when no longer needed</li> </ol>"},{"location":"concepts/entities/#performance-tips","title":"Performance Tips","text":"<ol> <li>Batch operations: Create/destroy entities in groups</li> <li>Cache IDs: Store EntityId rather than looking up repeatedly</li> <li>Use domains: Proper domain assignment enables optimized physics</li> </ol>"},{"location":"concepts/entities/#common-patterns","title":"Common Patterns","text":"<pre><code>// Entity with initial conditions\nEntityId create_aircraft(Engine&amp; engine, const Vec3&amp; position, Real heading) {\n    EntityId id = engine.create_entity(\"Aircraft\", Domain::Air);\n\n    physics::EntityState state;\n    state.position = position;\n    state.velocity = Vec3{200.0, 0.0, 0.0};  // Forward velocity\n    state.orientation = Quaternion::from_euler(0.0, 0.0, heading);\n    state.mass = 15000.0;\n    engine.set_entity_state(id, state);\n\n    return id;\n}\n</code></pre>"},{"location":"concepts/entities/#see-also","title":"See Also","text":"<ul> <li>Force Generators - Physics models</li> <li>Environment - Environmental services</li> <li>Coordinates - Coordinate systems</li> <li>API Reference - Complete API</li> </ul>"},{"location":"concepts/environment/","title":"Environment","text":"<p>The Environment system provides atmospheric, terrain, and ocean data for physics calculations. This guide covers environmental services and queries.</p>"},{"location":"concepts/environment/#overview","title":"Overview","text":"<p>JaguarEngine's environment system includes:</p> <ul> <li>Atmosphere: Temperature, pressure, density, wind</li> <li>Terrain: Elevation, surface normals, soil types</li> <li>Ocean: Waves, currents, sea state</li> </ul>"},{"location":"concepts/environment/#environment-structure","title":"Environment Structure","text":"<pre><code>struct Environment {\n    Real latitude{0.0};            // rad\n    Real longitude{0.0};           // rad\n    Real altitude{0.0};            // m above WGS84\n\n    AtmosphereState atmosphere;\n    TerrainQuery terrain;\n    Real terrain_elevation{0.0};\n    OceanState ocean;\n    bool over_water{false};\n    Vec3 gravity{0, 0, 9.80665};\n};\n</code></pre>"},{"location":"concepts/environment/#atmosphere","title":"Atmosphere","text":""},{"location":"concepts/environment/#atmosphere-state","title":"Atmosphere State","text":"<pre><code>struct AtmosphereState {\n    Real temperature{288.15};      // K\n    Real pressure{101325.0};       // Pa\n    Real density{1.225};           // kg/m\u00b3\n    Real speed_of_sound{340.29};   // m/s\n    Real viscosity{1.789e-5};      // Pa\u00b7s\n    Vec3 wind{0, 0, 0};            // m/s (NED)\n    Real humidity{0.0};            // 0-1\n    Real visibility{10000.0};      // m\n};\n</code></pre>"},{"location":"concepts/environment/#standard-atmosphere-us-std-1976","title":"Standard Atmosphere (US Std 1976)","text":"Altitude (km) Temperature (K) Pressure (Pa) Density (kg/m\u00b3) 0 288.15 101325 1.225 11 216.65 22632 0.3639 20 216.65 5474.9 0.0880 32 228.65 868.02 0.0132"},{"location":"concepts/environment/#using-atmosphere-data","title":"Using Atmosphere Data","text":"<pre><code>// Get environment at entity location\nauto env = engine.get_environment(aircraft);\n\n// Access atmosphere\nReal density = env.atmosphere.density;\nReal mach = airspeed / env.atmosphere.speed_of_sound;\nReal dynamic_pressure = 0.5 * density * airspeed * airspeed;\n\n// Wind components (NED)\nVec3 wind = env.atmosphere.wind;\n</code></pre>"},{"location":"concepts/environment/#weather-effects","title":"Weather Effects","text":"<pre><code>// Access weather model\nauto&amp; atm_mgr = engine.get_environment_service().atmosphere();\n\n// Set wind layer\natm_mgr.weather().set_wind_layer(\n    5000.0,                    // altitude (m)\n    45.0 * DEG_TO_RAD,        // direction (from)\n    15.0                       // speed (m/s)\n);\n\n// Set rain/fog\natm_mgr.weather().set_rain_rate(10.0);        // mm/hour\natm_mgr.weather().set_fog_visibility(1000.0); // m\n</code></pre>"},{"location":"concepts/environment/#terrain","title":"Terrain","text":""},{"location":"concepts/environment/#terrain-query","title":"Terrain Query","text":"<pre><code>struct TerrainQuery {\n    Real elevation{0.0};         // m above WGS84\n    Vec3 normal{0, 0, 1};        // Surface normal (NED)\n    Real slope_angle{0.0};       // rad\n    TerrainMaterial material;\n    bool valid{false};\n};\n</code></pre>"},{"location":"concepts/environment/#querying-terrain","title":"Querying Terrain","text":"<pre><code>auto&amp; terrain_mgr = engine.get_environment_service().terrain();\n\n// Get elevation at position\nReal elev = terrain_mgr.get_elevation(latitude, longitude);\n\n// Get surface normal\nVec3 normal = terrain_mgr.get_surface_normal(latitude, longitude);\n\n// Get slope angle\nReal slope = terrain_mgr.get_slope_angle(latitude, longitude);\n\n// Full query\nTerrainQuery query = terrain_mgr.query(latitude, longitude);\nif (query.valid) {\n    // Use terrain data\n}\n</code></pre>"},{"location":"concepts/environment/#terrain-data-sources","title":"Terrain Data Sources","text":"Format Description Resolution DTED Level 0 30 arc-sec ~900m DTED Level 1 3 arc-sec ~90m DTED Level 2 1 arc-sec ~30m GeoTIFF Custom DEM Variable"},{"location":"concepts/environment/#terrain-configuration","title":"Terrain Configuration","text":"<pre><code>&lt;terrain enabled=\"true\"&gt;\n    &lt;cache_mb&gt;2048&lt;/cache_mb&gt;\n    &lt;tile_size&gt;256&lt;/tile_size&gt;\n    &lt;data_path&gt;/data/dted/&lt;/data_path&gt;\n    &lt;data_path&gt;/data/srtm/&lt;/data_path&gt;\n&lt;/terrain&gt;\n</code></pre>"},{"location":"concepts/environment/#terrain-materials","title":"Terrain Materials","text":"<p>Soil properties for terramechanics:</p> <pre><code>// Get material at position\nTerrainMaterial mat = terrain_mgr.get_material(lat, lon);\n\n// Access soil properties\nSoilProperties soil = mat.get_soil_properties();\nReal friction = soil.get_friction_coefficient();\n</code></pre>"},{"location":"concepts/environment/#ocean","title":"Ocean","text":""},{"location":"concepts/environment/#ocean-state","title":"Ocean State","text":"<pre><code>struct OceanState {\n    Real water_depth{1000.0};      // m\n    Real surface_elevation{0.0};   // m\n    Vec3 current{0, 0, 0};         // m/s\n    Real temperature{15.0};        // \u00b0C\n    Real salinity{35.0};           // ppt\n    Real density{1025.0};          // kg/m\u00b3\n};\n</code></pre>"},{"location":"concepts/environment/#sea-state-configuration","title":"Sea State Configuration","text":"<pre><code>// Set sea conditions\nauto&amp; ocean_mgr = engine.get_environment_service().ocean();\n\ndomain::sea::SeaState sea_state;\nsea_state.significant_height = 3.0;  // m\nsea_state.peak_period = 9.0;         // s\nsea_state.direction = 45.0 * DEG_TO_RAD;  // from NE\nsea_state.spectrum = WaveSpectrum::JONSWAP;\n\nocean_mgr.set_sea_state(sea_state);\n</code></pre>"},{"location":"concepts/environment/#wave-queries","title":"Wave Queries","text":"<pre><code>// Get wave elevation\nReal elevation = ocean_mgr.get_wave_elevation(x, y, time);\n\n// Get wave slope\nVec3 slope = ocean_mgr.get_wave_slope(x, y, time);\n\n// Get particle velocity (for submerged objects)\nVec3 vel = ocean_mgr.get_particle_velocity(x, y, z, time);\n</code></pre>"},{"location":"concepts/environment/#ocean-currents","title":"Ocean Currents","text":"<pre><code>// Set uniform current\nocean_mgr.set_current(Vec3{0.5, 0.0, 0.0});  // 0.5 m/s east\n\n// Query current at depth\nVec3 current = ocean_mgr.get_current(lat, lon, depth);\n</code></pre>"},{"location":"concepts/environment/#environment-service","title":"Environment Service","text":""},{"location":"concepts/environment/#initialization","title":"Initialization","text":"<pre><code>// Access environment service\nauto&amp; env_service = engine.get_environment_service();\n\n// Initialize (called automatically by engine)\nenv_service.initialize();\n\n// Update environment state\nenv_service.update(dt);\n</code></pre>"},{"location":"concepts/environment/#querying-by-position","title":"Querying by Position","text":"<pre><code>// Query at ECEF position\nVec3 ecef_pos{6378137.0, 0.0, 0.0};\nEnvironment env = env_service.query(ecef_pos, time);\n\n// Query at geodetic position\nEnvironment env = env_service.query_geodetic(\n    lat, lon, alt, time\n);\n</code></pre>"},{"location":"concepts/environment/#performance-optimization","title":"Performance Optimization","text":"<pre><code>// Set terrain focus for LOD\nauto&amp; terrain = env_service.terrain();\nterrain.set_focus_point(camera_ecef);\nterrain.set_detail_radius(50000.0);  // 50 km high detail\n\n// Monitor cache usage\nSizeT tiles = terrain.loaded_tile_count();\nSizeT bytes = terrain.cache_usage_bytes();\n</code></pre>"},{"location":"concepts/environment/#configuration","title":"Configuration","text":""},{"location":"concepts/environment/#engine-configuration","title":"Engine Configuration","text":"<pre><code>&lt;engine_config&gt;\n    &lt;terrain enabled=\"true\"&gt;\n        &lt;cache_mb&gt;2048&lt;/cache_mb&gt;\n        &lt;data_path&gt;/data/terrain/&lt;/data_path&gt;\n    &lt;/terrain&gt;\n\n    &lt;atmosphere&gt;\n        &lt;model&gt;us_standard_1976&lt;/model&gt;\n        &lt;weather_enabled&gt;true&lt;/weather_enabled&gt;\n    &lt;/atmosphere&gt;\n\n    &lt;ocean enabled=\"true\"&gt;\n        &lt;default_sea_state&gt;4&lt;/default_sea_state&gt;\n    &lt;/ocean&gt;\n&lt;/engine_config&gt;\n</code></pre>"},{"location":"concepts/environment/#best-practices","title":"Best Practices","text":""},{"location":"concepts/environment/#environment-queries","title":"Environment Queries","text":"<ol> <li>Cache results: Don't query every frame if position hasn't changed</li> <li>Use entity queries: <code>get_environment(entity_id)</code> is optimized</li> <li>Batch queries: Group nearby position queries</li> </ol>"},{"location":"concepts/environment/#terrain-data","title":"Terrain Data","text":"<ol> <li>Set appropriate cache size: Larger cache = fewer disk reads</li> <li>Use focus point: Prioritize detail near areas of interest</li> <li>Match resolution to need: Use coarser data for distant entities</li> </ol>"},{"location":"concepts/environment/#weather-effects_1","title":"Weather Effects","text":"<ol> <li>Update gradually: Sudden weather changes can cause instabilities</li> <li>Consider performance: Complex weather adds computational cost</li> <li>Test edge cases: High winds, extreme temperatures</li> </ol>"},{"location":"concepts/environment/#see-also","title":"See Also","text":"<ul> <li>Entities - Entity management</li> <li>Force Generators - Physics models</li> <li>Configuration - Configuration options</li> <li>API Reference - Environment API</li> </ul>"},{"location":"concepts/force-generators/","title":"Force Generators","text":"<p>Force generators are the physics models that compute forces and moments acting on entities. This guide covers the force generator system and available models.</p>"},{"location":"concepts/force-generators/#overview","title":"Overview","text":"<p>Force generators implement the <code>IForceGenerator</code> interface:</p> <pre><code>class IForceGenerator {\npublic:\n    virtual void compute_forces(const EntityState&amp; state,\n                                const Environment&amp; env,\n                                Real dt,\n                                EntityForces&amp; forces) = 0;\n};\n</code></pre> <p>Each generator: 1. Receives entity state and environment data 2. Computes forces and moments 3. Accumulates results in the forces structure</p>"},{"location":"concepts/force-generators/#force-generator-categories","title":"Force Generator Categories","text":""},{"location":"concepts/force-generators/#by-domain","title":"By Domain","text":"Domain Force Generators Air Aerodynamics, Propulsion, Ground Reaction Land Terramechanics, Suspension, Tracked Vehicle Sea Buoyancy, Hydrodynamics, Wave Loading Space Gravity, Atmospheric Drag, Solar Radiation"},{"location":"concepts/force-generators/#by-physics-type","title":"By Physics Type","text":"Type Description Environmental Gravity, atmospheric forces Locomotion Propulsion, terramechanics Interaction Ground contact, collision Stability Buoyancy, aerodynamic damping"},{"location":"concepts/force-generators/#domain-specific-interfaces","title":"Domain-Specific Interfaces","text":""},{"location":"concepts/force-generators/#aerodynamics-air-domain","title":"Aerodynamics (Air Domain)","text":"<pre><code>class IAerodynamicsModel : public IForceGenerator {\npublic:\n    virtual Real get_cl() const = 0;    // Lift coefficient\n    virtual Real get_cd() const = 0;    // Drag coefficient\n    virtual Real get_cm() const = 0;    // Pitching moment\n    virtual Real get_alpha() const = 0; // Angle of attack (rad)\n    virtual Real get_beta() const = 0;  // Sideslip angle (rad)\n    virtual Real get_mach() const = 0;  // Mach number\n    virtual Real get_qbar() const = 0;  // Dynamic pressure (Pa)\n};\n</code></pre>"},{"location":"concepts/force-generators/#propulsion-air-domain","title":"Propulsion (Air Domain)","text":"<pre><code>class IPropulsionModel : public IForceGenerator {\npublic:\n    virtual Real get_thrust() const = 0;          // Current thrust (N)\n    virtual Real get_fuel_flow() const = 0;       // Fuel consumption (kg/s)\n    virtual Real get_fuel_remaining() const = 0;  // Remaining fuel (kg)\n    virtual bool is_running() const = 0;          // Engine status\n};\n</code></pre>"},{"location":"concepts/force-generators/#terramechanics-land-domain","title":"Terramechanics (Land Domain)","text":"<pre><code>class ITerramechanicsModel : public IForceGenerator {\npublic:\n    virtual Real get_sinkage() const = 0;           // Sinkage (m)\n    virtual Real get_motion_resistance() const = 0; // Resistance (N)\n    virtual Real get_traction() const = 0;          // Traction (N)\n    virtual Real get_slip_ratio() const = 0;        // Slip ratio\n};\n</code></pre>"},{"location":"concepts/force-generators/#hydrodynamics-sea-domain","title":"Hydrodynamics (Sea Domain)","text":"<pre><code>class IHydrodynamicsModel : public IForceGenerator {\npublic:\n    virtual Real get_buoyancy() const = 0;  // Buoyancy force (N)\n    virtual Real get_draft() const = 0;     // Draft (m)\n    virtual Real get_heel() const = 0;      // Roll angle (rad)\n    virtual Real get_trim() const = 0;      // Pitch angle (rad)\n};\n</code></pre>"},{"location":"concepts/force-generators/#using-force-generators","title":"Using Force Generators","text":""},{"location":"concepts/force-generators/#manual-force-computation","title":"Manual Force Computation","text":"<pre><code>// Create models\ndomain::air::AerodynamicsModel aero;\ndomain::air::PropulsionModel engine_model;\n\n// Configure\naero.set_reference_area(27.87);\naero.set_reference_chord(3.45);\nengine_model.set_max_thrust(130000.0);\n\n// In simulation loop\nphysics::EntityForces forces;\nforces.clear();\n\nauto state = engine.get_entity_state(aircraft);\nauto env = engine.get_environment(aircraft);\n\n// Compute forces from each model\naero.compute_forces(state, env, dt, forces);\nengine_model.compute_forces(state, env, dt, forces);\n\n// Add gravity\nforces.add_force(Vec3{0.0, 0.0, state.mass * constants::G0});\n\n// Apply accumulated forces\nengine.apply_forces(aircraft, forces);\n</code></pre>"},{"location":"concepts/force-generators/#force-accumulation","title":"Force Accumulation","text":"<p>The <code>EntityForces</code> structure accumulates all forces:</p> <pre><code>struct EntityForces {\n    Vec3 force{0, 0, 0};    // Total force (N)\n    Vec3 torque{0, 0, 0};   // Total torque (N\u00b7m)\n\n    void clear();\n    void add_force(const Vec3&amp; f);\n    void add_torque(const Vec3&amp; t);\n    void add_force_at_point(const Vec3&amp; f, const Vec3&amp; point, const Vec3&amp; cg);\n};\n</code></pre>"},{"location":"concepts/force-generators/#built-in-force-generators","title":"Built-in Force Generators","text":""},{"location":"concepts/force-generators/#air-domain","title":"Air Domain","text":"Model Description <code>AerodynamicsModel</code> Coefficient-based aerodynamics with table lookup <code>PropulsionModel</code> Turbofan/turbojet thrust with altitude-Mach correction <code>FlightControlSystem</code> Control surface mapping"},{"location":"concepts/force-generators/#land-domain","title":"Land Domain","text":"Model Description <code>TerramechanicsModel</code> Bekker-Wong soil-vehicle interaction <code>SuspensionModel</code> Multi-unit spring-damper system <code>TrackedVehicleModel</code> Track dynamics and propulsion"},{"location":"concepts/force-generators/#sea-domain","title":"Sea Domain","text":"Model Description <code>BuoyancyModel</code> Hydrostatic buoyancy with metacentric stability <code>HydrodynamicsModel</code> MMG maneuvering model <code>WaveModel</code> Wave spectrum generation <code>RAOModel</code> Ship motion response"},{"location":"concepts/force-generators/#space-domain","title":"Space Domain","text":"Model Description <code>GravityModel</code> Point mass to EGM2008 <code>AtmosphericDragModel</code> Drag with JB08 atmosphere <code>SGP4Propagator</code> TLE-based orbit propagation"},{"location":"concepts/force-generators/#force-generator-patterns","title":"Force Generator Patterns","text":""},{"location":"concepts/force-generators/#composite-force-generator","title":"Composite Force Generator","text":"<p>Combine multiple generators into one:</p> <pre><code>class CompositeForceGenerator : public IForceGenerator {\npublic:\n    void add_generator(std::unique_ptr&lt;IForceGenerator&gt; gen) {\n        generators_.push_back(std::move(gen));\n    }\n\n    void compute_forces(const EntityState&amp; state,\n                        const Environment&amp; env,\n                        Real dt,\n                        EntityForces&amp; forces) override {\n        for (auto&amp; gen : generators_) {\n            gen-&gt;compute_forces(state, env, dt, forces);\n        }\n    }\n\nprivate:\n    std::vector&lt;std::unique_ptr&lt;IForceGenerator&gt;&gt; generators_;\n};\n</code></pre>"},{"location":"concepts/force-generators/#conditional-force-generator","title":"Conditional Force Generator","text":"<p>Apply forces based on conditions:</p> <pre><code>class ConditionalDrag : public IForceGenerator {\npublic:\n    void compute_forces(const EntityState&amp; state,\n                        const Environment&amp; env,\n                        Real dt,\n                        EntityForces&amp; forces) override {\n        // Only apply drag above certain altitude\n        if (env.altitude &lt; 800000.0) {  // Below 800 km\n            drag_model_.compute_forces(state, env, dt, forces);\n        }\n    }\n\nprivate:\n    AtmosphericDragModel drag_model_;\n};\n</code></pre>"},{"location":"concepts/force-generators/#best-practices","title":"Best Practices","text":""},{"location":"concepts/force-generators/#force-computation-order","title":"Force Computation Order","text":"<ol> <li>Environmental forces (gravity, drag)</li> <li>Propulsion forces (thrust)</li> <li>Aerodynamic/Hydrodynamic forces</li> <li>Contact forces (ground, collision)</li> <li>Control forces (reactions, corrections)</li> </ol>"},{"location":"concepts/force-generators/#numerical-stability","title":"Numerical Stability","text":"<ul> <li>Set minimum velocity thresholds</li> <li>Clamp coefficient values</li> <li>Use appropriate time steps</li> <li>Apply forces in body frame when appropriate</li> </ul>"},{"location":"concepts/force-generators/#performance","title":"Performance","text":"<ul> <li>Cache intermediate calculations</li> <li>Reuse lookup tables</li> <li>Batch similar computations</li> <li>Profile hot paths</li> </ul>"},{"location":"concepts/force-generators/#see-also","title":"See Also","text":"<ul> <li>Entities - Entity management</li> <li>Integration - State propagation</li> <li>Custom Models - Creating custom generators</li> <li>API Reference - Physics API</li> </ul>"},{"location":"concepts/integration/","title":"Integration","text":"<p>JaguarEngine uses numerical integration to propagate entity states forward in time. This guide covers integrators, time stepping, and state propagation.</p>"},{"location":"concepts/integration/#overview","title":"Overview","text":"<p>The integration process:</p> <ol> <li>Compute forces and moments on entity</li> <li>Calculate accelerations from Newton's laws</li> <li>Integrate accelerations to get new velocity</li> <li>Integrate velocity to get new position</li> <li>Integrate angular rates to get new orientation</li> </ol>"},{"location":"concepts/integration/#integrator-interface","title":"Integrator Interface","text":"<pre><code>class IStatePropagator {\npublic:\n    virtual void propagate(EntityState&amp; state,\n                           const EntityForces&amp; forces,\n                           Real dt) = 0;\n};\n</code></pre>"},{"location":"concepts/integration/#available-integrators","title":"Available Integrators","text":""},{"location":"concepts/integration/#rk4-runge-kutta-4th-order","title":"RK4 (Runge-Kutta 4<sup>th</sup> Order)","text":"<p>The default integrator for most applications:</p> <pre><code>class RK4Integrator : public IStatePropagator {\npublic:\n    void propagate(EntityState&amp; state,\n                   const EntityForces&amp; forces,\n                   Real dt) override;\n};\n</code></pre> <p>Characteristics: - 4<sup>th</sup> order accuracy: Error ~ O(dt\u2075) - Good balance of accuracy and performance - Stable for typical simulation rates - Recommended for general use</p>"},{"location":"concepts/integration/#abm4-adams-bashforth-moulton-4th-order","title":"ABM4 (Adams-Bashforth-Moulton 4<sup>th</sup> Order)","text":"<p>Multi-step integrator for smooth dynamics:</p> <pre><code>class ABM4Integrator : public IStatePropagator {\npublic:\n    void propagate(EntityState&amp; state,\n                   const EntityForces&amp; forces,\n                   Real dt) override;\n};\n</code></pre> <p>Characteristics: - 4<sup>th</sup> order accuracy - More efficient for smooth systems - Requires history (4 previous steps) - Uses RK4 for startup</p>"},{"location":"concepts/integration/#equations-of-motion","title":"Equations of Motion","text":""},{"location":"concepts/integration/#translational-dynamics","title":"Translational Dynamics","text":"<pre><code>m \u00b7 a = F_total\na = F_total / m\n</code></pre> <p>Integration: <pre><code>Vec3 accel = forces.force / state.mass;\nstate.velocity += accel * dt;\nstate.position += state.velocity * dt;\n</code></pre></p>"},{"location":"concepts/integration/#rotational-dynamics","title":"Rotational Dynamics","text":"<pre><code>I \u00b7 \u03c9\u0307 = M - \u03c9 \u00d7 (I \u00b7 \u03c9)\n</code></pre> <p>Integration: <pre><code>Vec3 omega = state.angular_velocity;\nVec3 angular_accel = state.inertia.inverse() *\n    (forces.torque - omega.cross(state.inertia * omega));\nstate.angular_velocity += angular_accel * dt;\n</code></pre></p>"},{"location":"concepts/integration/#quaternion-integration","title":"Quaternion Integration","text":"<pre><code>q\u0307 = 0.5 \u00b7 q \u2297 \u03c9_body\n</code></pre> <p>Integration: <pre><code>Quaternion omega_quat{0, omega.x, omega.y, omega.z};\nQuaternion q_dot = state.orientation * omega_quat * 0.5;\nstate.orientation = (state.orientation + q_dot * dt).normalized();\n</code></pre></p>"},{"location":"concepts/integration/#time-step-selection","title":"Time Step Selection","text":""},{"location":"concepts/integration/#recommended-time-steps-by-domain","title":"Recommended Time Steps by Domain","text":"Domain Typical dt Reason Air (aircraft) 0.01 s (100 Hz) Flight dynamics Air (missile) 0.001-0.005 s High-g maneuvers Land 0.02 s (50 Hz) Ground contact Sea 0.02-0.05 s Ship dynamics Space (SGP4) Analytical Pre-integrated Space (numerical) 10-60 s Orbital periods"},{"location":"concepts/integration/#time-step-guidelines","title":"Time Step Guidelines","text":"<p>Too Large: - Numerical instability - Missed dynamics - Energy gain/loss</p> <p>Too Small: - Wasted computation - Round-off error accumulation - Slower than real-time</p>"},{"location":"concepts/integration/#adaptive-time-stepping","title":"Adaptive Time Stepping","text":"<p>For variable-complexity scenarios:</p> <pre><code>Real compute_adaptive_dt(const EntityState&amp; state,\n                         const EntityForces&amp; forces,\n                         Real dt_max) {\n    // Estimate required time step based on dynamics\n    Real accel_mag = (forces.force / state.mass).norm();\n    Real omega_mag = state.angular_velocity.norm();\n\n    // Scale based on acceleration\n    Real dt_accel = (accel_mag &gt; 0) ? 0.1 / accel_mag : dt_max;\n\n    // Scale based on rotation rate\n    Real dt_omega = (omega_mag &gt; 0) ? 0.05 / omega_mag : dt_max;\n\n    return std::min({dt_accel, dt_omega, dt_max});\n}\n</code></pre>"},{"location":"concepts/integration/#using-integrators","title":"Using Integrators","text":""},{"location":"concepts/integration/#basic-usage","title":"Basic Usage","text":"<pre><code>// Simulation loop\nReal dt = 0.01;  // 100 Hz\nReal end_time = 100.0;\n\nfor (Real t = 0; t &lt; end_time; t += dt) {\n    // Compute forces\n    physics::EntityForces forces;\n    forces.clear();\n    compute_forces(state, env, forces);\n\n    // Integrate\n    engine.step(dt);\n}\n</code></pre>"},{"location":"concepts/integration/#custom-integrator","title":"Custom Integrator","text":"<pre><code>class SemiImplicitEuler : public IStatePropagator {\npublic:\n    void propagate(EntityState&amp; state,\n                   const EntityForces&amp; forces,\n                   Real dt) override {\n        // Update velocity first (implicit in position)\n        Vec3 accel = forces.force / state.mass;\n        state.velocity += accel * dt;\n\n        // Then update position with new velocity\n        state.position += state.velocity * dt;\n\n        // Angular dynamics\n        Vec3 omega = state.angular_velocity;\n        Vec3 angular_accel = state.inertia.inverse() *\n            (forces.torque - omega.cross(state.inertia * omega));\n        state.angular_velocity += angular_accel * dt;\n\n        // Quaternion update\n        Quaternion omega_quat{0, omega.x, omega.y, omega.z};\n        Quaternion q_dot = state.orientation * omega_quat * 0.5;\n        state.orientation = (state.orientation + q_dot * dt).normalized();\n    }\n};\n</code></pre>"},{"location":"concepts/integration/#stability-analysis","title":"Stability Analysis","text":""},{"location":"concepts/integration/#energy-conservation","title":"Energy Conservation","text":"<p>For conservative systems, total energy should be constant:</p> <pre><code>Real compute_energy(const EntityState&amp; state) {\n    // Kinetic energy\n    Real KE_trans = 0.5 * state.mass * state.velocity.dot(state.velocity);\n    Real KE_rot = 0.5 * state.angular_velocity.dot(\n        state.inertia * state.angular_velocity);\n\n    // Potential energy (gravity)\n    Real PE = state.mass * G0 * (-state.position.z);\n\n    return KE_trans + KE_rot + PE;\n}\n\n// Monitor energy drift\nReal E0 = compute_energy(initial_state);\nReal E = compute_energy(current_state);\nReal drift = (E - E0) / E0;\nif (std::abs(drift) &gt; 0.01) {\n    // Energy drift &gt; 1%, may need smaller time step\n}\n</code></pre>"},{"location":"concepts/integration/#cfl-condition","title":"CFL Condition","text":"<p>For wave propagation (speed of sound, etc.):</p> <pre><code>dt &lt; dx / c\n</code></pre> <p>Where dx is characteristic length and c is wave speed.</p>"},{"location":"concepts/integration/#special-cases","title":"Special Cases","text":""},{"location":"concepts/integration/#constrained-systems","title":"Constrained Systems","text":"<p>For systems with constraints (e.g., ground contact):</p> <pre><code>void apply_ground_constraint(EntityState&amp; state, Real ground_z) {\n    if (state.position.z &gt; ground_z) {\n        // Below ground - apply constraint\n        state.position.z = ground_z;\n\n        // Remove downward velocity\n        if (state.velocity.z &gt; 0) {\n            state.velocity.z = 0;\n        }\n    }\n}\n</code></pre>"},{"location":"concepts/integration/#discontinuities","title":"Discontinuities","text":"<p>For sudden events (impacts, staging):</p> <pre><code>void handle_impact(EntityState&amp; state, Real restitution) {\n    // Reflect velocity\n    state.velocity.z = -restitution * state.velocity.z;\n\n    // Apply impulse\n    physics::EntityForces impulse;\n    // ... compute impulse ...\n}\n</code></pre>"},{"location":"concepts/integration/#best-practices","title":"Best Practices","text":""},{"location":"concepts/integration/#initialization","title":"Initialization","text":"<ol> <li>Set valid initial state before integration</li> <li>Ensure quaternion is normalized</li> <li>Verify inertia tensor is positive definite</li> </ol>"},{"location":"concepts/integration/#numerical-hygiene","title":"Numerical Hygiene","text":"<ol> <li>Normalize quaternions every step</li> <li>Check for NaN/Inf after integration</li> <li>Monitor energy conservation</li> </ol>"},{"location":"concepts/integration/#performance","title":"Performance","text":"<ol> <li>Profile integration vs force computation</li> <li>Consider multi-rate integration for multi-scale systems</li> <li>Use appropriate precision (float vs double)</li> </ol>"},{"location":"concepts/integration/#see-also","title":"See Also","text":"<ul> <li>Force Generators - Computing forces</li> <li>Entities - Entity state management</li> <li>API Reference - Physics API</li> </ul>"},{"location":"concepts/overview/","title":"Core Concepts","text":"<p>Understanding JaguarEngine's architecture and design principles.</p>"},{"location":"concepts/overview/#design-philosophy","title":"Design Philosophy","text":"<p>JaguarEngine is built on three core principles:</p> <ol> <li>Data-Oriented Design (DOD) - Optimize for cache efficiency and SIMD operations</li> <li>Multi-Domain Unification - Consistent interfaces across Air, Land, Sea, and Space</li> <li>Component-Based Physics - Modular force generators that can be mixed and matched</li> </ol>"},{"location":"concepts/overview/#architecture-overview","title":"Architecture Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Public API (Engine Facade)               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 Physics Engine Executive                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502Entity Manager\u2502 \u2502Physics System\u2502 \u2502 Property Manager     \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Domain Physics Layer                     \u2502\n\u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2502\n\u2502    \u2502 Air \u2502   \u2502 Land \u2502   \u2502 Sea \u2502   \u2502 Space \u2502               \u2502\n\u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Environment Services                      \u2502\n\u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2502\n\u2502    \u2502 Terrain \u2502   \u2502 Atmosphere \u2502   \u2502 Ocean \u2502               \u2502\n\u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      Core Services                          \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 Memory \u2502 \u2502 Threading \u2502 \u2502 Math \u2502 \u2502  I/O   \u2502 \u2502 Config   \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"concepts/overview/#entities-and-state","title":"Entities and State","text":""},{"location":"concepts/overview/#what-is-an-entity","title":"What is an Entity?","text":"<p>An entity represents a simulated object (aircraft, vehicle, ship, spacecraft). Entities are lightweight identifiers; the actual data is stored in contiguous arrays for cache efficiency.</p> <pre><code>// Entity creation\nEntityId aircraft = engine.create_entity(\"F-16\", Domain::Air);\nEntityId tank = engine.create_entity(\"M1A2\", Domain::Land);\nEntityId ship = engine.create_entity(\"DDG-51\", Domain::Sea);\nEntityId satellite = engine.create_entity(\"GPS-IIR\", Domain::Space);\n</code></pre>"},{"location":"concepts/overview/#entity-state","title":"Entity State","text":"<p>Each entity has a 6-DOF (6 Degrees of Freedom) state:</p> <pre><code>struct EntityState {\n    Vec3 position;           // Position (m) in ECEF or NED\n    Vec3 velocity;           // Velocity (m/s)\n    Quaternion orientation;  // Attitude quaternion\n    Vec3 angular_velocity;   // Angular velocity (rad/s)\n    Real mass;               // Mass (kg)\n    Mat3x3 inertia;          // Inertia tensor (kg\u00b7m\u00b2)\n};\n</code></pre>"},{"location":"concepts/overview/#state-access","title":"State Access","text":"<pre><code>// Set state\nengine.set_entity_state(entity_id, state);\n\n// Get state (read current values)\nauto state = engine.get_entity_state(entity_id);\n\n// Access individual components\nReal altitude = -state.position.z;  // NED: negative z is altitude\nReal speed = state.velocity.norm();\n</code></pre>"},{"location":"concepts/overview/#coordinate-systems","title":"Coordinate Systems","text":"<p>JaguarEngine supports multiple coordinate frames:</p>"},{"location":"concepts/overview/#ned-north-east-down","title":"NED (North-East-Down)","text":"<p>The default local frame:</p> Axis Direction Notes X North Positive forward Y East Positive right Z Down Positive into Earth <pre><code>// 10 km altitude in NED\nVec3 position{0.0, 0.0, -10000.0};\n\n// Flying north at 250 m/s\nVec3 velocity{250.0, 0.0, 0.0};\n</code></pre>"},{"location":"concepts/overview/#ecef-earth-centered-earth-fixed","title":"ECEF (Earth-Centered Earth-Fixed)","text":"<p>Global coordinate frame for large-scale simulations:</p> <ul> <li>Origin at Earth's center</li> <li>X-axis through Prime Meridian/Equator intersection</li> <li>Z-axis through North Pole</li> <li>Y-axis completes right-handed system</li> </ul>"},{"location":"concepts/overview/#eci-earth-centered-inertial","title":"ECI (Earth-Centered Inertial)","text":"<p>For space domain simulations:</p> <ul> <li>Non-rotating frame</li> <li>X-axis toward vernal equinox</li> <li>Z-axis toward celestial north pole</li> </ul>"},{"location":"concepts/overview/#coordinate-conversions","title":"Coordinate Conversions","text":"<pre><code>// ECEF to geodetic (lat, lon, alt)\nVec3 geodetic = transforms::ecef_to_geodetic(position_ecef);\nReal lat = geodetic.x;  // radians\nReal lon = geodetic.y;  // radians\nReal alt = geodetic.z;  // meters\n\n// Geodetic to ECEF\nVec3 ecef = transforms::geodetic_to_ecef(lat, lon, alt);\n\n// ECI to ECEF (time-dependent)\nVec3 ecef = transforms::eci_to_ecef(position_eci, julian_date);\n</code></pre>"},{"location":"concepts/overview/#physics-domains","title":"Physics Domains","text":""},{"location":"concepts/overview/#domain-selection","title":"Domain Selection","text":"<p>Choose the appropriate domain for your entity:</p> Domain Use Case Physics Models <code>Air</code> Aircraft, helicopters, UAVs Aerodynamics, propulsion <code>Land</code> Tanks, cars, trucks Terramechanics, suspension <code>Sea</code> Ships, submarines Hydrodynamics, buoyancy <code>Space</code> Satellites, spacecraft Orbital mechanics, gravity"},{"location":"concepts/overview/#domain-specific-physics","title":"Domain-Specific Physics","text":"<p>Each domain provides specialized force generators:</p> <pre><code>// Air domain\nAerodynamicsModel aero;      // Lift, drag, moments\nPropulsionModel engine;      // Thrust, fuel consumption\nFlightControlSystem fcs;     // Control surface deflections\n\n// Land domain\nTerramechanicsModel terra;   // Soil-vehicle interaction\nSuspensionModel suspension;  // Spring-damper dynamics\nTrackedVehicleModel tracks;  // Track slip and traction\n\n// Sea domain\nBuoyancyModel buoyancy;      // Hydrostatic forces\nHydrodynamicsModel hydro;    // Maneuvering forces\nWaveModel waves;             // Sea state effects\n\n// Space domain\nGravityModel gravity;        // Gravitational acceleration\nSGP4Propagator sgp4;         // Orbital propagation\nAtmosphericDragModel drag;   // Upper atmosphere drag\n</code></pre>"},{"location":"concepts/overview/#force-generators","title":"Force Generators","text":""},{"location":"concepts/overview/#concept","title":"Concept","text":"<p>Force generators compute forces and torques acting on entities. Multiple generators can be combined:</p> <pre><code>// Force generator interface\nclass IForceGenerator {\npublic:\n    virtual void compute_forces(\n        const EntityState&amp; state,\n        const Environment&amp; env,\n        Real dt,\n        EntityForces&amp; forces\n    ) = 0;\n};\n</code></pre>"},{"location":"concepts/overview/#combining-forces","title":"Combining Forces","text":"<pre><code>// Create force accumulators\nEntityForces forces;\n\n// Compute from multiple sources\naero_model.compute_forces(state, env, dt, forces);\npropulsion_model.compute_forces(state, env, dt, forces);\ngravity_force = Vec3{0, 0, mass * G0};\nforces.add_force(gravity_force);\n\n// Apply to entity\nengine.apply_forces(entity_id, forces);\n</code></pre>"},{"location":"concepts/overview/#built-in-force-generators","title":"Built-in Force Generators","text":"Generator Domain Purpose <code>AerodynamicsModel</code> Air Lift, drag, aerodynamic moments <code>PropulsionModel</code> Air Thrust, fuel consumption <code>TerramechanicsModel</code> Land Soil resistance, sinkage <code>SuspensionModel</code> Land Suspension forces <code>BuoyancyModel</code> Sea Hydrostatic lift <code>HydrodynamicsModel</code> Sea Hull resistance, maneuvering <code>GravityModel</code> Space Gravitational acceleration <code>AtmosphericDragModel</code> Space Atmospheric drag"},{"location":"concepts/overview/#environment-system","title":"Environment System","text":""},{"location":"concepts/overview/#environment-query","title":"Environment Query","text":"<p>Get environmental conditions at any location:</p> <pre><code>// Query at entity location\nEnvironment env = engine.get_environment(entity_id);\n\n// Query at arbitrary position\nEnvironment env = engine.get_environment_at(position_ecef);\n\n// Access components\nReal density = env.atmosphere.density;      // kg/m\u00b3\nReal temperature = env.atmosphere.temperature;  // K\nReal wind_speed = env.atmosphere.wind.norm();   // m/s\nReal terrain_elevation = env.terrain_elevation; // m\n</code></pre>"},{"location":"concepts/overview/#atmosphere","title":"Atmosphere","text":"<p>US Standard Atmosphere 1976 with weather extensions:</p> <pre><code>struct AtmosphereState {\n    Real temperature;      // K\n    Real pressure;         // Pa\n    Real density;          // kg/m\u00b3\n    Real speed_of_sound;   // m/s\n    Vec3 wind;             // m/s (NED)\n    Real humidity;         // 0-1\n    Real visibility;       // m\n};\n</code></pre>"},{"location":"concepts/overview/#terrain","title":"Terrain","text":"<p>Digital elevation model with material properties:</p> <pre><code>struct TerrainQuery {\n    Real elevation;        // m above WGS84\n    Vec3 normal;           // Surface normal\n    Real slope_angle;      // rad\n    TerrainMaterial material;\n    bool valid;\n};\n</code></pre>"},{"location":"concepts/overview/#ocean","title":"Ocean","text":"<p>Wave modeling and sea state:</p> <pre><code>struct OceanState {\n    Real water_depth;      // m\n    Real surface_elevation; // m\n    Vec3 current;          // m/s\n    Real temperature;      // \u00b0C\n    Real salinity;         // ppt\n    Real density;          // kg/m\u00b3\n};\n</code></pre>"},{"location":"concepts/overview/#simulation-loop","title":"Simulation Loop","text":""},{"location":"concepts/overview/#basic-loop-structure","title":"Basic Loop Structure","text":"<pre><code>// Initialize\nEngine engine;\nengine.initialize();\n\n// Create entities\nEntityId entity = engine.create_entity(\"name\", Domain::Air);\nengine.set_entity_state(entity, initial_state);\n\n// Simulation loop\nconst Real dt = 0.01;  // 100 Hz\nwhile (running) {\n    // 1. Update controls/inputs\n\n    // 2. Compute custom forces\n    EntityForces forces;\n    my_model.compute_forces(state, env, dt, forces);\n    engine.apply_forces(entity, forces);\n\n    // 3. Advance physics\n    engine.step(dt);\n\n    // 4. Read results\n    auto state = engine.get_entity_state(entity);\n}\n\n// Cleanup\nengine.shutdown();\n</code></pre>"},{"location":"concepts/overview/#time-step-selection","title":"Time Step Selection","text":"Application Recommended dt Notes Aircraft 0.01 s (100 Hz) Adequate for most dynamics Ground vehicles 0.02 s (50 Hz) Lower frequency sufficient Ships 0.05 s (20 Hz) Slower dynamics Spacecraft 1-10 s Long-duration orbits"},{"location":"concepts/overview/#variable-time-step","title":"Variable Time Step","text":"<pre><code>// Adaptive stepping\nauto last_time = std::chrono::high_resolution_clock::now();\n\nwhile (running) {\n    auto now = std::chrono::high_resolution_clock::now();\n    Real dt = std::chrono::duration&lt;Real&gt;(now - last_time).count();\n    last_time = now;\n\n    // Clamp dt to prevent instability\n    dt = std::min(dt, 0.1);\n\n    engine.step(dt);\n}\n</code></pre>"},{"location":"concepts/overview/#integration-methods","title":"Integration Methods","text":"<p>JaguarEngine provides multiple numerical integrators:</p> Method Order Use Case RK4 4<sup>th</sup> General purpose, good stability ABM4 4<sup>th</sup> Smooth trajectories, efficient Adaptive Variable Variable step size"},{"location":"concepts/overview/#selecting-integrator","title":"Selecting Integrator","text":"<pre><code>// In configuration\n&lt;physics&gt;\n    &lt;integrator&gt;rk4&lt;/integrator&gt;\n&lt;/physics&gt;\n\n// Or programmatically\nengine.set_integrator(\"rk4\");\n</code></pre>"},{"location":"concepts/overview/#property-system","title":"Property System","text":""},{"location":"concepts/overview/#hierarchical-access","title":"Hierarchical Access","text":"<p>Properties provide runtime access to simulation parameters:</p> <pre><code>aircraft/f16/\n\u251c\u2500\u2500 position/\n\u2502   \u251c\u2500\u2500 latitude-geod-rad\n\u2502   \u251c\u2500\u2500 longitude-geoc-rad\n\u2502   \u2514\u2500\u2500 h-sl-ft\n\u251c\u2500\u2500 velocity/\n\u2502   \u251c\u2500\u2500 u-fps\n\u2502   \u251c\u2500\u2500 v-fps\n\u2502   \u2514\u2500\u2500 w-fps\n\u251c\u2500\u2500 aero/\n\u2502   \u251c\u2500\u2500 alpha-rad\n\u2502   \u251c\u2500\u2500 beta-rad\n\u2502   \u251c\u2500\u2500 cl\n\u2502   \u2514\u2500\u2500 cd\n\u2514\u2500\u2500 propulsion/\n    \u251c\u2500\u2500 thrust-lbs\n    \u2514\u2500\u2500 fuel-lbs\n</code></pre>"},{"location":"concepts/overview/#using-properties","title":"Using Properties","text":"<pre><code>// Get property value\nReal alpha = engine.get_property(\"aircraft/f16/aero/alpha-rad\");\n\n// Set property value\nengine.set_property(\"aircraft/f16/propulsion/throttle\", 0.8);\n\n// Bind for direct access (faster)\nReal* thrust_ptr;\nengine.bind_property(\"aircraft/f16/propulsion/thrust-lbs\", thrust_ptr);\n// Now *thrust_ptr always has current value\n</code></pre>"},{"location":"concepts/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Entity Management - Detailed entity lifecycle</li> <li>Force Generators - Creating custom physics</li> <li>Environment Models - Terrain, atmosphere, ocean</li> <li>Coordinate Systems - Detailed coordinate transforms</li> <li>Integration Methods - Numerical integration options</li> </ul>"},{"location":"domains/air/","title":"Air Domain","text":"<p>The Air domain module implements aerodynamics, propulsion, and flight control systems for aircraft, missiles, and other airborne entities.</p>"},{"location":"domains/air/#overview","title":"Overview","text":"<p>JaguarEngine's Air domain provides:</p> <ul> <li>6-DOF Flight Dynamics: Full six degrees of freedom rigid body dynamics</li> <li>Coefficient-Based Aerodynamics: N-dimensional interpolation tables</li> <li>Propulsion Models: Turbofan/turbojet with altitude-Mach corrections</li> <li>Flight Control Systems: Rate limiting, autopilot, and stability augmentation</li> </ul>"},{"location":"domains/air/#aerodynamic-model","title":"Aerodynamic Model","text":""},{"location":"domains/air/#coefficient-tables","title":"Coefficient Tables","text":"<p>Multi-dimensional lookup tables for aerodynamic coefficients:</p> Coefficient Dependencies Description C_L \u03b1, M, \u03b4_e Lift coefficient C_D \u03b1, M, C_L Drag coefficient C_m \u03b1, M, \u03b4_e Pitching moment C_l \u03b2, p\u0304, \u03b4_a, \u03b4_r Rolling moment C_n \u03b2, r\u0304, \u03b4_a, \u03b4_r Yawing moment C_Y \u03b2, \u03b4_r Side force"},{"location":"domains/air/#equations-of-motion","title":"Equations of Motion","text":"<p>Translational (ECEF frame): <pre><code>m\u00b7a = F_aero + F_thrust + F_gravity + F_ground\n</code></pre></p> <p>Rotational (Body frame): <pre><code>I\u00b7\u03c9\u0307 = M - \u03c9 \u00d7 (I\u00b7\u03c9)\n</code></pre></p> <p>Quaternion Integration (Gimbal-lock free): <pre><code>q\u0307 = 0.5 \u00b7 q \u2297 \u03c9_body\n</code></pre></p>"},{"location":"domains/air/#example-creating-an-aircraft","title":"Example: Creating an Aircraft","text":"<pre><code>#include &lt;jaguar/jaguar.h&gt;\n\nusing namespace jaguar;\n\nint main() {\n    // Create engine\n    Engine engine;\n    engine.initialize();\n\n    // Create aircraft entity\n    EntityId aircraft = engine.create_entity(\"F16\", Domain::Air);\n\n    // Configure initial state\n    physics::EntityState state;\n    state.position = Vec3{0.0, 0.0, -10000.0};  // 10 km altitude (NED)\n    state.velocity = Vec3{250.0, 0.0, 0.0};     // 250 m/s forward\n    state.mass = 12000.0;                        // 12,000 kg\n    engine.set_entity_state(aircraft, state);\n\n    // Run simulation\n    for (int i = 0; i &lt; 1000; ++i) {\n        engine.step(0.01);  // 100 Hz\n\n        // Get current state\n        auto current = engine.get_entity_state(aircraft);\n        std::cout &lt;&lt; \"Altitude: \" &lt;&lt; -current.position.z &lt;&lt; \" m\\n\";\n    }\n\n    engine.shutdown();\n    return 0;\n}\n</code></pre>"},{"location":"domains/air/#propulsion","title":"Propulsion","text":""},{"location":"domains/air/#thrust-modeling","title":"Thrust Modeling","text":"<p>The propulsion model accounts for:</p> <ol> <li> <p>Altitude Effect (density ratio): <pre><code>\u03c3 = \u03c1 / \u03c1_SL\naltitude_factor = \u03c3^0.7  // Typical turbofan\n</code></pre></p> </li> <li> <p>Ram Effect (Mach correction): <pre><code>if (M &lt; 0.8)  ram = 1.0 + 0.15 \u00d7 M\nif (M &lt; 1.2)  ram = 1.12 - 0.1 \u00d7 (M - 0.8)\nif (M \u2265 1.2)  ram = max(0.5, 1.08 - 0.3 \u00d7 (M - 1.2))\n</code></pre></p> </li> <li> <p>Net Thrust: <pre><code>T = T_max \u00d7 throttle \u00d7 altitude_factor \u00d7 ram_factor\n</code></pre></p> </li> </ol>"},{"location":"domains/air/#configuration","title":"Configuration","text":"<pre><code>&lt;propulsion&gt;\n    &lt;engine type=\"turbofan\" name=\"F110-GE-129\"&gt;\n        &lt;max_thrust unit=\"lbf\"&gt;17000&lt;/max_thrust&gt;\n        &lt;afterburner_thrust unit=\"lbf\"&gt;29000&lt;/afterburner_thrust&gt;\n        &lt;tsfc&gt;0.76&lt;/tsfc&gt;  &lt;!-- lb/hr/lbf --&gt;\n    &lt;/engine&gt;\n&lt;/propulsion&gt;\n</code></pre>"},{"location":"domains/air/#flight-control-system","title":"Flight Control System","text":""},{"location":"domains/air/#control-surface-mapping","title":"Control Surface Mapping","text":"<pre><code>FlightControlSystem fcs;\n\n// Configure limits\nfcs.set_elevator_range(-25.0, 25.0);  // degrees\nfcs.set_aileron_range(-20.0, 20.0);\nfcs.set_rudder_range(-30.0, 30.0);\n\n// Process pilot inputs\nFlightControlSystem::ControlInputs inputs;\ninputs.pitch_cmd = -0.3;   // Pull back\ninputs.roll_cmd = 0.5;     // Roll right\ninputs.yaw_cmd = 0.0;\ninputs.throttle_cmd = 0.8;\n\nauto outputs = fcs.process(inputs, dt);\n// outputs.elevator_deg, outputs.aileron_deg, outputs.rudder_deg\n</code></pre>"},{"location":"domains/air/#coordinate-conventions","title":"Coordinate Conventions","text":""},{"location":"domains/air/#body-axis-system","title":"Body-Axis System","text":"<ul> <li>X: Forward (out the nose)</li> <li>Y: Right (out the right wing)</li> <li>Z: Down</li> </ul>"},{"location":"domains/air/#sign-conventions","title":"Sign Conventions","text":"Parameter Positive Direction \u03b1 (alpha) Nose up relative to velocity \u03b2 (beta) Nose left relative to velocity Elevator Trailing edge up (nose up) Aileron Right aileron trailing edge down Rudder Trailing edge left (nose left)"},{"location":"domains/air/#missile-specific-features","title":"Missile-Specific Features","text":"<ul> <li>Seeker Model: Configurable FOV, track rate, noise</li> <li>Guidance Laws: PNG, APN, optimal (configurable via XML)</li> <li>Motor Profiles: Thrust(t) curves with burn-out detection</li> <li>Fin Actuators: Rate limits, deflection limits, lag</li> </ul>"},{"location":"domains/air/#performance-guidelines","title":"Performance Guidelines","text":"Parameter Recommended Value Integration rate 100 Hz (dt = 0.01s) Alpha breakpoints 5-7 minimum Mach breakpoints 0.0, 0.4, 0.8, 0.9, 1.0, 1.2, 1.5 Minimum airspeed 1 m/s threshold"},{"location":"domains/air/#see-also","title":"See Also","text":"<ul> <li>Land Domain - Ground vehicle simulation</li> <li>Sea Domain - Naval vessel simulation</li> <li>Space Domain - Orbital mechanics</li> <li>Examples - Complete code examples</li> </ul>"},{"location":"domains/land/","title":"Land Domain","text":"<p>The Land domain module implements terramechanics, suspension systems, and tracked/wheeled vehicle dynamics for ground vehicles.</p>"},{"location":"domains/land/#overview","title":"Overview","text":"<p>JaguarEngine's Land domain provides:</p> <ul> <li>Bekker-Wong Terramechanics: Soil-vehicle interaction modeling</li> <li>Suspension Dynamics: Spring-damper systems with bump stops</li> <li>Tracked Vehicle Models: Continuous track approximation</li> <li>Terrain Integration: DTED/SRTM terrain queries</li> </ul>"},{"location":"domains/land/#terramechanics-model","title":"Terramechanics Model","text":""},{"location":"domains/land/#bekker-wong-theory","title":"Bekker-Wong Theory","text":"<p>The pressure-sinkage relationship:</p> <pre><code>p = (k_c/b + k_\u03c6) \u00d7 z^n\n</code></pre> <p>Where: - p = ground pressure (Pa) - k_c = cohesive modulus (kN/m^(n+1)) - k_\u03c6 = frictional modulus (kN/m^(n+2)) - b = contact width (m) - z = sinkage (m) - n = deformation exponent</p>"},{"location":"domains/land/#soil-properties","title":"Soil Properties","text":"Soil Type k_c k_\u03c6 n c (kPa) \u03c6 (deg) Dry Sand 0.99 1528 1.10 1.04 28\u00b0 Wet Sand 5.27 1515 0.73 1.72 29\u00b0 Clay 13.19 692 0.50 4.14 13\u00b0 Snow 4.37 196 1.60 1.03 19.7\u00b0 Asphalt 10\u2076 10\u2076 0 1000 45\u00b0"},{"location":"domains/land/#motion-resistance","title":"Motion Resistance","text":"<p>Compaction resistance from soil deformation:</p> <pre><code>R_c = b \u00d7 (k_c/b + k_\u03c6) \u00d7 z^(n+1) / (n+1)\n</code></pre>"},{"location":"domains/land/#traction-model-mohr-coulomb","title":"Traction Model (Mohr-Coulomb)","text":"<p>Maximum shear stress: <pre><code>\u03c4_max = c + \u03c3 \u00d7 tan(\u03c6)\n</code></pre></p> <p>Maximum traction force: <pre><code>T_max = A \u00d7 \u03c4_max\n</code></pre></p>"},{"location":"domains/land/#example-creating-a-tank","title":"Example: Creating a Tank","text":"<pre><code>#include &lt;jaguar/jaguar.h&gt;\n\nusing namespace jaguar;\n\nint main() {\n    Engine engine;\n    engine.initialize();\n\n    // Create ground vehicle entity\n    EntityId tank = engine.create_entity(\"M1A2\", Domain::Land);\n\n    // Configure initial state\n    physics::EntityState state;\n    state.position = Vec3{0.0, 0.0, 0.0};\n    state.velocity = Vec3{0.0, 0.0, 0.0};\n    state.mass = 62000.0;  // 62 tonnes\n    engine.set_entity_state(tank, state);\n\n    // Configure terramechanics\n    domain::land::TerramechanicsModel terra;\n    terra.set_contact_area(0.63, 4.6);    // Track width, length\n    terra.set_vehicle_weight(62000.0 * 9.81);\n\n    // Run simulation\n    for (int i = 0; i &lt; 1000; ++i) {\n        engine.step(0.02);  // 50 Hz\n\n        // Check mobility\n        Real sinkage = terra.get_sinkage();\n        if (sinkage &gt; 0.3) {\n            std::cout &lt;&lt; \"Warning: High sinkage!\\n\";\n        }\n    }\n\n    engine.shutdown();\n    return 0;\n}\n</code></pre>"},{"location":"domains/land/#suspension-system","title":"Suspension System","text":""},{"location":"domains/land/#spring-damper-model","title":"Spring-Damper Model","text":"<p>Force calculation: <pre><code>F = k \u00d7 x + c \u00d7 v + preload\n</code></pre></p> <p>Where: - k = spring stiffness (N/m) - c = damping coefficient (N\u00b7s/m) - x = compression (m) - v = compression rate (m/s)</p>"},{"location":"domains/land/#bump-stop-modeling","title":"Bump Stop Modeling","text":"<p>Quadratic resistance at travel limits: <pre><code>if (position &gt; travel_max - 0.02) {\n    Real penetration = position - (travel_max - 0.02);\n    F += 100000 \u00d7 penetration\u00b2 / 0.02;\n}\n</code></pre></p>"},{"location":"domains/land/#configuration","title":"Configuration","text":"<pre><code>&lt;suspension type=\"torsion_bar\"&gt;\n    &lt;road_wheels_per_side&gt;7&lt;/road_wheels_per_side&gt;\n    &lt;spring_rate unit=\"N/m\"&gt;300000&lt;/spring_rate&gt;\n    &lt;damping_rate unit=\"N*s/m\"&gt;30000&lt;/damping_rate&gt;\n    &lt;travel unit=\"m\"&gt;0.40&lt;/travel&gt;\n&lt;/suspension&gt;\n</code></pre>"},{"location":"domains/land/#tracked-vehicle-dynamics","title":"Tracked Vehicle Dynamics","text":""},{"location":"domains/land/#track-system","title":"Track System","text":"<pre><code>TrackedVehicleModel tracks;\n\n// Configure sprocket\ntracks.set_sprocket(0.35, 80000.0);  // 35cm radius, 80 kN\u00b7m max torque\n\n// Update dynamics\nReal engine_torque = throttle * 80000.0;\ntracks.update(engine_torque, vehicle_weight, soil, dt);\n\n// Check track states\nauto&amp; left = tracks.get_left_track();\nif (left.slip &gt; 0.3) {\n    // High slip - reduce throttle\n}\n</code></pre>"},{"location":"domains/land/#drive-force","title":"Drive Force","text":"<pre><code>F_drive = T_drive / r_sprocket\n</code></pre>"},{"location":"domains/land/#propulsive-force-with-efficiency","title":"Propulsive Force with Efficiency","text":"<pre><code>F_prop = T_track \u00d7 (1 - slip) \u00d7 \u03b7\n</code></pre> <p>Where \u03b7 \u2248 0.85 (track efficiency).</p>"},{"location":"domains/land/#coordinate-conventions","title":"Coordinate Conventions","text":""},{"location":"domains/land/#body-axis-system","title":"Body-Axis System","text":"<ul> <li>X: Forward (vehicle front)</li> <li>Y: Right (passenger side)</li> <li>Z: Down (into ground)</li> </ul>"},{"location":"domains/land/#forces","title":"Forces","text":"<ul> <li>Traction: Positive X (forward acceleration)</li> <li>Resistance: Negative X (opposes motion)</li> <li>Normal: Ground reaction force</li> </ul>"},{"location":"domains/land/#terrain-integration","title":"Terrain Integration","text":"<p>The terramechanics model queries the environment:</p> <pre><code>environment::Environment env;\n// ... populated by engine ...\n\nReal height = env.altitude - env.terrain_elevation;\nif (height &lt; 0.1) {\n    // Vehicle is on ground, compute terra forces\n    SoilProperties soil = env.terrain.material.get_soil_properties();\n    terra.compute_forces(state, env, dt, forces);\n}\n</code></pre>"},{"location":"domains/land/#vehicle-configuration","title":"Vehicle Configuration","text":"<pre><code>&lt;entity type=\"ground_vehicle\" name=\"M1A2\"&gt;\n    &lt;metrics&gt;\n        &lt;length unit=\"m\"&gt;9.77&lt;/length&gt;\n        &lt;width unit=\"m\"&gt;3.66&lt;/width&gt;\n        &lt;height unit=\"m\"&gt;2.44&lt;/height&gt;\n    &lt;/metrics&gt;\n\n    &lt;mass_balance&gt;\n        &lt;combat_weight unit=\"kg\"&gt;62000&lt;/combat_weight&gt;\n        &lt;fuel_capacity unit=\"L\"&gt;1900&lt;/fuel_capacity&gt;\n    &lt;/mass_balance&gt;\n\n    &lt;tracks&gt;\n        &lt;track_width unit=\"m\"&gt;0.63&lt;/track_width&gt;\n        &lt;track_length unit=\"m\"&gt;4.6&lt;/track_length&gt;\n        &lt;sprocket_radius unit=\"m\"&gt;0.33&lt;/sprocket_radius&gt;\n        &lt;max_torque unit=\"N*m\"&gt;100000&lt;/max_torque&gt;\n    &lt;/tracks&gt;\n&lt;/entity&gt;\n</code></pre>"},{"location":"domains/land/#performance-guidelines","title":"Performance Guidelines","text":"Parameter Recommended Value Integration rate 50-100 Hz Sinkage limit 0.5 m maximum Contact minimum 1 cm dimensions Slip ratio bounds [-1, 1]"},{"location":"domains/land/#see-also","title":"See Also","text":"<ul> <li>Air Domain - Aircraft simulation</li> <li>Sea Domain - Naval vessel simulation</li> <li>Space Domain - Orbital mechanics</li> <li>Examples - Complete code examples</li> </ul>"},{"location":"domains/sea/","title":"Sea Domain","text":"<p>The Sea domain module implements hydrodynamics, buoyancy, wave modeling, and ship motion response for surface vessels and submarines.</p>"},{"location":"domains/sea/#overview","title":"Overview","text":"<p>JaguarEngine's Sea domain provides:</p> <ul> <li>Hydrostatic Buoyancy: Archimedes' principle with metacentric stability</li> <li>Wave Spectrum Models: Pierson-Moskowitz, JONSWAP, Bretschneider</li> <li>RAO-Based Motion: Response Amplitude Operator seakeeping</li> <li>MMG Maneuvering: Maneuvering Mathematical Group hydrodynamics</li> </ul>"},{"location":"domains/sea/#sea-state-conditions","title":"Sea State Conditions","text":""},{"location":"domains/sea/#nato-sea-state-scale","title":"NATO Sea State Scale","text":"Code Description H_s (m) T_p (s) 0 Calm (glassy) 0.0 0.0 1 Calm (rippled) 0.05 2.0 2 Smooth (wavelets) 0.2 3.0 3 Slight 0.75 5.0 4 Moderate 1.5 6.5 5 Rough 2.75 8.0 6 Very rough 5.0 10.0 7 High 8.0 12.0 8 Very high 12.0 15.0"},{"location":"domains/sea/#wave-spectrum-types","title":"Wave Spectrum Types","text":"<ul> <li>Pierson-Moskowitz: Fully developed sea (open ocean)</li> <li>JONSWAP: Fetch-limited sea (coastal waters)</li> <li>Bretschneider: Parameterized spectrum</li> </ul>"},{"location":"domains/sea/#example-creating-a-ship","title":"Example: Creating a Ship","text":"<pre><code>#include &lt;jaguar/jaguar.h&gt;\n\nusing namespace jaguar;\n\nint main() {\n    Engine engine;\n    engine.initialize();\n\n    // Create surface vessel entity\n    EntityId ship = engine.create_entity(\"DDG51\", Domain::Sea);\n\n    // Configure initial state\n    physics::EntityState state;\n    state.position = Vec3{0.0, 0.0, 0.0};\n    state.velocity = Vec3{10.0, 0.0, 0.0};  // 10 m/s forward\n    state.mass = 8600000.0;  // 8,600 tonnes\n    engine.set_entity_state(ship, state);\n\n    // Set sea conditions\n    domain::sea::SeaState conditions = domain::sea::SeaState::FromNATOSeaState(4);\n\n    // Run simulation\n    for (int i = 0; i &lt; 1000; ++i) {\n        engine.step(0.05);  // 20 Hz\n\n        auto current = engine.get_entity_state(ship);\n        Real heel_deg = current.get_roll() * constants::RAD_TO_DEG;\n        std::cout &lt;&lt; \"Heel angle: \" &lt;&lt; heel_deg &lt;&lt; \" deg\\n\";\n    }\n\n    engine.shutdown();\n    return 0;\n}\n</code></pre>"},{"location":"domains/sea/#buoyancy-model","title":"Buoyancy Model","text":""},{"location":"domains/sea/#archimedes-principle","title":"Archimedes' Principle","text":"<pre><code>F_b = \u03c1_water \u00d7 g \u00d7 V_displaced\n</code></pre>"},{"location":"domains/sea/#static-stability-righting-moment","title":"Static Stability - Righting Moment","text":"<pre><code>M_roll = W \u00d7 GM \u00d7 sin(\u03b8)\n</code></pre> <p>Where: - W = vessel weight (N) - GM = metacentric height (m) - \u03b8 = heel angle (rad)</p>"},{"location":"domains/sea/#metacentric-height-gm","title":"Metacentric Height (GM)","text":"GM Value Stability GM &gt; 0 Stable (positive righting moment) GM = 0 Neutral stability GM &lt; 0 Unstable (capsizing tendency)"},{"location":"domains/sea/#typical-gm-values","title":"Typical GM Values","text":"Vessel Type GM (m) Large tanker 0.5-2.0 Container ship 1.0-3.0 Naval vessel 1.5-3.0 Yacht 0.5-1.5"},{"location":"domains/sea/#wave-model","title":"Wave Model","text":""},{"location":"domains/sea/#wave-superposition","title":"Wave Superposition","text":"<pre><code>// Generate 30 wave components from spectrum\nfor each component i:\n    amplitude[i] = sqrt(2 \u00d7 S(\u03c9[i]) \u00d7 \u0394\u03c9)\n    phase[i] = random\n\n// Surface elevation at (x, y, t)\n\u03b7 = \u03a3 a[i] \u00d7 cos(k[i]\u00d7x + k[i]\u00d7y - \u03c9[i]\u00d7t + \u03c6[i])\n</code></pre>"},{"location":"domains/sea/#usage","title":"Usage","text":"<pre><code>WaveModel waves;\nwaves.set_sea_state(SeaState::FromNATOSeaState(5));  // Rough sea\n\n// Surface elevation at ship position\nReal elevation = waves.get_elevation(x, y, time);\n\n// Particle velocity at keel depth\nVec3 orbital_velocity = waves.get_particle_velocity(x, y, -5.0, time);\n\n// Surface slope for roll/pitch excitation\nVec3 slope = waves.get_slope(x, y, time);\n</code></pre>"},{"location":"domains/sea/#rao-model","title":"RAO Model","text":""},{"location":"domains/sea/#response-amplitude-operator","title":"Response Amplitude Operator","text":"<p>The RAO describes how a vessel responds to waves:</p> <pre><code>Response_amplitude = Wave_amplitude \u00d7 RAO(\u03c9)\nResponse_phase = Wave_phase + RAO_phase(\u03c9)\n</code></pre>"},{"location":"domains/sea/#dof-indices","title":"DOF Indices","text":"Index Motion Unit 0 Surge m/m 1 Sway m/m 2 Heave m/m 3 Roll rad/m 4 Pitch rad/m 5 Yaw rad/m"},{"location":"domains/sea/#configuration","title":"Configuration","text":"<pre><code>RAOModel rao;\n\n// Set heave RAO data\nstd::vector&lt;Real&gt; freqs = {0.3, 0.5, 0.8, 1.0, 1.5};  // rad/s\nstd::vector&lt;Real&gt; amps = {0.8, 0.9, 1.0, 0.9, 0.6};   // RAO amplitude\nstd::vector&lt;Real&gt; phases = {0.0, 0.1, 0.2, 0.3, 0.5}; // RAO phase\nrao.set_rao(2, freqs, amps, phases);  // DOF 2 = heave\n\n// Calculate total response\nVec3 displacement, rotation;\nrao.calculate_response(waves, time, displacement, rotation);\n</code></pre>"},{"location":"domains/sea/#mmg-maneuvering-model","title":"MMG Maneuvering Model","text":""},{"location":"domains/sea/#force-decomposition","title":"Force Decomposition","text":"<pre><code>X_total = X_hull + X_propeller + X_rudder\nY_total = Y_hull + Y_rudder\nN_total = N_hull + N_rudder\n</code></pre>"},{"location":"domains/sea/#hull-coefficients","title":"Hull Coefficients","text":"Coefficient Typical Value Effect X_vv -0.04 Surge due to drift\u00b2 X_rr -0.01 Surge due to yaw rate\u00b2 Y_v -0.4 Sway due to drift Y_r 0.05 Sway due to yaw rate N_v -0.1 Yaw due to drift N_r -0.05 Yaw damping"},{"location":"domains/sea/#configuration_1","title":"Configuration","text":"<pre><code>&lt;hydrodynamics&gt;\n    &lt;hull_coefficients&gt;\n        &lt;x_vv&gt;-0.04&lt;/x_vv&gt;\n        &lt;x_rr&gt;-0.01&lt;/x_rr&gt;\n        &lt;y_v&gt;-0.4&lt;/y_v&gt;\n        &lt;y_r&gt;0.05&lt;/y_r&gt;\n        &lt;n_v&gt;-0.1&lt;/n_v&gt;\n        &lt;n_r&gt;-0.05&lt;/n_r&gt;\n    &lt;/hull_coefficients&gt;\n\n    &lt;rudder&gt;\n        &lt;area unit=\"m2\"&gt;18.0&lt;/area&gt;\n        &lt;aspect_ratio&gt;1.6&lt;/aspect_ratio&gt;\n        &lt;max_angle unit=\"deg\"&gt;35.0&lt;/max_angle&gt;\n    &lt;/rudder&gt;\n\n    &lt;propeller&gt;\n        &lt;diameter unit=\"m\"&gt;5.2&lt;/diameter&gt;\n        &lt;pitch_ratio&gt;1.0&lt;/pitch_ratio&gt;\n        &lt;max_rpm&gt;180&lt;/max_rpm&gt;\n    &lt;/propeller&gt;\n&lt;/hydrodynamics&gt;\n</code></pre>"},{"location":"domains/sea/#coordinate-conventions","title":"Coordinate Conventions","text":""},{"location":"domains/sea/#ship-body-axis-system","title":"Ship Body-Axis System","text":"<ul> <li>X: Forward (bow)</li> <li>Y: Starboard (right)</li> <li>Z: Down</li> </ul>"},{"location":"domains/sea/#motions","title":"Motions","text":"Motion Axis Positive Direction Surge X Forward Sway Y Starboard Heave Z Down Roll X Starboard down Pitch Y Bow up Yaw Z Bow to starboard"},{"location":"domains/sea/#performance-guidelines","title":"Performance Guidelines","text":"Parameter Recommended Value Integration rate 20-50 Hz Wave components 30 for good spectrum Frequency range 0.3-2.5 rad/s Minimum velocity 0.01 m/s threshold"},{"location":"domains/sea/#see-also","title":"See Also","text":"<ul> <li>Air Domain - Aircraft simulation</li> <li>Land Domain - Ground vehicle simulation</li> <li>Space Domain - Orbital mechanics</li> <li>Examples - Complete code examples</li> </ul>"},{"location":"domains/space/","title":"Space Domain","text":"<p>The Space domain module implements orbital mechanics, gravity models, atmospheric drag, and coordinate transformations for satellites and space vehicles.</p>"},{"location":"domains/space/#overview","title":"Overview","text":"<p>JaguarEngine's Space domain provides:</p> <ul> <li>SGP4/SDP4 Propagation: Analytical orbital propagation from TLE data</li> <li>High-Fidelity Gravity: Point mass to EGM2008 models</li> <li>Atmospheric Drag: JB08 thermospheric density model</li> <li>Coordinate Transforms: ECI, ECEF, geodetic conversions</li> </ul>"},{"location":"domains/space/#orbital-elements","title":"Orbital Elements","text":""},{"location":"domains/space/#classical-keplerian-elements","title":"Classical Keplerian Elements","text":"Element Symbol Range Description Semi-major axis a &gt; 0 Size of orbit (m) Eccentricity e [0, 1) Shape (0=circular) Inclination i [0, \u03c0] Tilt relative to equator (rad) RAAN \u03a9 [0, 2\u03c0] Orientation in equatorial plane (rad) Arg. of perigee \u03c9 [0, 2\u03c0] Orientation within orbital plane (rad) True anomaly \u03bd [0, 2\u03c0] Current position in orbit (rad)"},{"location":"domains/space/#common-orbit-types","title":"Common Orbit Types","text":"Orbit Type Altitude (km) Period Inclination LEO 160-2000 90-120 min Various MEO 2000-35786 2-24 hr Various GEO 35786 24 hr 0\u00b0 SSO 400-800 ~98 min 97-99\u00b0 Polar Various Various ~90\u00b0"},{"location":"domains/space/#example-creating-a-satellite","title":"Example: Creating a Satellite","text":"<pre><code>#include &lt;jaguar/jaguar.h&gt;\n\nusing namespace jaguar;\n\nint main() {\n    Engine engine;\n    engine.initialize();\n\n    // Create spacecraft entity\n    EntityId satellite = engine.create_entity(\"GPS-IIR\", Domain::Space);\n\n    // Configure orbital elements (GPS constellation)\n    domain::space::OrbitalElements orbit;\n    orbit.semi_major_axis = 26560000.0;  // 26,560 km\n    orbit.eccentricity = 0.0;\n    orbit.inclination = 55.0 * constants::DEG_TO_RAD;\n    orbit.raan = 0.0;\n    orbit.arg_of_perigee = 0.0;\n    orbit.true_anomaly = 0.0;\n\n    // Convert to state vectors\n    Vec3 pos_eci, vel_eci;\n    orbit.to_state_vector(pos_eci, vel_eci);\n\n    // Set initial state\n    physics::EntityState state;\n    state.position = pos_eci;\n    state.velocity = vel_eci;\n    state.mass = 1430.0;  // kg\n    engine.set_entity_state(satellite, state);\n\n    // Run simulation for one orbital period\n    Real period = orbit.period();  // ~12 hours\n    for (Real t = 0; t &lt; period; t += 60.0) {\n        engine.step(60.0);  // 1-minute steps\n\n        auto current = engine.get_entity_state(satellite);\n        Real alt = current.position.norm() - constants::EARTH_RADIUS;\n        std::cout &lt;&lt; \"Altitude: \" &lt;&lt; alt / 1000.0 &lt;&lt; \" km\\n\";\n    }\n\n    engine.shutdown();\n    return 0;\n}\n</code></pre>"},{"location":"domains/space/#sgp4-propagator","title":"SGP4 Propagator","text":""},{"location":"domains/space/#two-line-element-tle-format","title":"Two-Line Element (TLE) Format","text":"<pre><code>ISS (ZARYA)\n1 25544U 98067A   21275.52422453  .00001234  00000-0  28888-4 0  9990\n2 25544  51.6442  27.4345 0003542 211.7212 148.3510 15.48919914305213\n</code></pre>"},{"location":"domains/space/#usage","title":"Usage","text":"<pre><code>// Parse TLE\nstd::string line1 = \"1 25544U 98067A   21275.52422453...\";\nstd::string line2 = \"2 25544  51.6442  27.4345 0003542...\";\nTLE tle = TLE::parse(line1, line2);\n\n// Initialize propagator\nSGP4Propagator sgp4;\nsgp4.initialize(tle);\n\n// Propagate forward 90 minutes\nVec3 pos_km, vel_kms;\nsgp4.propagate(90.0, pos_km, vel_kms);\n\n// Convert to SI units\nVec3 pos_m = pos_km * 1000.0;\nVec3 vel_ms = vel_kms * 1000.0;\n</code></pre>"},{"location":"domains/space/#sgp4-vs-sdp4","title":"SGP4 vs SDP4","text":"Model Period Use Case SGP4 &lt; 225 min Near-Earth satellites (LEO) SDP4 \u2265 225 min Deep-space satellites (GEO, HEO) <p>Selection is automatic based on mean motion.</p>"},{"location":"domains/space/#gravity-model","title":"Gravity Model","text":""},{"location":"domains/space/#fidelity-levels","title":"Fidelity Levels","text":"Level Model Accuracy Performance 0 Point mass ~1 km at LEO Fastest 1 J2 ~100 m at LEO Fast 2 J2-J4 ~10 m at LEO Moderate 3 EGM96/EGM2008 ~1 m Slowest"},{"location":"domains/space/#zonal-harmonics","title":"Zonal Harmonics","text":"Coefficient Value Effect J2 1.08263 \u00d7 10\u207b\u00b3 Earth oblateness (dominant) J3 -2.532 \u00d7 10\u207b\u2076 North-south asymmetry J4 -1.6109 \u00d7 10\u207b\u2076 Higher-order oblateness"},{"location":"domains/space/#usage_1","title":"Usage","text":"<pre><code>GravityModel gravity;\ngravity.set_fidelity(1);  // J2 perturbation\n\n// Compute gravity acceleration\nVec3 g = gravity.compute_acceleration(position_ecef);\n</code></pre>"},{"location":"domains/space/#atmospheric-drag","title":"Atmospheric Drag","text":""},{"location":"domains/space/#jb08-atmosphere-model","title":"JB08 Atmosphere Model","text":"<p>Density depends on: - Altitude - Solar flux (F10.7) - Geomagnetic activity (Ap) - Day of year, local time</p>"},{"location":"domains/space/#space-weather-parameters","title":"Space Weather Parameters","text":"Parameter Description Typical Range F10.7 Solar radio flux 70-300 sfu F10.7 avg 81-day average 70-250 sfu Ap Geomagnetic index 0-400"},{"location":"domains/space/#density-vs-altitude","title":"Density vs Altitude","text":"Altitude (km) Quiet Sun (kg/m\u00b3) Active Sun (kg/m\u00b3) 200 ~3 \u00d7 10\u207b\u00b9\u2070 ~1 \u00d7 10\u207b\u2079 400 ~3 \u00d7 10\u207b\u00b9\u00b2 ~3 \u00d7 10\u207b\u00b9\u00b9 600 ~1 \u00d7 10\u207b\u00b9\u00b3 ~3 \u00d7 10\u207b\u00b9\u00b2 800 ~1 \u00d7 10\u207b\u00b9\u2074 ~5 \u00d7 10\u207b\u00b9\u00b3"},{"location":"domains/space/#drag-force","title":"Drag Force","text":"<pre><code>F_drag = -\u00bd \u00d7 \u03c1 \u00d7 Cd \u00d7 A \u00d7 V\u00b2 \u00d7 v\u0302\n</code></pre>"},{"location":"domains/space/#usage_2","title":"Usage","text":"<pre><code>JB08AtmosphereModel atm;\natm.set_space_weather(150.0, 145.0, 15.0);  // Moderate activity\n\nAtmosphericDragModel drag;\ndrag.set_cd(2.2);\ndrag.set_area(10.0);  // m\u00b2\n\n// Compute drag force\ndrag.compute_forces(state, env, dt, forces);\n</code></pre>"},{"location":"domains/space/#coordinate-transformations","title":"Coordinate Transformations","text":""},{"location":"domains/space/#supported-frames","title":"Supported Frames","text":"Frame Origin Axes Use Case ECI J2000 Earth center Inertial Orbit propagation ECEF Earth center Earth-fixed Ground track Geodetic Earth surface lat/lon/alt Ground stations"},{"location":"domains/space/#conversions","title":"Conversions","text":"<pre><code>using namespace transforms;\n\n// ECI to ECEF\nVec3 pos_ecef = eci_to_ecef(pos_eci, julian_date);\n\n// ECEF to geodetic\nReal lat, lon, alt;\necef_to_geodetic(pos_ecef, lat, lon, alt);\n\n// Ground station to ECEF\nVec3 station = geodetic_to_ecef(\n    37.0 * DEG_TO_RAD,   // Latitude\n    -122.0 * DEG_TO_RAD, // Longitude\n    100.0                // Altitude (m)\n);\n</code></pre>"},{"location":"domains/space/#spacecraft-configuration","title":"Spacecraft Configuration","text":"<pre><code>&lt;entity type=\"spacecraft\" name=\"GPS-IIR\"&gt;\n    &lt;mass_balance&gt;\n        &lt;dry_mass unit=\"kg\"&gt;1080&lt;/dry_mass&gt;\n        &lt;fuel_mass unit=\"kg\"&gt;350&lt;/fuel_mass&gt;\n    &lt;/mass_balance&gt;\n\n    &lt;aerodynamics&gt;\n        &lt;drag_coefficient&gt;2.2&lt;/drag_coefficient&gt;\n        &lt;cross_section unit=\"m2\"&gt;10.0&lt;/cross_section&gt;\n    &lt;/aerodynamics&gt;\n\n    &lt;srp&gt;\n        &lt;reflectivity&gt;0.8&lt;/reflectivity&gt;\n        &lt;area unit=\"m2\"&gt;15.0&lt;/area&gt;\n    &lt;/srp&gt;\n\n    &lt;orbit&gt;\n        &lt;semi_major_axis unit=\"km\"&gt;26560&lt;/semi_major_axis&gt;\n        &lt;eccentricity&gt;0.0&lt;/eccentricity&gt;\n        &lt;inclination unit=\"deg\"&gt;55.0&lt;/inclination&gt;\n    &lt;/orbit&gt;\n&lt;/entity&gt;\n</code></pre>"},{"location":"domains/space/#performance-guidelines","title":"Performance Guidelines","text":"Application Integration Step Notes SGP4 Direct use Pre-integrated analytical Numerical (LEO) 10-60 seconds RK4 or higher High fidelity Adaptive Variable step-size"},{"location":"domains/space/#see-also","title":"See Also","text":"<ul> <li>Air Domain - Aircraft simulation</li> <li>Land Domain - Ground vehicle simulation</li> <li>Sea Domain - Naval vessel simulation</li> <li>Examples - Complete code examples</li> </ul>"},{"location":"getting-started/first-simulation/","title":"Your First Complete Simulation","text":"<p>This guide walks you through building a complete, interactive flight simulation with JaguarEngine.</p>"},{"location":"getting-started/first-simulation/#what-youll-build","title":"What You'll Build","text":"<p>By the end of this tutorial, you'll have:</p> <ul> <li>A configurable F-16 aircraft model</li> <li>Realistic aerodynamics and propulsion</li> <li>Flight control with keyboard input</li> <li>Real-time telemetry display</li> <li>Data logging for analysis</li> </ul>"},{"location":"getting-started/first-simulation/#project-structure","title":"Project Structure","text":"<pre><code>my_flight_sim/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main.cpp\n\u2502   \u251c\u2500\u2500 aircraft.h\n\u2502   \u251c\u2500\u2500 aircraft.cpp\n\u2502   \u2514\u2500\u2500 telemetry.h\n\u251c\u2500\u2500 config/\n\u2502   \u2514\u2500\u2500 f16.xml\n\u2514\u2500\u2500 output/\n    \u2514\u2500\u2500 flight_data.csv\n</code></pre>"},{"location":"getting-started/first-simulation/#step-1-aircraft-configuration","title":"Step 1: Aircraft Configuration","text":"<p>Create <code>config/f16.xml</code>:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;entity&gt;\n    &lt;name&gt;F-16C&lt;/name&gt;\n    &lt;domain&gt;air&lt;/domain&gt;\n\n    &lt;!-- Mass Properties --&gt;\n    &lt;mass&gt;\n        &lt;empty_kg&gt;8570&lt;/empty_kg&gt;\n        &lt;fuel_capacity_kg&gt;3200&lt;/fuel_capacity_kg&gt;\n        &lt;center_of_gravity&gt;\n            &lt;x_m&gt;0.0&lt;/x_m&gt;\n            &lt;y_m&gt;0.0&lt;/y_m&gt;\n            &lt;z_m&gt;0.0&lt;/z_m&gt;\n        &lt;/center_of_gravity&gt;\n        &lt;inertia&gt;\n            &lt;ixx&gt;12875&lt;/ixx&gt;\n            &lt;iyy&gt;75674&lt;/iyy&gt;\n            &lt;izz&gt;85552&lt;/izz&gt;\n            &lt;ixy&gt;0&lt;/ixy&gt;\n            &lt;ixz&gt;1331&lt;/ixz&gt;\n            &lt;iyz&gt;0&lt;/iyz&gt;\n        &lt;/inertia&gt;\n    &lt;/mass&gt;\n\n    &lt;!-- Aerodynamic Reference --&gt;\n    &lt;aerodynamics&gt;\n        &lt;reference_area_m2&gt;27.87&lt;/reference_area_m2&gt;\n        &lt;reference_chord_m&gt;3.45&lt;/reference_chord_m&gt;\n        &lt;reference_span_m&gt;9.45&lt;/reference_span_m&gt;\n\n        &lt;!-- Basic coefficients (simplified) --&gt;\n        &lt;cl_alpha&gt;5.5&lt;/cl_alpha&gt;\n        &lt;cl_0&gt;0.2&lt;/cl_0&gt;\n        &lt;cd_0&gt;0.021&lt;/cd_0&gt;\n        &lt;cd_k&gt;0.12&lt;/cd_k&gt;\n        &lt;cm_alpha&gt;-1.2&lt;/cm_alpha&gt;\n    &lt;/aerodynamics&gt;\n\n    &lt;!-- Propulsion --&gt;\n    &lt;propulsion&gt;\n        &lt;engine type=\"turbofan\"&gt;\n            &lt;name&gt;F110-GE-100&lt;/name&gt;\n            &lt;max_thrust_n&gt;131000&lt;/max_thrust_n&gt;\n            &lt;mil_thrust_n&gt;76300&lt;/mil_thrust_n&gt;\n            &lt;idle_thrust_n&gt;6000&lt;/idle_thrust_n&gt;\n            &lt;sfc_kg_per_n_s&gt;2.5e-5&lt;/sfc_kg_per_n_s&gt;\n        &lt;/engine&gt;\n    &lt;/propulsion&gt;\n\n    &lt;!-- Flight Control --&gt;\n    &lt;flight_control&gt;\n        &lt;elevator&gt;\n            &lt;min_deg&gt;-25&lt;/min_deg&gt;\n            &lt;max_deg&gt;25&lt;/max_deg&gt;\n            &lt;rate_limit_deg_s&gt;60&lt;/rate_limit_deg_s&gt;\n        &lt;/elevator&gt;\n        &lt;aileron&gt;\n            &lt;min_deg&gt;-21.5&lt;/min_deg&gt;\n            &lt;max_deg&gt;21.5&lt;/max_deg&gt;\n            &lt;rate_limit_deg_s&gt;80&lt;/rate_limit_deg_s&gt;\n        &lt;/aileron&gt;\n        &lt;rudder&gt;\n            &lt;min_deg&gt;-30&lt;/min_deg&gt;\n            &lt;max_deg&gt;30&lt;/max_deg&gt;\n            &lt;rate_limit_deg_s&gt;120&lt;/rate_limit_deg_s&gt;\n        &lt;/rudder&gt;\n    &lt;/flight_control&gt;\n&lt;/entity&gt;\n</code></pre>"},{"location":"getting-started/first-simulation/#step-2-aircraft-class","title":"Step 2: Aircraft Class","text":"<p>Create <code>src/aircraft.h</code>:</p> <pre><code>#pragma once\n\n#include &lt;jaguar/jaguar.h&gt;\n#include &lt;jaguar/domain/air.h&gt;\n#include &lt;string&gt;\n\nclass Aircraft {\npublic:\n    // Control inputs\n    struct Controls {\n        jaguar::Real pitch{0.0};     // -1 to +1\n        jaguar::Real roll{0.0};      // -1 to +1\n        jaguar::Real yaw{0.0};       // -1 to +1\n        jaguar::Real throttle{0.0};  // 0 to 1\n    };\n\n    // Telemetry output\n    struct Telemetry {\n        jaguar::Real time;\n        jaguar::Real altitude;       // m\n        jaguar::Real airspeed;       // m/s\n        jaguar::Real mach;\n        jaguar::Real alpha;          // deg\n        jaguar::Real beta;           // deg\n        jaguar::Real roll;           // deg\n        jaguar::Real pitch;          // deg\n        jaguar::Real heading;        // deg\n        jaguar::Real thrust;         // N\n        jaguar::Real fuel_remaining; // kg\n        jaguar::Real g_load;         // g's\n    };\n\n    Aircraft(jaguar::interface::Engine&amp; engine, const std::string&amp; config_path);\n    ~Aircraft() = default;\n\n    // Setup\n    void set_initial_state(\n        const jaguar::Vec3&amp; position,\n        const jaguar::Vec3&amp; velocity,\n        jaguar::Real fuel_kg\n    );\n\n    // Control\n    void set_controls(const Controls&amp; controls);\n    void update(jaguar::Real dt);\n\n    // Telemetry\n    Telemetry get_telemetry() const;\n    jaguar::EntityId get_entity_id() const { return entity_id_; }\n\nprivate:\n    jaguar::interface::Engine&amp; engine_;\n    jaguar::EntityId entity_id_;\n\n    // Physics models\n    jaguar::domain::air::AerodynamicsModel aero_;\n    jaguar::domain::air::PropulsionModel propulsion_;\n    jaguar::domain::air::FlightControlSystem fcs_;\n\n    // Current state\n    Controls controls_;\n    jaguar::physics::EntityForces forces_;\n    jaguar::Real sim_time_{0.0};\n};\n</code></pre> <p>Create <code>src/aircraft.cpp</code>:</p> <pre><code>#include \"aircraft.h\"\n#include &lt;cmath&gt;\n\nAircraft::Aircraft(jaguar::interface::Engine&amp; engine, const std::string&amp; config_path)\n    : engine_(engine)\n{\n    // Create entity\n    entity_id_ = engine_.create_entity(\"F-16\", jaguar::Domain::Air);\n\n    // Configure aerodynamics (F-16 values)\n    aero_.set_reference_area(27.87);\n    aero_.set_reference_chord(3.45);\n    aero_.set_reference_span(9.45);\n\n    // Configure propulsion (F110 engine)\n    propulsion_.set_max_thrust(131000.0);\n    propulsion_.set_fuel_capacity(3200.0);\n    propulsion_.set_specific_fuel_consumption(2.5e-5);\n    propulsion_.start();\n\n    // Configure flight control limits\n    fcs_.set_elevator_range(-25.0, 25.0);\n    fcs_.set_aileron_range(-21.5, 21.5);\n    fcs_.set_rudder_range(-30.0, 30.0);\n}\n\nvoid Aircraft::set_initial_state(\n    const jaguar::Vec3&amp; position,\n    const jaguar::Vec3&amp; velocity,\n    jaguar::Real fuel_kg)\n{\n    jaguar::physics::EntityState state;\n    state.position = position;\n    state.velocity = velocity;\n    state.orientation = jaguar::Quaternion::identity();\n    state.angular_velocity = {0, 0, 0};\n\n    // Mass = empty + fuel\n    state.mass = 8570.0 + fuel_kg;\n\n    // Inertia tensor (simplified)\n    state.inertia = jaguar::Mat3x3{{\n        {12875, 0, 1331},\n        {0, 75674, 0},\n        {1331, 0, 85552}\n    }};\n\n    engine_.set_entity_state(entity_id_, state);\n}\n\nvoid Aircraft::set_controls(const Controls&amp; controls) {\n    controls_ = controls;\n    propulsion_.set_throttle(controls.throttle);\n}\n\nvoid Aircraft::update(jaguar::Real dt) {\n    auto state = engine_.get_entity_state(entity_id_);\n    auto env = engine_.get_environment(entity_id_);\n\n    // Clear forces\n    forces_.clear();\n\n    // Flight control surface deflections\n    jaguar::domain::air::FlightControlSystem::ControlInputs fcs_in;\n    fcs_in.pitch_cmd = controls_.pitch;\n    fcs_in.roll_cmd = controls_.roll;\n    fcs_in.yaw_cmd = controls_.yaw;\n    fcs_in.throttle_cmd = controls_.throttle;\n\n    auto fcs_out = fcs_.process(fcs_in, dt);\n\n    // Aerodynamic forces\n    aero_.compute_forces(state, env, dt, forces_);\n\n    // Propulsion forces\n    propulsion_.compute_forces(state, env, dt, forces_);\n\n    // Gravity\n    jaguar::Vec3 gravity{0, 0, state.mass * jaguar::constants::G0};\n    forces_.add_force(gravity);\n\n    // Apply forces\n    engine_.apply_forces(entity_id_, forces_);\n\n    sim_time_ += dt;\n}\n\nAircraft::Telemetry Aircraft::get_telemetry() const {\n    auto state = engine_.get_entity_state(entity_id_);\n\n    Telemetry t;\n    t.time = sim_time_;\n    t.altitude = -state.position.z;\n    t.airspeed = state.velocity.norm();\n    t.mach = aero_.get_mach();\n    t.alpha = aero_.get_alpha() * jaguar::constants::RAD_TO_DEG;\n    t.beta = aero_.get_beta() * jaguar::constants::RAD_TO_DEG;\n\n    // Euler angles\n    jaguar::Real roll, pitch, yaw;\n    state.orientation.to_euler(roll, pitch, yaw);\n    t.roll = roll * jaguar::constants::RAD_TO_DEG;\n    t.pitch = pitch * jaguar::constants::RAD_TO_DEG;\n    t.heading = yaw * jaguar::constants::RAD_TO_DEG;\n    if (t.heading &lt; 0) t.heading += 360.0;\n\n    t.thrust = propulsion_.get_thrust();\n    t.fuel_remaining = propulsion_.get_fuel_remaining();\n\n    // G-load (simplified: lift / weight)\n    t.g_load = 1.0;  // Would compute from forces\n\n    return t;\n}\n</code></pre>"},{"location":"getting-started/first-simulation/#step-3-telemetry-display","title":"Step 3: Telemetry Display","text":"<p>Create <code>src/telemetry.h</code>:</p> <pre><code>#pragma once\n\n#include \"aircraft.h\"\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;fstream&gt;\n\nclass TelemetryDisplay {\npublic:\n    void print_header() {\n        std::cout &lt;&lt; \"\\n\";\n        std::cout &lt;&lt; \"\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\\n\";\n        std::cout &lt;&lt; \"\u2551                    JaguarEngine Flight Simulator                  \u2551\\n\";\n        std::cout &lt;&lt; \"\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\\n\";\n        std::cout &lt;&lt; \"\u2551  Time \u2502 Alt (ft) \u2502 IAS (kt) \u2502 Mach \u2502 Alpha \u2502 G's \u2502 Fuel (lb)    \u2551\\n\";\n        std::cout &lt;&lt; \"\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\\n\";\n    }\n\n    void print_telemetry(const Aircraft::Telemetry&amp; t) {\n        // Convert to aviation units\n        double alt_ft = t.altitude * 3.28084;\n        double ias_kt = t.airspeed * 1.94384;\n        double fuel_lb = t.fuel_remaining * 2.20462;\n\n        std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1);\n        std::cout &lt;&lt; \"\u2551 \" &lt;&lt; std::setw(5) &lt;&lt; t.time &lt;&lt; \" \u2502 \"\n                  &lt;&lt; std::setw(8) &lt;&lt; alt_ft &lt;&lt; \" \u2502 \"\n                  &lt;&lt; std::setw(8) &lt;&lt; ias_kt &lt;&lt; \" \u2502 \"\n                  &lt;&lt; std::setw(4) &lt;&lt; std::setprecision(2) &lt;&lt; t.mach &lt;&lt; \" \u2502 \"\n                  &lt;&lt; std::setw(5) &lt;&lt; std::setprecision(1) &lt;&lt; t.alpha &lt;&lt; \" \u2502 \"\n                  &lt;&lt; std::setw(4) &lt;&lt; std::setprecision(1) &lt;&lt; t.g_load &lt;&lt; \" \u2502 \"\n                  &lt;&lt; std::setw(8) &lt;&lt; fuel_lb &lt;&lt; \"     \u2551\\n\";\n    }\n\n    void print_footer() {\n        std::cout &lt;&lt; \"\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\\n\";\n    }\n};\n\nclass DataLogger {\npublic:\n    DataLogger(const std::string&amp; filename) : file_(filename) {\n        file_ &lt;&lt; \"time,altitude,airspeed,mach,alpha,beta,roll,pitch,heading,thrust,fuel,g_load\\n\";\n    }\n\n    void log(const Aircraft::Telemetry&amp; t) {\n        file_ &lt;&lt; t.time &lt;&lt; \",\"\n              &lt;&lt; t.altitude &lt;&lt; \",\"\n              &lt;&lt; t.airspeed &lt;&lt; \",\"\n              &lt;&lt; t.mach &lt;&lt; \",\"\n              &lt;&lt; t.alpha &lt;&lt; \",\"\n              &lt;&lt; t.beta &lt;&lt; \",\"\n              &lt;&lt; t.roll &lt;&lt; \",\"\n              &lt;&lt; t.pitch &lt;&lt; \",\"\n              &lt;&lt; t.heading &lt;&lt; \",\"\n              &lt;&lt; t.thrust &lt;&lt; \",\"\n              &lt;&lt; t.fuel_remaining &lt;&lt; \",\"\n              &lt;&lt; t.g_load &lt;&lt; \"\\n\";\n    }\n\nprivate:\n    std::ofstream file_;\n};\n</code></pre>"},{"location":"getting-started/first-simulation/#step-4-main-simulation","title":"Step 4: Main Simulation","text":"<p>Create <code>src/main.cpp</code>:</p> <pre><code>#include &lt;jaguar/jaguar.h&gt;\n#include \"aircraft.h\"\n#include \"telemetry.h\"\n#include &lt;iostream&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n\nvoid print_controls_help() {\n    std::cout &lt;&lt; \"\\nFlight Controls:\\n\";\n    std::cout &lt;&lt; \"  W/S - Pitch down/up\\n\";\n    std::cout &lt;&lt; \"  A/D - Roll left/right\\n\";\n    std::cout &lt;&lt; \"  Q/E - Yaw left/right\\n\";\n    std::cout &lt;&lt; \"  +/- - Throttle up/down\\n\";\n    std::cout &lt;&lt; \"  ESC - Exit\\n\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    std::cout &lt;&lt; \"\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\\n\";\n    std::cout &lt;&lt; \"\u2551     JaguarEngine Flight Simulation Demo           \u2551\\n\";\n    std::cout &lt;&lt; \"\u2551     Version: \" &lt;&lt; jaguar::GetVersionString() &lt;&lt; \"                            \u2551\\n\";\n    std::cout &lt;&lt; \"\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\\n\";\n\n    // Initialize engine\n    jaguar::interface::Engine engine;\n    if (!engine.initialize()) {\n        std::cerr &lt;&lt; \"Error: Failed to initialize JaguarEngine\\n\";\n        return 1;\n    }\n    std::cout &lt;&lt; \"Engine initialized.\\n\";\n\n    // Create aircraft\n    Aircraft f16(engine, \"config/f16.xml\");\n\n    // Set initial conditions: 20,000 ft, 400 knots, heading north\n    jaguar::Vec3 initial_pos{0.0, 0.0, -6096.0};  // 20,000 ft in meters\n    jaguar::Vec3 initial_vel{205.8, 0.0, 0.0};    // 400 knots in m/s\n    f16.set_initial_state(initial_pos, initial_vel, 2500.0);  // 2500 kg fuel\n\n    std::cout &lt;&lt; \"Aircraft spawned at 20,000 ft, 400 KIAS\\n\";\n\n    // Set initial throttle\n    Aircraft::Controls controls;\n    controls.throttle = 0.8;  // 80% power\n    f16.set_controls(controls);\n\n    // Create telemetry display and logger\n    TelemetryDisplay display;\n    DataLogger logger(\"output/flight_data.csv\");\n\n    print_controls_help();\n    display.print_header();\n\n    // Simulation parameters\n    const jaguar::Real dt = 0.01;           // 100 Hz physics\n    const jaguar::Real display_rate = 1.0;  // 1 Hz display\n    const jaguar::Real sim_duration = 60.0; // 60 seconds\n\n    jaguar::Real last_display = 0.0;\n\n    // Main simulation loop\n    for (jaguar::Real t = 0.0; t &lt; sim_duration; t += dt) {\n        // Update physics\n        f16.update(dt);\n        engine.step(dt);\n\n        // Get telemetry\n        auto telemetry = f16.get_telemetry();\n\n        // Log data (every step)\n        logger.log(telemetry);\n\n        // Display (every second)\n        if (t - last_display &gt;= display_rate) {\n            display.print_telemetry(telemetry);\n            last_display = t;\n        }\n\n        // Simple maneuver: gentle climb at t=10, level off at t=30\n        if (t &gt;= 10.0 &amp;&amp; t &lt; 30.0) {\n            controls.pitch = -0.1;  // Slight nose up\n        } else if (t &gt;= 30.0 &amp;&amp; t &lt; 35.0) {\n            controls.pitch = 0.05;  // Nose down to level\n        } else {\n            controls.pitch = 0.0;\n        }\n        f16.set_controls(controls);\n    }\n\n    display.print_footer();\n\n    // Final status\n    auto final_telemetry = f16.get_telemetry();\n    std::cout &lt;&lt; \"\\nFinal Status:\\n\";\n    std::cout &lt;&lt; \"  Altitude: \" &lt;&lt; final_telemetry.altitude * 3.28084 &lt;&lt; \" ft\\n\";\n    std::cout &lt;&lt; \"  Airspeed: \" &lt;&lt; final_telemetry.airspeed * 1.94384 &lt;&lt; \" kt\\n\";\n    std::cout &lt;&lt; \"  Fuel remaining: \" &lt;&lt; final_telemetry.fuel_remaining * 2.20462 &lt;&lt; \" lb\\n\";\n    std::cout &lt;&lt; \"\\nFlight data saved to: output/flight_data.csv\\n\";\n\n    // Cleanup\n    engine.shutdown();\n    std::cout &lt;&lt; \"Simulation complete.\\n\";\n\n    return 0;\n}\n</code></pre>"},{"location":"getting-started/first-simulation/#step-5-cmakeliststxt","title":"Step 5: CMakeLists.txt","text":"<pre><code>cmake_minimum_required(VERSION 3.25)\nproject(MyFlightSim VERSION 1.0.0)\n\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n# Find JaguarEngine\nfind_package(Jaguar REQUIRED)\n\n# Create executable\nadd_executable(flight_sim\n    src/main.cpp\n    src/aircraft.cpp\n)\n\ntarget_include_directories(flight_sim PRIVATE src)\ntarget_link_libraries(flight_sim PRIVATE Jaguar::jaguar)\n\n# Create output directory\nfile(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/output)\n\n# Copy config files\nfile(COPY config DESTINATION ${CMAKE_BINARY_DIR})\n</code></pre>"},{"location":"getting-started/first-simulation/#step-6-build-and-run","title":"Step 6: Build and Run","text":"<pre><code># Create directories\nmkdir -p config output\n\n# Build\nmkdir build &amp;&amp; cd build\ncmake ..\nmake\n\n# Run\n./flight_sim\n</code></pre>"},{"location":"getting-started/first-simulation/#expected-output","title":"Expected Output","text":"<pre><code>\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551     JaguarEngine Flight Simulation Demo           \u2551\n\u2551     Version: 0.4.0                                \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\nEngine initialized.\nAircraft spawned at 20,000 ft, 400 KIAS\n\nFlight Controls:\n  W/S - Pitch down/up\n  A/D - Roll left/right\n  Q/E - Yaw left/right\n  +/- - Throttle up/down\n  ESC - Exit\n\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                    JaguarEngine Flight Simulator                  \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551  Time \u2502 Alt (ft) \u2502 IAS (kt) \u2502 Mach \u2502 Alpha \u2502 G's \u2502 Fuel (lb)    \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551   0.0 \u2502  20000.0 \u2502    400.0 \u2502 0.62 \u2502   2.1 \u2502  1.0 \u2502   5511.6     \u2551\n\u2551   1.0 \u2502  19998.2 \u2502    399.5 \u2502 0.62 \u2502   2.1 \u2502  1.0 \u2502   5509.1     \u2551\n\u2551   2.0 \u2502  19996.4 \u2502    399.0 \u2502 0.62 \u2502   2.2 \u2502  1.0 \u2502   5506.6     \u2551\n...\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\nFinal Status:\n  Altitude: 22450.3 ft\n  Airspeed: 385.2 kt\n  Fuel remaining: 5312.4 lb\n\nFlight data saved to: output/flight_data.csv\nSimulation complete.\n</code></pre>"},{"location":"getting-started/first-simulation/#analyzing-results","title":"Analyzing Results","text":"<p>The simulation outputs CSV data that you can analyze:</p> <pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv('output/flight_data.csv')\n\n# Plot altitude profile\nfig, axes = plt.subplots(2, 2, figsize=(12, 8))\n\naxes[0, 0].plot(df['time'], df['altitude'] * 3.28084)\naxes[0, 0].set_xlabel('Time (s)')\naxes[0, 0].set_ylabel('Altitude (ft)')\naxes[0, 0].set_title('Altitude Profile')\naxes[0, 0].grid(True)\n\naxes[0, 1].plot(df['time'], df['airspeed'] * 1.94384)\naxes[0, 1].set_xlabel('Time (s)')\naxes[0, 1].set_ylabel('Airspeed (kt)')\naxes[0, 1].set_title('Airspeed Profile')\naxes[0, 1].grid(True)\n\naxes[1, 0].plot(df['time'], df['alpha'])\naxes[1, 0].set_xlabel('Time (s)')\naxes[1, 0].set_ylabel('Alpha (deg)')\naxes[1, 0].set_title('Angle of Attack')\naxes[1, 0].grid(True)\n\naxes[1, 1].plot(df['time'], df['fuel'] * 2.20462)\naxes[1, 1].set_xlabel('Time (s)')\naxes[1, 1].set_ylabel('Fuel (lb)')\naxes[1, 1].set_title('Fuel Consumption')\naxes[1, 1].grid(True)\n\nplt.tight_layout()\nplt.savefig('flight_analysis.png')\nplt.show()\n</code></pre>"},{"location":"getting-started/first-simulation/#next-steps","title":"Next Steps","text":"<ul> <li>Add Terrain - Add terrain collision and following</li> <li>Air Domain - Implement aircraft control systems</li> <li>Multi-Aircraft - Simulate multiple aircraft</li> <li>Python Integration - Use Python for analysis</li> </ul>"},{"location":"getting-started/installation/","title":"Installation Guide","text":"<p>This guide covers building JaguarEngine from source on various platforms.</p>"},{"location":"getting-started/installation/#system-requirements","title":"System Requirements","text":""},{"location":"getting-started/installation/#minimum-requirements","title":"Minimum Requirements","text":"Component Requirement CPU x86_64 or ARM64 processor RAM 4 GB (8 GB recommended for development) Disk 1 GB free space OS Linux, macOS 12+, Windows 10+"},{"location":"getting-started/installation/#compiler-requirements","title":"Compiler Requirements","text":"<p>JaguarEngine requires a C++20 compatible compiler:</p> Compiler Minimum Version GCC 11.0+ Clang 14.0+ AppleClang 15.0+ MSVC Visual Studio 2022 (17.0+)"},{"location":"getting-started/installation/#build-tools","title":"Build Tools","text":"<ul> <li>CMake: 3.25 or later</li> <li>Make/Ninja: Any recent version</li> </ul>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":""},{"location":"getting-started/installation/#required-auto-fetched","title":"Required (Auto-fetched)","text":"<p>These dependencies are automatically downloaded by CMake if not found on your system:</p> Library Version Purpose Eigen3 3.4.0 Linear algebra, matrix operations pugixml 1.14 XML configuration parsing GoogleTest 1.14.0 Unit testing framework Google Benchmark 1.8.3 Performance benchmarking"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":"Library Version Purpose CMake Option GDAL 3.0+ Geospatial terrain loading Auto-detected pybind11 2.11+ Python bindings <code>JAGUAR_BUILD_PYTHON</code> sol2 3.3+ Lua bindings <code>JAGUAR_BUILD_LUA</code> OpenDIS - DIS protocol <code>JAGUAR_ENABLE_DIS</code> HLA RTI - HLA protocol <code>JAGUAR_ENABLE_HLA</code>"},{"location":"getting-started/installation/#quick-installation","title":"Quick Installation","text":""},{"location":"getting-started/installation/#linux-macos","title":"Linux / macOS","text":"<pre><code># Clone repository\ngit clone https://github.com/jaguarcode/JaguarEngine.git\ncd JaguarEngine\n\n# Create build directory\nmkdir build &amp;&amp; cd build\n\n# Configure (dependencies auto-fetched)\ncmake ..\n\n# Build (use all available cores)\nmake -j$(nproc)\n\n# Run tests to verify installation\n./jaguar_unit_tests\n</code></pre>"},{"location":"getting-started/installation/#windows-visual-studio","title":"Windows (Visual Studio)","text":"<pre><code># Clone repository\ngit clone https://github.com/jaguarcode/JaguarEngine.git\ncd JaguarEngine\n\n# Create build directory\nmkdir build\ncd build\n\n# Configure for Visual Studio 2022\ncmake .. -G \"Visual Studio 17 2022\" -A x64\n\n# Build\ncmake --build . --config Release\n\n# Run tests\n.\\Release\\jaguar_unit_tests.exe\n</code></pre>"},{"location":"getting-started/installation/#platform-specific-instructions","title":"Platform-Specific Instructions","text":""},{"location":"getting-started/installation/#ubuntu-debian","title":"Ubuntu / Debian","text":"<pre><code># Install build tools\nsudo apt update\nsudo apt install -y build-essential cmake git\n\n# Optional: Install GDAL for terrain support\nsudo apt install -y libgdal-dev\n\n# Optional: Install Python development for bindings\nsudo apt install -y python3-dev python3-pip\n\n# Build\ncd JaguarEngine\nmkdir build &amp;&amp; cd build\ncmake ..\nmake -j$(nproc)\n</code></pre>"},{"location":"getting-started/installation/#fedora-rhel","title":"Fedora / RHEL","text":"<pre><code># Install build tools\nsudo dnf install -y gcc-c++ cmake git\n\n# Optional: Install GDAL\nsudo dnf install -y gdal-devel\n\n# Build\ncd JaguarEngine\nmkdir build &amp;&amp; cd build\ncmake ..\nmake -j$(nproc)\n</code></pre>"},{"location":"getting-started/installation/#macos","title":"macOS","text":"<pre><code># Install Xcode Command Line Tools\nxcode-select --install\n\n# Install CMake via Homebrew\nbrew install cmake\n\n# Optional: Install GDAL\nbrew install gdal\n\n# Build\ncd JaguarEngine\nmkdir build &amp;&amp; cd build\ncmake ..\nmake -j$(sysctl -n hw.ncpu)\n</code></pre>"},{"location":"getting-started/installation/#windows","title":"Windows","text":"<ol> <li>Install Visual Studio 2022 with the C++ Desktop Development workload</li> <li>Install CMake (add to PATH)</li> <li>Install Git</li> </ol> <pre><code># From Developer PowerShell for VS 2022\ncd JaguarEngine\nmkdir build &amp;&amp; cd build\ncmake .. -G \"Visual Studio 17 2022\" -A x64\ncmake --build . --config Release --parallel\n</code></pre>"},{"location":"getting-started/installation/#build-options","title":"Build Options","text":""},{"location":"getting-started/installation/#cmake-configuration-options","title":"CMake Configuration Options","text":"<pre><code>cmake .. \\\n    -DCMAKE_BUILD_TYPE=Release \\\n    -DJAGUAR_BUILD_TESTS=ON \\\n    -DJAGUAR_BUILD_BENCHMARKS=ON \\\n    -DJAGUAR_BUILD_EXAMPLES=ON \\\n    -DJAGUAR_BUILD_PYTHON=OFF \\\n    -DJAGUAR_BUILD_LUA=OFF \\\n    -DJAGUAR_ENABLE_DIS=OFF \\\n    -DJAGUAR_ENABLE_HLA=OFF \\\n    -DJAGUAR_ENABLE_SIMD=ON\n</code></pre>"},{"location":"getting-started/installation/#build-types","title":"Build Types","text":"Build Type Description Use Case <code>Debug</code> No optimization, full debug symbols Development, debugging <code>Release</code> Full optimization (-O3) Production, benchmarking <code>RelWithDebInfo</code> Optimization with debug info Profiling <code>MinSizeRel</code> Optimize for size Embedded systems"},{"location":"getting-started/installation/#option-reference","title":"Option Reference","text":"Option Default Description <code>JAGUAR_BUILD_TESTS</code> ON Build GoogleTest-based unit tests <code>JAGUAR_BUILD_BENCHMARKS</code> ON Build Google Benchmark suite <code>JAGUAR_BUILD_EXAMPLES</code> ON Build example applications <code>JAGUAR_BUILD_PYTHON</code> OFF Build pybind11 Python module <code>JAGUAR_BUILD_LUA</code> OFF Build sol2 Lua bindings <code>JAGUAR_ENABLE_DIS</code> OFF Enable DIS network protocol <code>JAGUAR_ENABLE_HLA</code> OFF Enable HLA federation <code>JAGUAR_ENABLE_SIMD</code> ON Enable AVX2/FMA optimizations"},{"location":"getting-started/installation/#installing-jaguarengine","title":"Installing JaguarEngine","text":""},{"location":"getting-started/installation/#system-wide-installation","title":"System-wide Installation","text":"<pre><code>cd build\nsudo cmake --install . --prefix /usr/local\n</code></pre>"},{"location":"getting-started/installation/#custom-installation-path","title":"Custom Installation Path","text":"<pre><code>cmake --install . --prefix ~/local/jaguar\n</code></pre>"},{"location":"getting-started/installation/#using-in-your-cmake-project","title":"Using in Your CMake Project","text":"<p>After installation, use JaguarEngine in your CMake projects:</p> <pre><code># CMakeLists.txt\ncmake_minimum_required(VERSION 3.25)\nproject(MySimulation)\n\nfind_package(Jaguar REQUIRED)\n\nadd_executable(my_simulation main.cpp)\ntarget_link_libraries(my_simulation PRIVATE Jaguar::jaguar)\n</code></pre>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":""},{"location":"getting-started/installation/#run-unit-tests","title":"Run Unit Tests","text":"<pre><code>cd build\n./jaguar_unit_tests\n</code></pre> <p>Expected output:</p> <pre><code>[==========] Running 237 tests from 41 test suites.\n...\n[  PASSED  ] 237 tests.\n</code></pre>"},{"location":"getting-started/installation/#run-examples","title":"Run Examples","text":"<pre><code># Simple flight simulation\n./example_simple_flight\n\n# Multi-domain simulation\n./example_multi_domain\n</code></pre>"},{"location":"getting-started/installation/#check-build-configuration","title":"Check Build Configuration","text":"<pre><code>cmake -L ..   # List all options\ncmake -LA ..  # List all options including advanced\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/installation/#eigen3-not-found","title":"Eigen3 Not Found","text":"<pre><code>CMake Warning: Eigen3 not found, will use FetchContent\n</code></pre> <p>Solution: This is normal behavior. Eigen3 is automatically downloaded if not installed system-wide.</p>"},{"location":"getting-started/installation/#gdal-not-found","title":"GDAL Not Found","text":"<pre><code>CMake Warning: GDAL not found. Terrain features will be limited.\n</code></pre> <p>Solution: Install GDAL if you need terrain loading:</p> <ul> <li>Ubuntu: <code>sudo apt install libgdal-dev</code></li> <li>macOS: <code>brew install gdal</code></li> <li>Windows: Use OSGeo4W installer</li> </ul>"},{"location":"getting-started/installation/#compiler-too-old","title":"Compiler Too Old","text":"<pre><code>error: 'span' is not a member of 'std'\n</code></pre> <p>Solution: Upgrade to a C++20 compatible compiler:</p> <ul> <li>GCC 11+ (Ubuntu 22.04+ default)</li> <li>Clang 14+</li> <li>MSVC 2022</li> </ul>"},{"location":"getting-started/installation/#build-fails-on-arm-mac-rosetta","title":"Build Fails on ARM Mac (Rosetta)","text":"<pre><code>error: -march=native requires native target\n</code></pre> <p>Solution: The build system automatically detects Rosetta and disables native optimizations. Ensure you're using the latest CMakeLists.txt.</p>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<ol> <li>Check existing GitHub Issues</li> <li>Search the documentation</li> <li>Open a new issue with:</li> <li>OS and version</li> <li>Compiler version (<code>g++ --version</code>)</li> <li>CMake version (<code>cmake --version</code>)</li> <li>Full error output</li> </ol>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Tutorial - Your first simulation</li> <li>Examples Guide - Code examples for all domains</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>Get up and running with JaguarEngine in under 10 minutes.</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li> JaguarEngine built and installed (Installation Guide)</li> <li> C++ development environment (compiler, IDE)</li> <li> Basic understanding of physics simulation concepts</li> </ul>"},{"location":"getting-started/quickstart/#your-first-simulation","title":"Your First Simulation","text":""},{"location":"getting-started/quickstart/#step-1-create-a-new-project","title":"Step 1: Create a New Project","text":"<p>Create a new directory for your simulation project:</p> <pre><code>mkdir my_first_simulation\ncd my_first_simulation\n</code></pre> <p>Create a <code>CMakeLists.txt</code>:</p> <pre><code>cmake_minimum_required(VERSION 3.25)\nproject(MyFirstSimulation)\n\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n# Find JaguarEngine\nfind_package(Jaguar REQUIRED)\n\n# Create executable\nadd_executable(simulation main.cpp)\ntarget_link_libraries(simulation PRIVATE Jaguar::jaguar)\n</code></pre>"},{"location":"getting-started/quickstart/#step-2-write-your-simulation","title":"Step 2: Write Your Simulation","text":"<p>Create <code>main.cpp</code>:</p> <pre><code>#include &lt;jaguar/jaguar.h&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nint main() {\n    std::cout &lt;&lt; \"JaguarEngine Quick Start Example\\n\";\n    std::cout &lt;&lt; \"Version: \" &lt;&lt; jaguar::GetVersionString() &lt;&lt; \"\\n\\n\";\n\n    // Step 1: Create and initialize the engine\n    jaguar::interface::Engine engine;\n\n    if (!engine.initialize()) {\n        std::cerr &lt;&lt; \"Failed to initialize engine\\n\";\n        return 1;\n    }\n    std::cout &lt;&lt; \"Engine initialized successfully\\n\";\n\n    // Step 2: Create an aircraft entity\n    jaguar::EntityId aircraft = engine.create_entity(\"F-16\", jaguar::Domain::Air);\n    std::cout &lt;&lt; \"Created aircraft entity (ID: \" &lt;&lt; aircraft &lt;&lt; \")\\n\";\n\n    // Step 3: Set initial state\n    jaguar::physics::EntityState initial_state;\n    initial_state.position = jaguar::Vec3{0.0, 0.0, -10000.0};  // 10 km altitude (NED)\n    initial_state.velocity = jaguar::Vec3{250.0, 0.0, 0.0};     // 250 m/s forward\n    initial_state.orientation = jaguar::Quaternion::identity();  // Level flight\n    initial_state.mass = 12000.0;                                // 12,000 kg\n\n    engine.set_entity_state(aircraft, initial_state);\n    std::cout &lt;&lt; \"Initial state set\\n\\n\";\n\n    // Step 4: Run simulation loop\n    const jaguar::Real dt = 0.01;  // 100 Hz update rate\n    const jaguar::Real duration = 10.0;  // 10 seconds\n\n    std::cout &lt;&lt; \"Running simulation for \" &lt;&lt; duration &lt;&lt; \" seconds...\\n\";\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2);\n    std::cout &lt;&lt; \"--------------------------------------------\\n\";\n    std::cout &lt;&lt; \"  Time (s)  |  Altitude (m)  |  Speed (m/s)\\n\";\n    std::cout &lt;&lt; \"--------------------------------------------\\n\";\n\n    for (jaguar::Real t = 0; t &lt;= duration; t += dt) {\n        // Advance simulation\n        engine.step(dt);\n\n        // Print status every second\n        if (static_cast&lt;int&gt;(t * 100) % 100 == 0) {\n            auto state = engine.get_entity_state(aircraft);\n            jaguar::Real altitude = -state.position.z;  // NED: negative z is up\n            jaguar::Real speed = state.velocity.norm();\n\n            std::cout &lt;&lt; \"    \" &lt;&lt; std::setw(6) &lt;&lt; t\n                      &lt;&lt; \"    |    \" &lt;&lt; std::setw(8) &lt;&lt; altitude\n                      &lt;&lt; \"    |    \" &lt;&lt; std::setw(6) &lt;&lt; speed &lt;&lt; \"\\n\";\n        }\n    }\n\n    std::cout &lt;&lt; \"--------------------------------------------\\n\";\n    std::cout &lt;&lt; \"Simulation complete!\\n\";\n\n    // Step 5: Get final state\n    auto final_state = engine.get_entity_state(aircraft);\n    std::cout &lt;&lt; \"\\nFinal Position: (\"\n              &lt;&lt; final_state.position.x &lt;&lt; \", \"\n              &lt;&lt; final_state.position.y &lt;&lt; \", \"\n              &lt;&lt; final_state.position.z &lt;&lt; \") m\\n\";\n    std::cout &lt;&lt; \"Final Velocity: (\"\n              &lt;&lt; final_state.velocity.x &lt;&lt; \", \"\n              &lt;&lt; final_state.velocity.y &lt;&lt; \", \"\n              &lt;&lt; final_state.velocity.z &lt;&lt; \") m/s\\n\";\n\n    // Step 6: Clean up\n    engine.shutdown();\n    std::cout &lt;&lt; \"Engine shutdown complete\\n\";\n\n    return 0;\n}\n</code></pre>"},{"location":"getting-started/quickstart/#step-3-build-and-run","title":"Step 3: Build and Run","text":"<pre><code># Configure\nmkdir build &amp;&amp; cd build\ncmake ..\n\n# Build\nmake\n\n# Run\n./simulation\n</code></pre> <p>Expected Output:</p> <pre><code>JaguarEngine Quick Start Example\nVersion: 0.4.0\n\nEngine initialized successfully\nCreated aircraft entity (ID: 1)\nInitial state set\n\nRunning simulation for 10.00 seconds...\n--------------------------------------------\n  Time (s)  |  Altitude (m)  |  Speed (m/s)\n--------------------------------------------\n      0.00    |    10000.00    |   250.00\n      1.00    |     9951.23    |   249.85\n      2.00    |     9902.46    |   249.70\n      3.00    |     9853.69    |   249.55\n      ...\n     10.00    |     9512.30    |   248.50\n--------------------------------------------\nSimulation complete!\n\nFinal Position: (2485.00, 0.00, -9512.30) m\nFinal Velocity: (248.50, 0.00, 0.15) m/s\nEngine shutdown complete\n</code></pre>"},{"location":"getting-started/quickstart/#understanding-the-code","title":"Understanding the Code","text":""},{"location":"getting-started/quickstart/#engine-lifecycle","title":"Engine Lifecycle","text":"<pre><code>// 1. Create engine instance\njaguar::interface::Engine engine;\n\n// 2. Initialize (loads configuration, sets up subsystems)\nengine.initialize();\n\n// 3. Use the engine (create entities, run simulation)\n// ...\n\n// 4. Clean shutdown (releases resources)\nengine.shutdown();\n</code></pre>"},{"location":"getting-started/quickstart/#entity-management","title":"Entity Management","text":"<pre><code>// Create entity with name and domain\njaguar::EntityId id = engine.create_entity(\"name\", jaguar::Domain::Air);\n\n// Set entity state\nengine.set_entity_state(id, state);\n\n// Get entity state\nauto state = engine.get_entity_state(id);\n\n// Destroy entity when done\nengine.destroy_entity(id);\n</code></pre>"},{"location":"getting-started/quickstart/#coordinate-system-ned","title":"Coordinate System (NED)","text":"<p>JaguarEngine uses the North-East-Down (NED) coordinate frame:</p> <ul> <li>X: North (positive forward)</li> <li>Y: East (positive right)</li> <li>Z: Down (positive into earth, negative is altitude)</li> </ul> <pre><code>// 10 km altitude: z = -10000\nstate.position = {0.0, 0.0, -10000.0};\n\n// Flying north at 250 m/s\nstate.velocity = {250.0, 0.0, 0.0};\n</code></pre>"},{"location":"getting-started/quickstart/#simulation-loop","title":"Simulation Loop","text":"<pre><code>const jaguar::Real dt = 0.01;  // Time step (seconds)\n\nfor (jaguar::Real t = 0; t &lt; duration; t += dt) {\n    // 1. Update entity controls (if needed)\n    // 2. Advance physics\n    engine.step(dt);\n    // 3. Read results\n    auto state = engine.get_entity_state(entity);\n}\n</code></pre>"},{"location":"getting-started/quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/quickstart/#setting-up-multiple-entities","title":"Setting Up Multiple Entities","text":"<pre><code>// Create entities for different domains\nauto aircraft = engine.create_entity(\"F-16\", jaguar::Domain::Air);\nauto tank = engine.create_entity(\"M1A2\", jaguar::Domain::Land);\nauto ship = engine.create_entity(\"DDG-51\", jaguar::Domain::Sea);\nauto satellite = engine.create_entity(\"GPS-IIR\", jaguar::Domain::Space);\n</code></pre>"},{"location":"getting-started/quickstart/#applying-forces","title":"Applying Forces","text":"<pre><code>jaguar::physics::EntityForces forces;\n\n// Add force in body frame\nforces.add_force({1000.0, 0.0, 0.0});  // 1000 N forward\n\n// Add torque\nforces.add_torque({0.0, 100.0, 0.0});  // 100 Nm pitch\n\n// Apply to entity\nengine.apply_forces(entity_id, forces);\n</code></pre>"},{"location":"getting-started/quickstart/#querying-environment","title":"Querying Environment","text":"<pre><code>// Get environment at entity location\nauto env = engine.get_environment(entity_id);\n\nstd::cout &lt;&lt; \"Altitude: \" &lt;&lt; env.altitude &lt;&lt; \" m\\n\";\nstd::cout &lt;&lt; \"Air density: \" &lt;&lt; env.atmosphere.density &lt;&lt; \" kg/m\u00b3\\n\";\nstd::cout &lt;&lt; \"Temperature: \" &lt;&lt; env.atmosphere.temperature &lt;&lt; \" K\\n\";\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've created your first simulation, explore these topics:</p> <ol> <li>Air Domain Tutorial - Detailed aircraft simulation</li> <li>Land Domain Tutorial - Ground vehicle physics</li> <li>Sea Domain Tutorial - Ship simulation with waves</li> <li>Space Domain Tutorial - Orbital mechanics</li> <li>Multi-Entity Example - Combined simulation</li> <li>Configuration Guide - XML configuration system</li> <li>API Reference - Complete API documentation</li> </ol>"},{"location":"getting-started/quickstart/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/quickstart/#engine-fails-to-initialize","title":"Engine Fails to Initialize","text":"<pre><code>if (!engine.initialize()) {\n    // Check for missing configuration files\n    // Verify data paths are correct\n}\n</code></pre>"},{"location":"getting-started/quickstart/#entity-state-not-changing","title":"Entity State Not Changing","text":"<p>Make sure you're calling <code>engine.step(dt)</code> to advance the simulation:</p> <pre><code>// Wrong: state won't change\nengine.set_entity_state(id, state);\nauto s = engine.get_entity_state(id);  // Same as input\n\n// Correct: advance physics\nengine.set_entity_state(id, state);\nengine.step(0.01);  // Physics update\nauto s = engine.get_entity_state(id);  // Updated state\n</code></pre>"},{"location":"getting-started/quickstart/#unexpected-position-values","title":"Unexpected Position Values","text":"<p>Remember NED coordinate conventions: - Altitude is negative Z - Velocity forward is positive X</p> <pre><code>// Altitude check\njaguar::Real altitude = -state.position.z;  // Convert to positive altitude\n</code></pre>"},{"location":"tutorials/air-domain/","title":"Air Domain Tutorial","text":"<p>This tutorial demonstrates how to simulate aircraft using JaguarEngine's Air domain.</p>"},{"location":"tutorials/air-domain/#prerequisites","title":"Prerequisites","text":"<ul> <li>JaguarEngine installed and configured</li> <li>Basic understanding of flight dynamics</li> <li>C++ development environment</li> </ul>"},{"location":"tutorials/air-domain/#tutorial-simple-aircraft-simulation","title":"Tutorial: Simple Aircraft Simulation","text":""},{"location":"tutorials/air-domain/#step-1-create-the-engine","title":"Step 1: Create the Engine","text":"<pre><code>#include &lt;jaguar/jaguar.h&gt;\n\nusing namespace jaguar;\n\nint main() {\n    // Create and initialize engine\n    Engine engine;\n    if (!engine.initialize()) {\n        std::cerr &lt;&lt; \"Failed to initialize engine\\n\";\n        return 1;\n    }\n</code></pre>"},{"location":"tutorials/air-domain/#step-2-create-an-aircraft-entity","title":"Step 2: Create an Aircraft Entity","text":"<pre><code>    // Create aircraft entity\n    EntityId aircraft = engine.create_entity(\"F16\", Domain::Air);\n</code></pre>"},{"location":"tutorials/air-domain/#step-3-set-initial-state","title":"Step 3: Set Initial State","text":"<pre><code>    // Configure initial state\n    physics::EntityState state;\n\n    // Position: 10 km altitude (NED, so Z is negative up)\n    state.position = Vec3{0.0, 0.0, -10000.0};\n\n    // Velocity: 250 m/s forward (North in NED)\n    state.velocity = Vec3{250.0, 0.0, 0.0};\n\n    // Orientation: Level flight, heading North\n    state.orientation = Quaternion::identity();\n\n    // Mass properties\n    state.mass = 12000.0;  // 12,000 kg\n\n    // Inertia tensor (simplified)\n    state.inertia = Mat3x3::identity();\n    state.inertia.data[0][0] = 12875;   // Ixx\n    state.inertia.data[1][1] = 75674;   // Iyy\n    state.inertia.data[2][2] = 85552;   // Izz\n\n    engine.set_entity_state(aircraft, state);\n</code></pre>"},{"location":"tutorials/air-domain/#step-4-create-physics-models","title":"Step 4: Create Physics Models","text":"<pre><code>    // Create aerodynamics model\n    domain::air::AerodynamicsModel aero;\n    aero.set_reference_area(27.87);    // Wing area (m\u00b2)\n    aero.set_reference_chord(3.45);    // Mean chord (m)\n    aero.set_reference_span(9.45);     // Wingspan (m)\n\n    // Create propulsion model\n    domain::air::PropulsionModel propulsion;\n    propulsion.set_max_thrust(130000.0);  // 130 kN\n    propulsion.set_fuel_capacity(3200.0); // 3200 kg\n    propulsion.set_specific_fuel_consumption(2.5e-5);\n    propulsion.start();\n    propulsion.set_throttle(0.7);  // 70% throttle\n</code></pre>"},{"location":"tutorials/air-domain/#step-5-run-the-simulation","title":"Step 5: Run the Simulation","text":"<pre><code>    // Simulation parameters\n    Real dt = 0.01;       // 100 Hz\n    Real duration = 60.0; // 1 minute\n\n    std::cout &lt;&lt; \"Time(s), Altitude(m), Airspeed(m/s), Alpha(deg)\\n\";\n\n    for (Real t = 0; t &lt; duration; t += dt) {\n        // Get current state and environment\n        auto state = engine.get_entity_state(aircraft);\n        auto env = engine.get_environment(aircraft);\n\n        // Compute forces\n        physics::EntityForces forces;\n        forces.clear();\n\n        aero.compute_forces(state, env, dt, forces);\n        propulsion.compute_forces(state, env, dt, forces);\n\n        // Add gravity\n        forces.add_force(Vec3{0.0, 0.0, state.mass * constants::G0});\n\n        // Apply forces and step\n        engine.apply_forces(aircraft, forces);\n        engine.step(dt);\n\n        // Output telemetry every second\n        if (std::fmod(t, 1.0) &lt; dt) {\n            Real altitude = -state.position.z;\n            Real airspeed = state.velocity.norm();\n            Real alpha = aero.get_alpha() * constants::RAD_TO_DEG;\n\n            std::cout &lt;&lt; t &lt;&lt; \", \"\n                      &lt;&lt; altitude &lt;&lt; \", \"\n                      &lt;&lt; airspeed &lt;&lt; \", \"\n                      &lt;&lt; alpha &lt;&lt; \"\\n\";\n        }\n    }\n\n    engine.shutdown();\n    return 0;\n}\n</code></pre>"},{"location":"tutorials/air-domain/#tutorial-aircraft-with-flight-controls","title":"Tutorial: Aircraft with Flight Controls","text":""},{"location":"tutorials/air-domain/#adding-control-inputs","title":"Adding Control Inputs","text":"<pre><code>// Create flight control system\ndomain::air::FlightControlSystem fcs;\nfcs.set_elevator_range(-25.0, 25.0);\nfcs.set_aileron_range(-20.0, 20.0);\nfcs.set_rudder_range(-30.0, 30.0);\n\n// Define control inputs\ndomain::air::FlightControlSystem::ControlInputs inputs;\ninputs.pitch_cmd = 0.0;      // Neutral pitch\ninputs.roll_cmd = 0.0;       // Wings level\ninputs.yaw_cmd = 0.0;        // No rudder\ninputs.throttle_cmd = 0.7;   // 70% throttle\n\n// In simulation loop\nauto surfaces = fcs.process(inputs, dt);\n\n// Apply control surface effects to aerodynamics\n// (Control surfaces modify aerodynamic coefficients)\n</code></pre>"},{"location":"tutorials/air-domain/#implementing-a-simple-autopilot","title":"Implementing a Simple Autopilot","text":"<pre><code>class SimpleAutopilot {\npublic:\n    void set_altitude_target(Real altitude) {\n        target_alt_ = altitude;\n    }\n\n    void set_heading_target(Real heading) {\n        target_hdg_ = heading;\n    }\n\n    FlightControlSystem::ControlInputs compute(\n        const physics::EntityState&amp; state,\n        Real dt)\n    {\n        FlightControlSystem::ControlInputs inputs;\n\n        // Altitude hold (pitch control)\n        Real alt = -state.position.z;\n        Real alt_error = target_alt_ - alt;\n        Real climb_rate = -state.velocity.z;\n\n        // PI controller for altitude\n        alt_integral_ += alt_error * dt;\n        inputs.pitch_cmd = kp_alt_ * alt_error +\n                           ki_alt_ * alt_integral_ -\n                           kd_alt_ * climb_rate;\n        inputs.pitch_cmd = std::clamp(inputs.pitch_cmd, -1.0, 1.0);\n\n        // Heading hold (roll control)\n        Real roll, pitch, yaw;\n        state.orientation.to_euler(roll, pitch, yaw);\n\n        Real hdg_error = target_hdg_ - yaw;\n        // Normalize to [-\u03c0, \u03c0]\n        while (hdg_error &gt; M_PI) hdg_error -= 2 * M_PI;\n        while (hdg_error &lt; -M_PI) hdg_error += 2 * M_PI;\n\n        // Bank angle command\n        Real bank_cmd = kp_hdg_ * hdg_error;\n        bank_cmd = std::clamp(bank_cmd, -0.5, 0.5);  // Max 30\u00b0 bank\n\n        // Roll to achieve bank\n        Real bank_error = bank_cmd - roll;\n        inputs.roll_cmd = kp_roll_ * bank_error;\n        inputs.roll_cmd = std::clamp(inputs.roll_cmd, -1.0, 1.0);\n\n        return inputs;\n    }\n\nprivate:\n    Real target_alt_{10000.0};\n    Real target_hdg_{0.0};\n    Real alt_integral_{0.0};\n\n    // Gains\n    Real kp_alt_{0.01};\n    Real ki_alt_{0.001};\n    Real kd_alt_{0.05};\n    Real kp_hdg_{1.0};\n    Real kp_roll_{2.0};\n};\n</code></pre>"},{"location":"tutorials/air-domain/#tutorial-missile-simulation","title":"Tutorial: Missile Simulation","text":""},{"location":"tutorials/air-domain/#creating-a-guided-missile","title":"Creating a Guided Missile","text":"<pre><code>// Create missile entity\nEntityId missile = engine.create_entity(\"AIM120\", Domain::Air);\n\n// Initial state (launched from aircraft)\nphysics::EntityState missile_state;\nmissile_state.position = aircraft_state.position;\nmissile_state.velocity = aircraft_state.velocity +\n    aircraft_state.orientation.rotate(Vec3{50.0, 0.0, 0.0});\nmissile_state.orientation = aircraft_state.orientation;\nmissile_state.mass = 150.0;\n\n// Missile-specific models\ndomain::air::AerodynamicsModel missile_aero;\nmissile_aero.set_reference_area(0.03);  // Small frontal area\nmissile_aero.set_reference_chord(0.2);\nmissile_aero.set_reference_span(0.5);\n\ndomain::air::PropulsionModel rocket;\nrocket.set_max_thrust(12000.0);\nrocket.set_fuel_capacity(30.0);\nrocket.set_specific_fuel_consumption(1e-4);\nrocket.start();\nrocket.set_throttle(1.0);  // Full throttle\n</code></pre>"},{"location":"tutorials/air-domain/#proportional-navigation-guidance","title":"Proportional Navigation Guidance","text":"<pre><code>class ProNavGuidance {\npublic:\n    Vec3 compute_acceleration(const Vec3&amp; missile_pos,\n                              const Vec3&amp; missile_vel,\n                              const Vec3&amp; target_pos,\n                              const Vec3&amp; target_vel) {\n        // Line-of-sight vector\n        Vec3 los = target_pos - missile_pos;\n        Real range = los.norm();\n        Vec3 los_unit = los / range;\n\n        // Closing velocity\n        Vec3 rel_vel = target_vel - missile_vel;\n        Real closing_speed = -rel_vel.dot(los_unit);\n\n        // LOS rate\n        Vec3 omega_los = los.cross(rel_vel) / (range * range);\n\n        // Pro-nav acceleration\n        Real N = 4.0;  // Navigation constant\n        Vec3 accel_cmd = missile_vel.cross(omega_los) * N;\n\n        return accel_cmd;\n    }\n};\n</code></pre>"},{"location":"tutorials/air-domain/#xml-configuration","title":"XML Configuration","text":""},{"location":"tutorials/air-domain/#aircraft-definition","title":"Aircraft Definition","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;entity type=\"aircraft\" name=\"F16\"&gt;\n    &lt;metrics&gt;\n        &lt;wingspan unit=\"m\"&gt;9.45&lt;/wingspan&gt;\n        &lt;wing_area unit=\"m2\"&gt;27.87&lt;/wing_area&gt;\n        &lt;wing_chord unit=\"m\"&gt;3.45&lt;/wing_chord&gt;\n    &lt;/metrics&gt;\n\n    &lt;mass_balance&gt;\n        &lt;empty_weight unit=\"kg\"&gt;8936&lt;/empty_weight&gt;\n        &lt;fuel_capacity unit=\"kg\"&gt;3200&lt;/fuel_capacity&gt;\n    &lt;/mass_balance&gt;\n\n    &lt;propulsion&gt;\n        &lt;engine type=\"turbofan\"&gt;\n            &lt;max_thrust unit=\"N\"&gt;130000&lt;/max_thrust&gt;\n        &lt;/engine&gt;\n    &lt;/propulsion&gt;\n&lt;/entity&gt;\n</code></pre>"},{"location":"tutorials/air-domain/#common-issues","title":"Common Issues","text":""},{"location":"tutorials/air-domain/#numerical-instability","title":"Numerical Instability","text":"<p>Symptoms: Aircraft diverges, oscillates wildly, or crashes</p> <p>Solutions: - Reduce time step (try 0.005s instead of 0.01s) - Check coefficient table bounds - Verify mass and inertia are positive</p>"},{"location":"tutorials/air-domain/#unrealistic-flight","title":"Unrealistic Flight","text":"<p>Symptoms: Aircraft doesn't behave physically</p> <p>Solutions: - Verify aerodynamic coefficients match aircraft type - Check reference dimensions (area, chord, span) - Ensure control surface limits are reasonable</p>"},{"location":"tutorials/air-domain/#next-steps","title":"Next Steps","text":"<ul> <li>Land Domain Tutorial - Ground vehicle simulation</li> <li>Sea Domain Tutorial - Naval simulation</li> <li>Multi-Entity Tutorial - Multiple aircraft simulation</li> <li>API Reference - Air domain API</li> </ul>"},{"location":"tutorials/examples/","title":"Examples Guide","text":"<p>Comprehensive examples for using JaguarEngine across all supported domains.</p>"},{"location":"tutorials/examples/#overview","title":"Overview","text":"Example Domain Complexity Description Minimal Any Beginner Basic engine usage Simple Flight Air Beginner Aircraft simulation Tank Simulation Land Intermediate Ground vehicle Ship Maneuvering Sea Intermediate Naval vessel Satellite Orbit Space Intermediate Orbital mechanics Multi-Domain All Advanced Combined domains Custom Forces Any Advanced Extending physics"},{"location":"tutorials/examples/#minimal-example","title":"Minimal Example","text":"<p>The simplest possible JaguarEngine program:</p> <pre><code>#include &lt;jaguar/jaguar.h&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Create and initialize engine\n    jaguar::interface::Engine engine;\n    if (!engine.initialize()) {\n        std::cerr &lt;&lt; \"Engine initialization failed\\n\";\n        return 1;\n    }\n\n    // Create an entity\n    auto entity = engine.create_entity(\"MyEntity\", jaguar::Domain::Air);\n\n    // Set initial state\n    jaguar::physics::EntityState state;\n    state.position = {0, 0, -1000};  // 1 km altitude\n    state.velocity = {100, 0, 0};    // 100 m/s forward\n    state.mass = 1000;               // 1000 kg\n    engine.set_entity_state(entity, state);\n\n    // Run simulation for 10 seconds\n    engine.run_for(10.0);\n\n    // Get final state\n    auto final_state = engine.get_entity_state(entity);\n    std::cout &lt;&lt; \"Final X position: \" &lt;&lt; final_state.position.x &lt;&lt; \" m\\n\";\n\n    engine.shutdown();\n    return 0;\n}\n</code></pre>"},{"location":"tutorials/examples/#simple-aircraft","title":"Simple Aircraft","text":"<p>A complete aircraft simulation with aerodynamics and propulsion:</p> <pre><code>#include &lt;jaguar/jaguar.h&gt;\n#include &lt;jaguar/domain/air.h&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nint main() {\n    std::cout &lt;&lt; \"F-16 Flight Simulation\\n\\n\";\n\n    // Initialize engine\n    jaguar::interface::Engine engine;\n    engine.initialize();\n\n    // Create aircraft entity\n    auto aircraft = engine.create_entity(\"F-16\", jaguar::Domain::Air);\n\n    // Configure aerodynamics\n    jaguar::domain::air::AerodynamicsModel aero;\n    aero.set_reference_area(27.87);    // m\u00b2\n    aero.set_reference_chord(3.45);    // m\n    aero.set_reference_span(9.45);     // m\n\n    // Configure propulsion\n    jaguar::domain::air::PropulsionModel propulsion;\n    propulsion.set_max_thrust(131000.0);  // N\n    propulsion.set_fuel_capacity(3200.0); // kg\n    propulsion.set_specific_fuel_consumption(2.5e-5);\n    propulsion.start();\n    propulsion.set_throttle(0.85);  // 85% power\n\n    // Set initial state (10 km altitude, 250 m/s)\n    jaguar::physics::EntityState state;\n    state.position = {0, 0, -10000};\n    state.velocity = {250, 0, 0};\n    state.orientation = jaguar::Quaternion::identity();\n    state.mass = 12000;\n    engine.set_entity_state(aircraft, state);\n\n    // Print header\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1);\n    std::cout &lt;&lt; \"Time(s) | Alt(m)    | Speed(m/s) | Mach  | Fuel(kg)\\n\";\n    std::cout &lt;&lt; \"--------|-----------|------------|-------|----------\\n\";\n\n    // Simulation loop\n    const jaguar::Real dt = 0.01;  // 100 Hz\n    jaguar::physics::EntityForces forces;\n\n    for (jaguar::Real t = 0; t &lt; 60.0; t += dt) {\n        // Get current state and environment\n        auto s = engine.get_entity_state(aircraft);\n        auto env = engine.get_environment(aircraft);\n\n        // Compute forces\n        forces.clear();\n        aero.compute_forces(s, env, dt, forces);\n        propulsion.compute_forces(s, env, dt, forces);\n\n        // Add gravity\n        forces.add_force({0, 0, s.mass * jaguar::constants::G0});\n\n        // Apply and step\n        engine.apply_forces(aircraft, forces);\n        engine.step(dt);\n\n        // Print telemetry every 5 seconds\n        if (static_cast&lt;int&gt;(t * 100) % 500 == 0) {\n            std::cout &lt;&lt; std::setw(7) &lt;&lt; t &lt;&lt; \" | \"\n                      &lt;&lt; std::setw(9) &lt;&lt; -s.position.z &lt;&lt; \" | \"\n                      &lt;&lt; std::setw(10) &lt;&lt; s.velocity.norm() &lt;&lt; \" | \"\n                      &lt;&lt; std::setw(5) &lt;&lt; std::setprecision(2) &lt;&lt; aero.get_mach() &lt;&lt; \" | \"\n                      &lt;&lt; std::setw(8) &lt;&lt; std::setprecision(1)\n                      &lt;&lt; propulsion.get_fuel_remaining() &lt;&lt; \"\\n\";\n        }\n    }\n\n    engine.shutdown();\n    return 0;\n}\n</code></pre>"},{"location":"tutorials/examples/#tank-simulation","title":"Tank Simulation","text":"<p>Ground vehicle with terramechanics and suspension:</p> <pre><code>#include &lt;jaguar/jaguar.h&gt;\n#include &lt;jaguar/domain/land.h&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"M1A2 Abrams Tank Simulation\\n\\n\";\n\n    jaguar::interface::Engine engine;\n    engine.initialize();\n\n    // Create tank entity\n    auto tank = engine.create_entity(\"M1A2\", jaguar::Domain::Land);\n\n    // Configure terramechanics (track-soil interaction)\n    jaguar::domain::land::TerramechanicsModel terra;\n    terra.set_contact_area(0.63, 4.6);   // Track: 63cm \u00d7 4.6m\n    terra.set_vehicle_weight(549000.0);  // 56 tonnes \u00d7 9.81\n\n    // Configure tracks\n    jaguar::domain::land::TrackedVehicleModel tracks;\n    tracks.set_sprocket(0.33, 100000.0); // 33cm radius, 100 kN\u00b7m max\n\n    // Configure suspension\n    jaguar::domain::land::SuspensionModel suspension;\n    jaguar::domain::land::SuspensionUnit wheel;\n    wheel.spring_k = 300000.0;   // 300 kN/m\n    wheel.damper_c = 30000.0;    // 30 kN\u00b7s/m\n    wheel.travel_max = 0.40;     // 40cm travel\n\n    // Add road wheels (6 per side)\n    for (jaguar::Real x = -3.5; x &lt;= 2.0; x += 1.1) {\n        suspension.add_unit({x, 1.8, -0.9}, wheel);   // Left\n        suspension.add_unit({x, -1.8, -0.9}, wheel);  // Right\n    }\n\n    // Set initial state\n    jaguar::physics::EntityState state;\n    state.position = {0, 0, 0};\n    state.orientation = jaguar::Quaternion::identity();\n    state.mass = 56000;  // kg\n    engine.set_entity_state(tank, state);\n\n    // Simulation variables\n    jaguar::Real throttle = 0.8;  // 80% power\n    jaguar::Real steering = 0.0;\n\n    std::cout &lt;&lt; \"Time(s) | Speed(km/h) | Slip(%) | Sinkage(cm)\\n\";\n    std::cout &lt;&lt; \"--------|-------------|---------|------------\\n\";\n\n    const jaguar::Real dt = 0.02;  // 50 Hz\n    jaguar::physics::EntityForces forces;\n    auto soil = jaguar::domain::land::SoilProperties::DrySand();\n\n    for (jaguar::Real t = 0; t &lt; 30.0; t += dt) {\n        auto s = engine.get_entity_state(tank);\n        auto env = engine.get_environment(tank);\n\n        forces.clear();\n\n        // Terramechanics forces\n        terra.compute_forces(s, env, dt, forces);\n\n        // Track dynamics\n        jaguar::Real drive_torque = throttle * 100000.0;\n        jaguar::Real steer_bias = steering * 0.3;\n        jaguar::Real left_torque = drive_torque * (1.0 - steer_bias);\n        jaguar::Real right_torque = drive_torque * (1.0 + steer_bias);\n\n        tracks.update(left_torque, right_torque, s.mass * 9.81, soil, dt);\n        forces.add_force({tracks.get_propulsive_force(), 0, 0});\n\n        // Steering moment\n        jaguar::Real steer_moment = (right_torque - left_torque) * 1.8;\n        forces.add_torque({0, 0, steer_moment});\n\n        // Suspension\n        suspension.update(s, dt);\n        forces.add_force(suspension.get_total_force());\n        forces.add_torque(suspension.get_total_torque());\n\n        // Gravity\n        forces.add_force({0, 0, s.mass * 9.81});\n\n        engine.apply_forces(tank, forces);\n        engine.step(dt);\n\n        // Turn right at t=10s\n        if (t &gt; 10.0 &amp;&amp; t &lt; 15.0) {\n            steering = 0.5;\n        } else {\n            steering = 0.0;\n        }\n\n        // Print every second\n        if (static_cast&lt;int&gt;(t * 50) % 50 == 0) {\n            jaguar::Real speed_kmh = s.velocity.norm() * 3.6;\n            jaguar::Real avg_slip = (tracks.get_left_track().slip +\n                                     tracks.get_right_track().slip) / 2.0;\n            std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1)\n                      &lt;&lt; std::setw(7) &lt;&lt; t &lt;&lt; \" | \"\n                      &lt;&lt; std::setw(11) &lt;&lt; speed_kmh &lt;&lt; \" | \"\n                      &lt;&lt; std::setw(7) &lt;&lt; avg_slip * 100 &lt;&lt; \" | \"\n                      &lt;&lt; std::setw(10) &lt;&lt; terra.get_sinkage() * 100 &lt;&lt; \"\\n\";\n        }\n    }\n\n    engine.shutdown();\n    return 0;\n}\n</code></pre>"},{"location":"tutorials/examples/#ship-maneuvering","title":"Ship Maneuvering","text":"<p>Destroyer maneuvering simulation with hydrodynamics:</p> <pre><code>#include &lt;jaguar/jaguar.h&gt;\n#include &lt;jaguar/domain/sea.h&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"DDG-51 Arleigh Burke Destroyer Simulation\\n\\n\";\n\n    jaguar::interface::Engine engine;\n    engine.initialize();\n\n    auto ship = engine.create_entity(\"DDG-51\", jaguar::Domain::Sea);\n\n    // Configure buoyancy (8400 tonnes displacement)\n    jaguar::domain::sea::BuoyancyModel buoyancy;\n    buoyancy.set_displaced_volume(8400.0);\n    buoyancy.set_metacentric_height(2.5);\n    buoyancy.set_center_of_buoyancy({0, 0, -4.7});\n\n    // Configure hydrodynamics (MMG model)\n    jaguar::domain::sea::HydrodynamicsModel hydro;\n    hydro.set_hull_coefficients(-0.04, -0.01, -0.4, 0.05, -0.1, -0.05);\n    hydro.set_rudder_parameters(18.0, 1.6);     // 18 m\u00b2 rudder\n    hydro.set_propeller_parameters(5.2, 1.0);   // 5.2m propeller\n\n    // Configure waves (Sea State 4)\n    jaguar::domain::sea::WaveModel waves;\n    auto sea_state = jaguar::domain::sea::SeaState::FromNATOSeaState(4);\n    waves.set_sea_state(sea_state);\n\n    // Set initial state\n    jaguar::physics::EntityState state;\n    state.position = {0, 0, 0};\n    state.orientation = jaguar::Quaternion::identity();\n    state.mass = 8600000;  // 8600 tonnes in kg\n    engine.set_entity_state(ship, state);\n\n    // Control inputs\n    hydro.set_propeller_rpm(126.0);  // 70% power \u2248 180 RPM max\n    hydro.set_rudder_angle(0.0);\n\n    std::cout &lt;&lt; \"Time(s) | Speed(kt) | Heading(\u00b0) | Roll(\u00b0) | Pitch(\u00b0)\\n\";\n    std::cout &lt;&lt; \"--------|-----------|------------|---------|----------\\n\";\n\n    const jaguar::Real dt = 0.05;  // 20 Hz\n    jaguar::physics::EntityForces forces;\n    jaguar::Real sim_time = 0.0;\n\n    for (jaguar::Real t = 0; t &lt; 120.0; t += dt) {\n        auto s = engine.get_entity_state(ship);\n        auto env = engine.get_environment(ship);\n\n        // Update wave surface\n        env.ocean.surface_elevation = waves.get_elevation(\n            s.position.x, s.position.y, sim_time);\n        env.over_water = true;\n\n        forces.clear();\n\n        // Buoyancy and stability\n        buoyancy.compute_forces(s, env, dt, forces);\n\n        // Hydrodynamic maneuvering forces\n        hydro.compute_forces(s, env, dt, forces);\n\n        // Gravity\n        forces.add_force({0, 0, s.mass * 9.81});\n\n        engine.apply_forces(ship, forces);\n        engine.step(dt);\n        sim_time += dt;\n\n        // Execute turn at t=30s\n        if (t &gt; 30.0 &amp;&amp; t &lt; 50.0) {\n            hydro.set_rudder_angle(0.35);  // 20\u00b0 starboard\n        } else {\n            hydro.set_rudder_angle(0.0);\n        }\n\n        // Print every 5 seconds\n        if (static_cast&lt;int&gt;(t * 20) % 100 == 0) {\n            jaguar::Real speed_kt = std::sqrt(s.velocity.x * s.velocity.x +\n                                              s.velocity.y * s.velocity.y) * 1.94384;\n            jaguar::Real roll_deg = buoyancy.get_heel() * jaguar::constants::RAD_TO_DEG;\n            jaguar::Real pitch_deg = buoyancy.get_trim() * jaguar::constants::RAD_TO_DEG;\n\n            jaguar::Real yaw;\n            s.orientation.to_euler(yaw, yaw, yaw);  // Just get yaw\n            jaguar::Real hdg_deg = yaw * jaguar::constants::RAD_TO_DEG;\n            if (hdg_deg &lt; 0) hdg_deg += 360.0;\n\n            std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1)\n                      &lt;&lt; std::setw(7) &lt;&lt; t &lt;&lt; \" | \"\n                      &lt;&lt; std::setw(9) &lt;&lt; speed_kt &lt;&lt; \" | \"\n                      &lt;&lt; std::setw(10) &lt;&lt; hdg_deg &lt;&lt; \" | \"\n                      &lt;&lt; std::setw(7) &lt;&lt; roll_deg &lt;&lt; \" | \"\n                      &lt;&lt; std::setw(8) &lt;&lt; pitch_deg &lt;&lt; \"\\n\";\n        }\n    }\n\n    engine.shutdown();\n    return 0;\n}\n</code></pre>"},{"location":"tutorials/examples/#satellite-orbit","title":"Satellite Orbit","text":"<p>LEO satellite with orbital mechanics:</p> <pre><code>#include &lt;jaguar/jaguar.h&gt;\n#include &lt;jaguar/domain/space.h&gt;\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nint main() {\n    std::cout &lt;&lt; \"ISS-like LEO Satellite Simulation\\n\\n\";\n\n    jaguar::interface::Engine engine;\n    engine.initialize();\n\n    auto satellite = engine.create_entity(\"ISS\", jaguar::Domain::Space);\n\n    // Configure gravity model (J4 for LEO accuracy)\n    jaguar::domain::space::GravityModel gravity;\n    gravity.set_fidelity(jaguar::domain::space::GravityFidelity::J4);\n\n    // Configure atmospheric drag\n    jaguar::domain::space::AtmosphericDragModel drag;\n    drag.set_drag_coefficient(2.2);\n    drag.set_area(2500.0);  // ~ISS area\n\n    // Define ISS-like orbit\n    jaguar::domain::space::OrbitalElements orbit;\n    orbit.semi_major_axis = 6778000.0;   // ~400 km altitude\n    orbit.eccentricity = 0.0002;\n    orbit.inclination = 51.6 * jaguar::constants::DEG_TO_RAD;\n    orbit.raan = 0.0;\n    orbit.arg_periapsis = 0.0;\n    orbit.mean_anomaly = 0.0;\n\n    // Convert to Cartesian\n    jaguar::Vec3 pos, vel;\n    orbit.to_cartesian(pos, vel);\n\n    jaguar::physics::EntityState state;\n    state.position = pos;\n    state.velocity = vel;\n    state.mass = 420000;  // ~ISS mass\n    engine.set_entity_state(satellite, state);\n\n    std::cout &lt;&lt; \"Initial orbit: \" &lt;&lt; (orbit.semi_major_axis - 6378137) / 1000\n              &lt;&lt; \" km altitude\\n\";\n    std::cout &lt;&lt; \"Orbital period: \" &lt;&lt; orbit.period() / 60 &lt;&lt; \" minutes\\n\\n\";\n\n    std::cout &lt;&lt; \"Time(min) | Alt(km) | Speed(km/s) | Period(min)\\n\";\n    std::cout &lt;&lt; \"----------|---------|-------------|------------\\n\";\n\n    const jaguar::Real dt = 10.0;  // 10 second steps\n    const jaguar::Real duration = 5400.0;  // ~1 orbit (90 min)\n    jaguar::physics::EntityForces forces;\n\n    for (jaguar::Real t = 0; t &lt; duration; t += dt) {\n        auto s = engine.get_entity_state(satellite);\n        auto env = engine.get_environment(satellite);\n\n        forces.clear();\n\n        // Gravity (main force)\n        gravity.compute_forces(s, env, dt, forces);\n\n        // Atmospheric drag (small but significant in LEO)\n        jaguar::Real alt = s.position.norm() - 6378137.0;\n        if (alt &lt; 600000.0) {  // Below 600 km\n            drag.compute_forces(s, env, dt, forces);\n        }\n\n        engine.apply_forces(satellite, forces);\n        engine.step(dt);\n\n        // Print every 10 minutes\n        if (static_cast&lt;int&gt;(t) % 600 == 0) {\n            jaguar::Real alt_km = (s.position.norm() - 6378137.0) / 1000.0;\n            jaguar::Real speed_kms = s.velocity.norm() / 1000.0;\n\n            // Compute current orbital period\n            jaguar::Real r = s.position.norm();\n            jaguar::Real v = s.velocity.norm();\n            jaguar::Real energy = v*v/2.0 - jaguar::constants::EARTH_MU/r;\n            jaguar::Real a = -jaguar::constants::EARTH_MU / (2.0 * energy);\n            jaguar::Real period_min = 2.0 * jaguar::constants::PI *\n                std::sqrt(a*a*a / jaguar::constants::EARTH_MU) / 60.0;\n\n            std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2)\n                      &lt;&lt; std::setw(9) &lt;&lt; t / 60.0 &lt;&lt; \" | \"\n                      &lt;&lt; std::setw(7) &lt;&lt; alt_km &lt;&lt; \" | \"\n                      &lt;&lt; std::setw(11) &lt;&lt; speed_kms &lt;&lt; \" | \"\n                      &lt;&lt; std::setw(10) &lt;&lt; period_min &lt;&lt; \"\\n\";\n        }\n    }\n\n    engine.shutdown();\n    return 0;\n}\n</code></pre>"},{"location":"tutorials/examples/#multi-domain-simulation","title":"Multi-Domain Simulation","text":"<p>Simultaneous simulation across all domains:</p> <pre><code>#include &lt;jaguar/jaguar.h&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nint main() {\n    std::cout &lt;&lt; \"JaguarEngine Multi-Domain Simulation\\n\";\n    std::cout &lt;&lt; \"=====================================\\n\\n\";\n\n    jaguar::interface::Engine engine;\n    engine.initialize();\n\n    // Create entities in each domain\n    auto aircraft = engine.create_entity(\"F-16\", jaguar::Domain::Air);\n    auto tank = engine.create_entity(\"M1A2\", jaguar::Domain::Land);\n    auto ship = engine.create_entity(\"DDG-51\", jaguar::Domain::Sea);\n    auto satellite = engine.create_entity(\"GPS-IIR\", jaguar::Domain::Space);\n\n    // Set initial states\n\n    // Aircraft: 10 km altitude, 250 m/s\n    {\n        jaguar::physics::EntityState s;\n        s.position = {0, 0, -10000};\n        s.velocity = {250, 0, 0};\n        s.mass = 12000;\n        engine.set_entity_state(aircraft, s);\n    }\n\n    // Tank: on ground, moving at 10 m/s\n    {\n        jaguar::physics::EntityState s;\n        s.position = {1000, 0, 0};\n        s.velocity = {10, 0, 0};\n        s.mass = 56000;\n        engine.set_entity_state(tank, s);\n    }\n\n    // Ship: at sea, 15 m/s\n    {\n        jaguar::physics::EntityState s;\n        s.position = {0, 5000, 0};\n        s.velocity = {15, 0, 0};\n        s.mass = 8600000;\n        engine.set_entity_state(ship, s);\n    }\n\n    // Satellite: 400 km circular orbit\n    {\n        jaguar::physics::EntityState s;\n        s.position = {6778137, 0, 0};\n        s.velocity = {0, 7670, 0};\n        s.mass = 2000;\n        engine.set_entity_state(satellite, s);\n    }\n\n    std::cout &lt;&lt; \"Simulating all domains simultaneously...\\n\\n\";\n\n    // Run simulation\n    const jaguar::Real dt = 0.01;\n    for (jaguar::Real t = 0; t &lt; 60.0; t += dt) {\n        engine.step(dt);\n\n        // Print every 10 seconds\n        if (static_cast&lt;int&gt;(t * 100) % 1000 == 0) {\n            std::cout &lt;&lt; \"=== T = \" &lt;&lt; std::fixed &lt;&lt; std::setprecision(0)\n                      &lt;&lt; t &lt;&lt; \" s ===\\n\";\n\n            auto air = engine.get_entity_state(aircraft);\n            std::cout &lt;&lt; \"Aircraft: Alt=\" &lt;&lt; -air.position.z\n                      &lt;&lt; \" m, Speed=\" &lt;&lt; air.velocity.norm() &lt;&lt; \" m/s\\n\";\n\n            auto land = engine.get_entity_state(tank);\n            std::cout &lt;&lt; \"Tank: X=\" &lt;&lt; land.position.x\n                      &lt;&lt; \" m, Speed=\" &lt;&lt; land.velocity.norm() * 3.6 &lt;&lt; \" km/h\\n\";\n\n            auto sea = engine.get_entity_state(ship);\n            std::cout &lt;&lt; \"Ship: Y=\" &lt;&lt; sea.position.y\n                      &lt;&lt; \" m, Speed=\" &lt;&lt; sea.velocity.norm() * 1.94384 &lt;&lt; \" kt\\n\";\n\n            auto space = engine.get_entity_state(satellite);\n            jaguar::Real sat_alt = (space.position.norm() - 6378137) / 1000;\n            std::cout &lt;&lt; \"Satellite: Alt=\" &lt;&lt; sat_alt\n                      &lt;&lt; \" km, Speed=\" &lt;&lt; space.velocity.norm() / 1000 &lt;&lt; \" km/s\\n\\n\";\n        }\n    }\n\n    engine.shutdown();\n    return 0;\n}\n</code></pre>"},{"location":"tutorials/examples/#custom-force-generator","title":"Custom Force Generator","text":"<p>Creating a custom physics model:</p> <pre><code>#include &lt;jaguar/jaguar.h&gt;\n#include &lt;jaguar/physics/force.h&gt;\n#include &lt;random&gt;\n\n// Custom wind turbulence model\nclass WindTurbulence : public jaguar::physics::IForceGenerator {\npublic:\n    WindTurbulence(jaguar::Real intensity, jaguar::Real area)\n        : intensity_(intensity), area_(area), gen_(std::random_device{}()) {}\n\n    void compute_forces(\n        const jaguar::physics::EntityState&amp; state,\n        const jaguar::environment::Environment&amp; env,\n        jaguar::Real dt,\n        jaguar::physics::EntityForces&amp; forces) override\n    {\n        // Generate random gusts\n        std::normal_distribution&lt;jaguar::Real&gt; dist(0.0, intensity_);\n\n        jaguar::Real gust_x = dist(gen_);\n        jaguar::Real gust_y = dist(gen_);\n        jaguar::Real gust_z = dist(gen_) * 0.5;  // Less vertical turbulence\n\n        // Scale by dynamic pressure\n        jaguar::Real speed = state.velocity.norm();\n        jaguar::Real qbar = 0.5 * env.atmosphere.density * speed * speed;\n\n        jaguar::Vec3 turbulence{\n            gust_x * qbar * area_,\n            gust_y * qbar * area_,\n            gust_z * qbar * area_\n        };\n\n        forces.add_force(turbulence);\n    }\n\nprivate:\n    jaguar::Real intensity_;\n    jaguar::Real area_;\n    std::mt19937 gen_;\n};\n\nint main() {\n    jaguar::interface::Engine engine;\n    engine.initialize();\n\n    auto aircraft = engine.create_entity(\"Test\", jaguar::Domain::Air);\n\n    // Create custom turbulence model\n    WindTurbulence turbulence(5.0, 30.0);  // intensity=5, area=30 m\u00b2\n\n    jaguar::physics::EntityState state;\n    state.position = {0, 0, -5000};\n    state.velocity = {200, 0, 0};\n    state.mass = 10000;\n    engine.set_entity_state(aircraft, state);\n\n    jaguar::physics::EntityForces forces;\n    const jaguar::Real dt = 0.01;\n\n    for (jaguar::Real t = 0; t &lt; 30.0; t += dt) {\n        auto s = engine.get_entity_state(aircraft);\n        auto env = engine.get_environment(aircraft);\n\n        forces.clear();\n\n        // Apply custom turbulence\n        turbulence.compute_forces(s, env, dt, forces);\n\n        // Other forces (gravity, etc.)\n        forces.add_force({0, 0, s.mass * jaguar::constants::G0});\n\n        engine.apply_forces(aircraft, forces);\n        engine.step(dt);\n    }\n\n    engine.shutdown();\n    return 0;\n}\n</code></pre>"},{"location":"tutorials/examples/#building-examples","title":"Building Examples","text":"<p>All examples can be built with CMake:</p> <pre><code>cmake_minimum_required(VERSION 3.25)\nproject(JaguarExamples)\n\nfind_package(Jaguar REQUIRED)\n\nadd_executable(minimal minimal.cpp)\ntarget_link_libraries(minimal PRIVATE Jaguar::jaguar)\n\nadd_executable(simple_flight simple_flight.cpp)\ntarget_link_libraries(simple_flight PRIVATE Jaguar::jaguar)\n\n# Add more examples...\n</code></pre> <p>Build and run:</p> <pre><code>mkdir build &amp;&amp; cd build\ncmake ..\nmake\n./simple_flight\n</code></pre>"},{"location":"tutorials/examples/#next-steps","title":"Next Steps","text":"<ul> <li>Air Domain Deep Dive</li> <li>Land Domain Deep Dive</li> <li>Sea Domain Deep Dive</li> <li>Space Domain Deep Dive</li> <li>Configuration Reference</li> <li>Python API Guide</li> </ul>"},{"location":"tutorials/land-domain/","title":"Land Domain Tutorial","text":"<p>This tutorial demonstrates how to simulate ground vehicles using JaguarEngine's Land domain.</p>"},{"location":"tutorials/land-domain/#prerequisites","title":"Prerequisites","text":"<ul> <li>JaguarEngine installed and configured</li> <li>Basic understanding of vehicle dynamics</li> <li>C++ development environment</li> </ul>"},{"location":"tutorials/land-domain/#tutorial-tank-simulation","title":"Tutorial: Tank Simulation","text":""},{"location":"tutorials/land-domain/#step-1-create-the-engine","title":"Step 1: Create the Engine","text":"<pre><code>#include &lt;jaguar/jaguar.h&gt;\n\nusing namespace jaguar;\n\nint main() {\n    Engine engine;\n    if (!engine.initialize()) {\n        std::cerr &lt;&lt; \"Failed to initialize engine\\n\";\n        return 1;\n    }\n</code></pre>"},{"location":"tutorials/land-domain/#step-2-create-a-ground-vehicle-entity","title":"Step 2: Create a Ground Vehicle Entity","text":"<pre><code>    // Create tank entity\n    EntityId tank = engine.create_entity(\"M1A2\", Domain::Land);\n</code></pre>"},{"location":"tutorials/land-domain/#step-3-set-initial-state","title":"Step 3: Set Initial State","text":"<pre><code>    // Configure initial state\n    physics::EntityState state;\n\n    // Position: On ground at origin\n    state.position = Vec3{0.0, 0.0, 0.0};\n\n    // Velocity: Stationary\n    state.velocity = Vec3{0.0, 0.0, 0.0};\n\n    // Orientation: Facing North\n    state.orientation = Quaternion::identity();\n\n    // Mass: 62 tonnes combat weight\n    state.mass = 62000.0;\n\n    // Inertia tensor\n    state.inertia = Mat3x3::identity();\n    state.inertia.data[0][0] = 50000;   // Ixx\n    state.inertia.data[1][1] = 200000;  // Iyy\n    state.inertia.data[2][2] = 220000;  // Izz\n\n    engine.set_entity_state(tank, state);\n</code></pre>"},{"location":"tutorials/land-domain/#step-4-create-physics-models","title":"Step 4: Create Physics Models","text":"<pre><code>    // Create terramechanics model\n    domain::land::TerramechanicsModel terra;\n    terra.set_contact_area(0.63, 4.6);  // Track width, length (m)\n    terra.set_vehicle_weight(62000.0 * constants::G0);\n\n    // Create suspension model\n    domain::land::SuspensionModel suspension;\n\n    // Configure suspension units (6 road wheels per side)\n    domain::land::SuspensionUnit wheel;\n    wheel.spring_k = 300000.0;   // 300 kN/m\n    wheel.damper_c = 30000.0;    // 30 kN\u00b7s/m\n    wheel.travel_max = 0.40;     // 40 cm travel\n\n    // Left side\n    for (Real x = -3.0; x &lt;= 2.0; x += 1.0) {\n        suspension.add_unit(Vec3{x, 1.5, -0.8}, wheel);\n    }\n    // Right side\n    for (Real x = -3.0; x &lt;= 2.0; x += 1.0) {\n        suspension.add_unit(Vec3{x, -1.5, -0.8}, wheel);\n    }\n\n    // Create tracked vehicle model\n    domain::land::TrackedVehicleModel tracks;\n    tracks.set_sprocket(0.33, 100000.0);  // Radius, max torque\n</code></pre>"},{"location":"tutorials/land-domain/#step-5-run-the-simulation","title":"Step 5: Run the Simulation","text":"<pre><code>    // Simulation parameters\n    Real dt = 0.02;       // 50 Hz\n    Real duration = 30.0; // 30 seconds\n    Real throttle = 0.5;  // 50% throttle\n\n    std::cout &lt;&lt; \"Time(s), Position(m), Speed(m/s), Sinkage(m)\\n\";\n\n    for (Real t = 0; t &lt; duration; t += dt) {\n        auto state = engine.get_entity_state(tank);\n        auto env = engine.get_environment(tank);\n\n        // Get soil properties at current location\n        domain::land::SoilProperties soil =\n            domain::land::SoilProperties::DrySand();\n\n        // Compute forces\n        physics::EntityForces forces;\n        forces.clear();\n\n        // Terramechanics\n        terra.compute_forces(state, env, dt, forces);\n\n        // Track dynamics\n        Real engine_torque = throttle * 100000.0;  // Max 100 kN\u00b7m\n        tracks.update(engine_torque, state.mass * constants::G0, soil, dt);\n\n        // Propulsive force from tracks\n        Real propulsion = tracks.get_propulsive_force();\n        forces.add_force(Vec3{propulsion, 0.0, 0.0});\n\n        // Suspension\n        suspension.update(state, dt);\n        forces.add_force(suspension.get_total_force());\n        forces.add_torque(suspension.get_total_torque());\n\n        // Gravity\n        forces.add_force(Vec3{0.0, 0.0, state.mass * constants::G0});\n\n        // Apply forces and step\n        engine.apply_forces(tank, forces);\n        engine.step(dt);\n\n        // Output telemetry every second\n        if (std::fmod(t, 1.0) &lt; dt) {\n            Real distance = state.position.x;\n            Real speed = state.velocity.norm();\n            Real sinkage = terra.get_sinkage();\n\n            std::cout &lt;&lt; t &lt;&lt; \", \"\n                      &lt;&lt; distance &lt;&lt; \", \"\n                      &lt;&lt; speed &lt;&lt; \", \"\n                      &lt;&lt; sinkage &lt;&lt; \"\\n\";\n        }\n    }\n\n    engine.shutdown();\n    return 0;\n}\n</code></pre>"},{"location":"tutorials/land-domain/#tutorial-wheeled-vehicle","title":"Tutorial: Wheeled Vehicle","text":""},{"location":"tutorials/land-domain/#creating-a-wheeled-vehicle","title":"Creating a Wheeled Vehicle","text":"<pre><code>// Create wheeled vehicle\nEntityId apc = engine.create_entity(\"BTR80\", Domain::Land);\n\nphysics::EntityState state;\nstate.mass = 13600.0;  // 13.6 tonnes\nengine.set_entity_state(apc, state);\n\n// Wheeled suspension (8 wheels)\ndomain::land::SuspensionModel suspension;\ndomain::land::SuspensionUnit wheel;\nwheel.spring_k = 150000.0;  // Softer than tank\nwheel.damper_c = 15000.0;\nwheel.travel_max = 0.30;\n\n// 4 axles, 2 wheels each\nReal axle_positions[] = {2.5, 1.0, -1.0, -2.5};\nfor (Real x : axle_positions) {\n    suspension.add_unit(Vec3{x, 1.2, -0.6}, wheel);   // Left\n    suspension.add_unit(Vec3{x, -1.2, -0.6}, wheel);  // Right\n}\n</code></pre>"},{"location":"tutorials/land-domain/#tire-soil-interaction","title":"Tire-Soil Interaction","text":"<pre><code>// For wheeled vehicles, modify contact area\ndomain::land::TerramechanicsModel terra;\nReal tire_width = 0.35;   // 35 cm tire width\nReal contact_length = 0.4; // Approximate contact patch\nterra.set_contact_area(tire_width, contact_length);\nterra.set_vehicle_weight(13600.0 * constants::G0 / 8);  // Per tire\n</code></pre>"},{"location":"tutorials/land-domain/#tutorial-terrain-interaction","title":"Tutorial: Terrain Interaction","text":""},{"location":"tutorials/land-domain/#different-soil-types","title":"Different Soil Types","text":"<pre><code>// Query terrain material at position\nauto env = engine.get_environment(tank);\nTerrainMaterial material = env.terrain.material;\n\n// Get soil properties\ndomain::land::SoilProperties soil;\n\nswitch (material.type) {\n    case TerrainMaterial::Sand:\n        soil = domain::land::SoilProperties::DrySand();\n        break;\n    case TerrainMaterial::Clay:\n        soil = domain::land::SoilProperties::Clay();\n        break;\n    case TerrainMaterial::Snow:\n        soil = domain::land::SoilProperties::Snow();\n        break;\n    case TerrainMaterial::Road:\n        soil = domain::land::SoilProperties::Asphalt();\n        break;\n    default:\n        soil = domain::land::SoilProperties::DrySand();\n}\n</code></pre>"},{"location":"tutorials/land-domain/#slope-effects","title":"Slope Effects","text":"<pre><code>// Get terrain slope at vehicle position\nReal slope_angle = env.terrain.slope_angle;\nVec3 surface_normal = env.terrain.normal;\n\n// Decompose gravity into normal and parallel components\nVec3 gravity{0.0, 0.0, state.mass * constants::G0};\nVec3 gravity_normal = surface_normal * gravity.dot(surface_normal);\nVec3 gravity_parallel = gravity - gravity_normal;\n\n// Gravity parallel component affects vehicle motion on slopes\nforces.add_force(gravity_parallel);\n</code></pre>"},{"location":"tutorials/land-domain/#xml-configuration","title":"XML Configuration","text":""},{"location":"tutorials/land-domain/#ground-vehicle-definition","title":"Ground Vehicle Definition","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;entity type=\"ground_vehicle\" name=\"M1A2\"&gt;\n    &lt;metrics&gt;\n        &lt;length unit=\"m\"&gt;9.77&lt;/length&gt;\n        &lt;width unit=\"m\"&gt;3.66&lt;/width&gt;\n        &lt;height unit=\"m\"&gt;2.44&lt;/height&gt;\n    &lt;/metrics&gt;\n\n    &lt;mass_balance&gt;\n        &lt;combat_weight unit=\"kg\"&gt;62000&lt;/combat_weight&gt;\n        &lt;fuel_capacity unit=\"L\"&gt;1900&lt;/fuel_capacity&gt;\n    &lt;/mass_balance&gt;\n\n    &lt;tracks&gt;\n        &lt;track_width unit=\"m\"&gt;0.63&lt;/track_width&gt;\n        &lt;track_length unit=\"m\"&gt;4.6&lt;/track_length&gt;\n        &lt;sprocket_radius unit=\"m\"&gt;0.33&lt;/sprocket_radius&gt;\n    &lt;/tracks&gt;\n\n    &lt;suspension type=\"torsion_bar\"&gt;\n        &lt;road_wheels_per_side&gt;7&lt;/road_wheels_per_side&gt;\n        &lt;spring_rate unit=\"N/m\"&gt;300000&lt;/spring_rate&gt;\n        &lt;damping_rate unit=\"N*s/m\"&gt;30000&lt;/damping_rate&gt;\n    &lt;/suspension&gt;\n&lt;/entity&gt;\n</code></pre>"},{"location":"tutorials/land-domain/#mobility-analysis","title":"Mobility Analysis","text":""},{"location":"tutorials/land-domain/#gono-go-terrain-assessment","title":"Go/No-Go Terrain Assessment","text":"<pre><code>bool can_traverse(const domain::land::SoilProperties&amp; soil,\n                  Real vehicle_weight,\n                  Real contact_area,\n                  Real slope_deg) {\n    // Check sinkage\n    Real pressure = vehicle_weight / contact_area;\n    Real k = soil.k_c / 0.5 + soil.k_phi;  // Assume 0.5m contact width\n    Real sinkage = std::pow(pressure / k, 1.0 / soil.n);\n\n    if (sinkage &gt; 0.3) {  // Max 30cm sinkage\n        return false;  // Vehicle may be stuck\n    }\n\n    // Check slope\n    Real max_slope = std::atan(soil.phi) * constants::RAD_TO_DEG;\n    if (slope_deg &gt; max_slope * 0.8) {  // 80% of friction limit\n        return false;  // Slope too steep\n    }\n\n    return true;\n}\n</code></pre>"},{"location":"tutorials/land-domain/#common-issues","title":"Common Issues","text":""},{"location":"tutorials/land-domain/#vehicle-sinking","title":"Vehicle Sinking","text":"<p>Symptoms: Vehicle sinks excessively or gets stuck</p> <p>Solutions: - Check contact area dimensions - Verify soil properties are realistic - Consider adding track width/length</p>"},{"location":"tutorials/land-domain/#oscillations","title":"Oscillations","text":"<p>Symptoms: Vehicle bounces or oscillates</p> <p>Solutions: - Increase damping coefficient - Reduce time step - Check suspension preload</p>"},{"location":"tutorials/land-domain/#next-steps","title":"Next Steps","text":"<ul> <li>Sea Domain Tutorial - Naval simulation</li> <li>Air Domain Tutorial - Aircraft simulation</li> <li>Terrain Tutorial - Working with terrain data</li> <li>API Reference - Land domain API</li> </ul>"},{"location":"tutorials/lua-scripting/","title":"Lua Scripting Tutorial","text":"<p>This tutorial demonstrates how to use JaguarEngine's Lua bindings for simulation scripting, scenario automation, and embedded scripting applications.</p>"},{"location":"tutorials/lua-scripting/#prerequisites","title":"Prerequisites","text":"<ul> <li>JaguarEngine built with Lua bindings (<code>-DJAGUAR_BUILD_LUA=ON</code>)</li> <li>Lua 5.4+ (bundled with JaguarEngine if not found on system)</li> </ul>"},{"location":"tutorials/lua-scripting/#installation","title":"Installation","text":""},{"location":"tutorials/lua-scripting/#build-from-source","title":"Build from Source","text":"<pre><code>cd JaguarEngine\n\n# Configure with Lua bindings enabled\ncmake -B build -DJAGUAR_BUILD_LUA=ON\n\n# Build\ncmake --build build --parallel\n\n# The module will be at build/jaguar.so (or jaguar.dll on Windows)\n</code></pre>"},{"location":"tutorials/lua-scripting/#loading-the-module","title":"Loading the Module","text":"<pre><code>-- Add build directory to cpath\npackage.cpath = package.cpath .. \";./build/?.so;./build/?.dll\"\n\n-- Load the module\nlocal jag = require(\"jaguar\")\n\n-- All types are now in global scope: Vec3, Quat, Engine, etc.\n</code></pre>"},{"location":"tutorials/lua-scripting/#verify-installation","title":"Verify Installation","text":"<pre><code>require(\"jaguar\")\n\nprint(\"JaguarEngine Lua bindings loaded!\")\nprint(\"Domains available:\")\nfor k, v in pairs(Domain) do\n    print(\"  \" .. k)\nend\n</code></pre>"},{"location":"tutorials/lua-scripting/#tutorial-1-hello-world-minimal-simulation","title":"Tutorial 1: Hello World - Minimal Simulation","text":"<p>The simplest possible JaguarEngine Lua program:</p> <pre><code>require(\"jaguar\")\n\n-- Create and initialize engine\nlocal engine = Engine()\nengine:initialize()\n\n-- Create an entity\nlocal entity = engine:create_entity(\"Test\", Domain.Air)\n\n-- Set initial state\nlocal state = EntityState()\nstate.position = Vec3(0, 0, -1000)  -- 1 km altitude\nstate.velocity = Vec3(100, 0, 0)    -- 100 m/s forward\nstate.mass = 1000\nengine:set_entity_state(entity, state)\n\n-- Run simulation\nfor i = 1, 1000 do  -- 10 seconds at 100 Hz\n    engine:step(0.01)\nend\n\n-- Get final state\nlocal final = engine:get_entity_state(entity)\nprint(string.format(\"Final position: (%.1f, %.1f, %.1f)\",\n    final.position.x, final.position.y, final.position.z))\n\nengine:shutdown()\n</code></pre>"},{"location":"tutorials/lua-scripting/#tutorial-2-vec3-and-quat-operations","title":"Tutorial 2: Vec3 and Quat Operations","text":"<p>Master the core math types:</p> <pre><code>require(\"jaguar\")\n\nprint(\"=== Vec3 Operations ===\\n\")\n\n-- Construction (both syntaxes work)\nlocal v1 = Vec3(1, 2, 3)        -- Constructor syntax\nlocal v2 = Vec3.new(4, 5, 6)    -- Factory method\nlocal zero = Vec3.zero()         -- Static factory\n\nprint(string.format(\"v1 = %s\", tostring(v1)))\nprint(string.format(\"v2 = %s\", tostring(v2)))\n\n-- Arithmetic operators\nlocal sum = v1 + v2\nlocal diff = v1 - v2\nlocal scaled = v1 * 2.0\nlocal divided = v2 / 2.0\nlocal negated = -v1\n\nprint(string.format(\"v1 + v2 = %s\", tostring(sum)))\nprint(string.format(\"v1 - v2 = %s\", tostring(diff)))\nprint(string.format(\"v1 * 2 = %s\", tostring(scaled)))\nprint(string.format(\"-v1 = %s\", tostring(negated)))\n\n-- Methods\nprint(string.format(\"v1 length = %.3f\", v1:length()))\nprint(string.format(\"v1 normalized = %s\", tostring(v1:normalized())))\nprint(string.format(\"v1 dot v2 = %.3f\", v1:dot(v2)))\nprint(string.format(\"v1 cross v2 = %s\", tostring(v1:cross(v2))))\n\n-- Table conversion (useful for serialization)\nlocal t = v1:to_table()\nprint(string.format(\"As table: x=%.1f, y=%.1f, z=%.1f\", t.x, t.y, t.z))\n\nlocal from_table = Vec3.from_table({x = 10, y = 20, z = 30})\nprint(string.format(\"From table: %s\", tostring(from_table)))\n\nprint(\"\\n=== Quaternion Operations ===\\n\")\n\n-- Construction\nlocal q1 = Quat()                              -- Identity\nlocal q2 = Quat.from_euler(0, 0.1, 0)          -- Pitch 0.1 rad\nlocal q3 = Quat.from_axis_angle(Vec3.unit_z(), math.pi / 4)  -- 45\u00b0 yaw\n\nprint(string.format(\"Identity: %s\", tostring(q1)))\nprint(string.format(\"Pitch 0.1 rad: %s\", tostring(q2)))\nprint(string.format(\"45\u00b0 yaw: %s\", tostring(q3)))\n\n-- Rotation composition\nlocal combined = q2 * q3\nprint(string.format(\"Combined rotation: %s\", tostring(combined)))\n\n-- Rotate a vector\nlocal forward = Vec3(1, 0, 0)\nlocal rotated = q3:rotate(forward)\nprint(string.format(\"Forward after 45\u00b0 yaw: %s\", tostring(rotated)))\n\n-- Extract Euler angles\nlocal roll, pitch, yaw = q3:to_euler()\nprint(string.format(\"Euler angles: roll=%.2f, pitch=%.2f, yaw=%.2f\",\n    roll, pitch, yaw))\n</code></pre>"},{"location":"tutorials/lua-scripting/#tutorial-3-aircraft-simulation","title":"Tutorial 3: Aircraft Simulation","text":"<p>A complete aircraft simulation with aerodynamics and propulsion:</p> <pre><code>require(\"jaguar\")\n\nprint(\"F-16 Flight Simulation (Lua)\\n\")\n\n-- Access domain models\nlocal air = jaguar.domain.air\n\n-- Initialize engine\nlocal engine = Engine()\nengine:initialize()\n\n-- Create aircraft entity\nlocal aircraft = engine:create_entity(\"F-16\", Domain.Air)\n\n-- Configure aerodynamics\nlocal aero = air.AerodynamicsModel()\naero:set_reference_area(27.87)    -- m\u00b2\naero:set_reference_chord(3.45)    -- m\naero:set_reference_span(9.45)     -- m\n\n-- Configure propulsion\nlocal prop = air.PropulsionModel()\nprop:set_max_thrust(131000.0)       -- N\nprop:set_fuel_capacity(3200.0)      -- kg\nprop:set_specific_fuel_consumption(2.5e-5)\nprop:start()\nprop:set_throttle(0.85)             -- 85% power\n\n-- Set initial state (10 km altitude, 250 m/s)\nlocal state = EntityState()\nstate.position = Vec3(0, 0, -10000)\nstate.velocity = Vec3(250, 0, 0)\nstate.orientation = Quat.from_euler(0, 0, 0)\nstate.mass = 12000\nengine:set_entity_state(aircraft, state)\n\n-- Print header\nprint(string.format(\"%7s | %9s | %10s | %5s | %8s\",\n    \"Time(s)\", \"Alt(m)\", \"Speed(m/s)\", \"Mach\", \"Fuel(kg)\"))\nprint(string.rep(\"-\", 55))\n\n-- Simulation loop\nlocal dt = 0.01  -- 100 Hz\nlocal forces = EntityForces()\n\nfor i = 0, 5999 do\n    local t = i * dt\n\n    -- Get current state and environment\n    local s = engine:get_entity_state(aircraft)\n    local env = engine:get_environment(aircraft)\n\n    -- Compute forces\n    forces:clear()\n    aero:compute_forces(s, env, dt, forces)\n    prop:compute_forces(s, env, dt, forces)\n\n    -- Add gravity\n    forces:add_force(Vec3(0, 0, s.mass * jaguar.G0))\n\n    -- Apply and step\n    engine:apply_forces(aircraft, forces)\n    engine:step(dt)\n\n    -- Print telemetry every 5 seconds\n    if i % 500 == 0 then\n        print(string.format(\"%7.1f | %9.0f | %10.1f | %5.2f | %8.1f\",\n            t, -s.position.z, s.velocity:length(),\n            aero:get_mach(), prop:get_fuel_remaining()))\n    end\nend\n\nengine:shutdown()\nprint(\"\\nSimulation complete!\")\n</code></pre>"},{"location":"tutorials/lua-scripting/#tutorial-4-multi-entity-scenario","title":"Tutorial 4: Multi-Entity Scenario","text":"<p>Simulate multiple entities interacting:</p> <pre><code>require(\"jaguar\")\n\nprint(\"Multi-Entity Combat Scenario\\n\")\n\nlocal engine = Engine()\nengine:initialize()\n\n-- Create formations\nlocal function create_formation(base_name, count)\n    local entities = {}\n    for i = 1, count do\n        local name = base_name .. \"-\" .. i\n        local entity = engine:create_entity(name, Domain.Air)\n        table.insert(entities, entity)\n    end\n    return entities\nend\n\n-- Create blue force (4 aircraft)\nlocal blue = create_formation(\"Blue\", 4)\n\n-- Create red force (4 aircraft)\nlocal red = create_formation(\"Red\", 4)\n\n-- Set blue force initial states (from west)\nfor i, aircraft in ipairs(blue) do\n    local state = EntityState()\n    state.position = Vec3(0, (i-1) * 500, -8000)\n    state.velocity = Vec3(250, 0, 0)  -- Heading east\n    state.mass = 12000\n    engine:set_entity_state(aircraft, state)\nend\n\n-- Set red force initial states (from east)\nfor i, aircraft in ipairs(red) do\n    local state = EntityState()\n    state.position = Vec3(50000, (i-1) * 500, -8000)\n    state.velocity = Vec3(-250, 0, 0)  -- Heading west\n    state.mass = 12000\n    engine:set_entity_state(aircraft, state)\nend\n\nprint(string.format(\"Created %d Blue aircraft and %d Red aircraft\",\n    #blue, #red))\nprint(\"Starting simulation...\\n\")\n\n-- Simulation loop\nlocal dt = 0.01\nlocal duration = 120.0  -- 2 minutes\n\nfor t = 0, duration, dt do\n    engine:step(dt)\n\n    -- Log every 10 seconds\n    if math.floor(t) ~= math.floor(t - dt) and math.floor(t) % 10 == 0 then\n        print(string.format(\"T = %.0fs\", t))\n\n        -- Calculate closest approach\n        local min_dist = math.huge\n        for _, b in ipairs(blue) do\n            local blue_state = engine:get_entity_state(b)\n            for _, r in ipairs(red) do\n                local red_state = engine:get_entity_state(r)\n                local diff = blue_state.position - red_state.position\n                local dist = diff:length()\n                if dist &lt; min_dist then\n                    min_dist = dist\n                end\n            end\n        end\n\n        print(string.format(\"  Closest blue-red distance: %.0f m\", min_dist))\n    end\nend\n\nprint(\"\\nSimulation complete!\")\nengine:shutdown()\n</code></pre>"},{"location":"tutorials/lua-scripting/#tutorial-5-space-domain-orbital-mechanics","title":"Tutorial 5: Space Domain - Orbital Mechanics","text":"<p>Simulate a satellite in orbit:</p> <pre><code>require(\"jaguar\")\n\nprint(\"LEO Satellite Simulation\\n\")\n\nlocal space = jaguar.domain.space\n\nlocal engine = Engine()\nengine:initialize()\n\nlocal satellite = engine:create_entity(\"ISS\", Domain.Space)\n\n-- Define ISS-like orbit using orbital elements\nlocal orbit = space.OrbitalElements()\norbit.semi_major_axis = jaguar.EARTH_RADIUS + 420000  -- 420 km altitude\norbit.eccentricity = 0.0001\norbit.inclination = 51.6 * jaguar.DEG_TO_RAD\norbit.raan = 0.0\norbit.arg_periapsis = 0.0\norbit.mean_anomaly = 0.0\n\n-- Convert to Cartesian state\nlocal pos, vel = orbit:to_cartesian()\n\nlocal state = EntityState()\nstate.position = pos\nstate.velocity = vel\nstate.mass = 420000  -- ~ISS mass\nengine:set_entity_state(satellite, state)\n\nprint(string.format(\"Initial orbit: %.0f km altitude\",\n    (orbit.semi_major_axis - jaguar.EARTH_RADIUS) / 1000))\nprint(string.format(\"Orbital period: %.1f minutes\", orbit:period() / 60))\nprint(\"\")\n\n-- Configure gravity model\nlocal gravity = space.GravityModel()\ngravity:set_fidelity(space.GravityFidelity.J2)\n\nprint(string.format(\"%9s | %7s | %11s | %10s\",\n    \"Time(min)\", \"Alt(km)\", \"Speed(km/s)\", \"Period(min)\"))\nprint(string.rep(\"-\", 50))\n\n-- Simulation loop\nlocal dt = 10.0  -- 10 second steps\nlocal duration = 5400.0  -- ~1 orbit (90 min)\nlocal forces = EntityForces()\n\nfor t = 0, duration, dt do\n    local s = engine:get_entity_state(satellite)\n    local env = engine:get_environment(satellite)\n\n    forces:clear()\n\n    -- Gravity (main force)\n    gravity:compute_forces(s, env, dt, forces)\n\n    engine:apply_forces(satellite, forces)\n    engine:step(dt)\n\n    -- Print every 10 minutes\n    if math.floor(t) % 600 == 0 then\n        local alt_km = (s.position:length() - jaguar.EARTH_RADIUS) / 1000\n        local speed_kms = s.velocity:length() / 1000\n\n        -- Compute current orbital period from energy\n        local r = s.position:length()\n        local v = s.velocity:length()\n        local energy = v*v/2.0 - jaguar.EARTH_MU/r\n        local a = -jaguar.EARTH_MU / (2.0 * energy)\n        local period_min = 2.0 * jaguar.PI * math.sqrt(a*a*a / jaguar.EARTH_MU) / 60.0\n\n        print(string.format(\"%9.2f | %7.1f | %11.3f | %10.2f\",\n            t/60, alt_km, speed_kms, period_min))\n    end\nend\n\nengine:shutdown()\nprint(\"\\nSimulation complete!\")\n</code></pre>"},{"location":"tutorials/lua-scripting/#tutorial-6-coordinate-transforms","title":"Tutorial 6: Coordinate Transforms","text":"<p>Working with geodetic coordinates:</p> <pre><code>require(\"jaguar\")\n\nlocal transforms = jaguar.transforms\n\nprint(\"=== Geodetic to ECEF Conversion ===\\n\")\n\n-- Example locations\nlocal locations = {\n    { name = \"New York\", lat = 40.7128, lon = -74.0060, alt = 0 },\n    { name = \"London\", lat = 51.5074, lon = -0.1278, alt = 0 },\n    { name = \"Tokyo\", lat = 35.6762, lon = 139.6503, alt = 0 },\n}\n\nprint(string.format(\"%-12s | %10s | %10s | %12s | %12s | %12s\",\n    \"Location\", \"Lat\", \"Lon\", \"ECEF X (km)\", \"ECEF Y (km)\", \"ECEF Z (km)\"))\nprint(string.rep(\"-\", 80))\n\nfor _, loc in ipairs(locations) do\n    local lat_rad = loc.lat * jaguar.DEG_TO_RAD\n    local lon_rad = loc.lon * jaguar.DEG_TO_RAD\n\n    local ecef = transforms.geodetic_to_ecef(lat_rad, lon_rad, loc.alt)\n\n    print(string.format(\"%-12s | %10.4f | %10.4f | %12.1f | %12.1f | %12.1f\",\n        loc.name, loc.lat, loc.lon,\n        ecef.x/1000, ecef.y/1000, ecef.z/1000))\nend\n\nprint(\"\\n=== ECEF to Geodetic (Round-trip) ===\\n\")\n\n-- Test round-trip conversion\nlocal test_lat = 45.0 * jaguar.DEG_TO_RAD\nlocal test_lon = -90.0 * jaguar.DEG_TO_RAD\nlocal test_alt = 10000  -- 10 km\n\nlocal ecef = transforms.geodetic_to_ecef(test_lat, test_lon, test_alt)\nlocal lat2, lon2, alt2 = transforms.ecef_to_geodetic(ecef)\n\nprint(string.format(\"Original:  lat=%.4f\u00b0, lon=%.4f\u00b0, alt=%.1f m\",\n    test_lat * jaguar.RAD_TO_DEG, test_lon * jaguar.RAD_TO_DEG, test_alt))\nprint(string.format(\"Round-trip: lat=%.4f\u00b0, lon=%.4f\u00b0, alt=%.1f m\",\n    lat2 * jaguar.RAD_TO_DEG, lon2 * jaguar.RAD_TO_DEG, alt2))\n</code></pre>"},{"location":"tutorials/lua-scripting/#tutorial-7-callback-system","title":"Tutorial 7: Callback System","text":"<p>Register callbacks for simulation events:</p> <pre><code>require(\"jaguar\")\n\nprint(\"Callback System Demo\\n\")\n\nlocal engine = Engine()\nengine:initialize()\n\n-- Create test entity\nlocal aircraft = engine:create_entity(\"Test\", Domain.Air)\n\nlocal state = EntityState()\nstate.position = Vec3(0, 0, -10000)\nstate.velocity = Vec3(200, 0, 0)\nstate.mass = 12000\nengine:set_entity_state(aircraft, state)\n\n-- Register step callback\nlocal step_count = 0\nlocal function on_step(dt, time)\n    step_count = step_count + 1\n\n    -- Do something every second\n    if math.floor(time) ~= math.floor(time - dt) then\n        local s = engine:get_entity_state(aircraft)\n        print(string.format(\"T=%.0fs: altitude=%.0f m, speed=%.1f m/s\",\n            time, -s.position.z, s.velocity:length()))\n    end\nend\n\njaguar.register_callback(\"step\", on_step)\n\n-- Register entity event callback\nlocal function on_entity_created(entity_id, name, domain)\n    print(string.format(\"Entity created: %s (ID=%d, domain=%s)\",\n        name, entity_id, tostring(domain)))\nend\n\njaguar.register_callback(\"entity_created\", on_entity_created)\n\n-- Create another entity to trigger callback\nlocal missile = engine:create_entity(\"Missile\", Domain.Air)\n\n-- Run simulation\nprint(\"\\nRunning simulation for 10 seconds...\\n\")\nengine:run_for(10.0)\n\nprint(string.format(\"\\nTotal steps executed: %d\", step_count))\n\nengine:shutdown()\n</code></pre>"},{"location":"tutorials/lua-scripting/#tutorial-8-configuration-and-properties","title":"Tutorial 8: Configuration and Properties","text":"<p>Work with engine configuration and entity properties:</p> <pre><code>require(\"jaguar\")\n\nprint(\"Configuration and Properties Demo\\n\")\n\nlocal engine = Engine()\nengine:initialize()\n\n-- Engine properties\nprint(\"=== Engine Properties ===\")\nprint(string.format(\"Time: %.2f s\", engine:get_time()))\nprint(string.format(\"Time scale: %.1f\", engine:get_time_scale()))\nprint(string.format(\"State: %s\", tostring(engine:get_state())))\n\n-- Modify time scale\nengine:set_time_scale(2.0)\nprint(string.format(\"New time scale: %.1f\", engine:get_time_scale()))\n\n-- Set fixed time step\nengine:set_fixed_time_step(0.01)\n\n-- Create entity with properties\nlocal aircraft = engine:create_entity(\"Test\", Domain.Air)\n\nlocal state = EntityState()\nstate.position = Vec3(0, 0, -5000)\nstate.velocity = Vec3(200, 0, 0)\nstate.mass = 10000\nengine:set_entity_state(aircraft, state)\n\n-- Access entity properties\nprint(\"\\n=== Entity Properties ===\")\n\n-- Get environment data\nlocal env = engine:get_environment(aircraft)\nprint(string.format(\"Latitude: %.4f\u00b0\", env.latitude * jaguar.RAD_TO_DEG))\nprint(string.format(\"Longitude: %.4f\u00b0\", env.longitude * jaguar.RAD_TO_DEG))\nprint(string.format(\"Altitude: %.1f m\", env.altitude))\nprint(string.format(\"Temperature: %.1f K\", env.atmosphere.temperature))\nprint(string.format(\"Pressure: %.0f Pa\", env.atmosphere.pressure))\nprint(string.format(\"Density: %.4f kg/m\u00b3\", env.atmosphere.density))\n\n-- Simulation control\nprint(\"\\n=== Simulation Control ===\")\n\nengine:step(0.01)\nprint(string.format(\"After step: time = %.2f s\", engine:get_time()))\n\n-- Run for duration\nengine:run_for(1.0)\nprint(string.format(\"After run_for(1.0): time = %.2f s\", engine:get_time()))\n\n-- Pause and resume\nengine:pause()\nprint(string.format(\"State after pause: %s\", tostring(engine:get_state())))\n\nengine:resume()\nprint(string.format(\"State after resume: %s\", tostring(engine:get_state())))\n\nengine:shutdown()\n</code></pre>"},{"location":"tutorials/lua-scripting/#common-patterns","title":"Common Patterns","text":""},{"location":"tutorials/lua-scripting/#pattern-reusable-scenario-framework","title":"Pattern: Reusable Scenario Framework","text":"<pre><code>require(\"jaguar\")\n\n-- Scenario base class\nScenario = {}\nScenario.__index = Scenario\n\nfunction Scenario.new(name)\n    local self = setmetatable({}, Scenario)\n    self.name = name\n    self.engine = Engine()\n    self.entities = {}\n    self.time = 0\n    return self\nend\n\nfunction Scenario:setup()\n    self.engine:initialize()\n    self:create_entities()\n    print(string.format(\"Scenario '%s' initialized\", self.name))\nend\n\nfunction Scenario:create_entities()\n    -- Override in subclass\nend\n\nfunction Scenario:step(dt)\n    self.engine:step(dt)\n    self.time = self.time + dt\nend\n\nfunction Scenario:run(duration, dt)\n    dt = dt or 0.01\n    local steps = math.floor(duration / dt)\n\n    for i = 1, steps do\n        self:step(dt)\n        self:on_step(i, steps)\n    end\n\n    print(string.format(\"Scenario completed at T = %.2fs\", self.time))\nend\n\nfunction Scenario:on_step(step, total)\n    -- Override for custom behavior\nend\n\nfunction Scenario:cleanup()\n    self.engine:shutdown()\nend\n\n-- Example usage\nlocal InterceptScenario = setmetatable({}, {__index = Scenario})\nInterceptScenario.__index = InterceptScenario\n\nfunction InterceptScenario.new()\n    local self = Scenario.new(\"Intercept\")\n    setmetatable(self, InterceptScenario)\n    return self\nend\n\nfunction InterceptScenario:create_entities()\n    self.target = self.engine:create_entity(\"Target\", Domain.Air)\n    self.interceptor = self.engine:create_entity(\"Interceptor\", Domain.Air)\n\n    local ts = EntityState()\n    ts.position = Vec3(0, 0, -8000)\n    ts.velocity = Vec3(200, 0, 0)\n    ts.mass = 10000\n    self.engine:set_entity_state(self.target, ts)\n\n    local is = EntityState()\n    is.position = Vec3(30000, 5000, -10000)\n    is.velocity = Vec3(-300, -50, 20)\n    is.mass = 15000\n    self.engine:set_entity_state(self.interceptor, is)\nend\n\nfunction InterceptScenario:on_step(step, total)\n    if step % 1000 == 0 then\n        local t_state = self.engine:get_entity_state(self.target)\n        local i_state = self.engine:get_entity_state(self.interceptor)\n        local range = (t_state.position - i_state.position):length()\n        print(string.format(\"T=%.1fs, Range: %.0f m\", self.time, range))\n    end\nend\n\n-- Run\nlocal scenario = InterceptScenario.new()\nscenario:setup()\nscenario:run(60.0)\nscenario:cleanup()\n</code></pre>"},{"location":"tutorials/lua-scripting/#pattern-data-collection","title":"Pattern: Data Collection","text":"<pre><code>require(\"jaguar\")\n\n-- Simple data logger\nDataLogger = {}\nDataLogger.__index = DataLogger\n\nfunction DataLogger.new()\n    local self = setmetatable({}, DataLogger)\n    self.data = {}\n    return self\nend\n\nfunction DataLogger:log(time, entity_name, state)\n    table.insert(self.data, {\n        time = time,\n        entity = entity_name,\n        x = state.position.x,\n        y = state.position.y,\n        z = state.position.z,\n        vx = state.velocity.x,\n        vy = state.velocity.y,\n        vz = state.velocity.z,\n    })\nend\n\nfunction DataLogger:export_csv(filename)\n    local file = io.open(filename, \"w\")\n    file:write(\"time,entity,x,y,z,vx,vy,vz\\n\")\n\n    for _, record in ipairs(self.data) do\n        file:write(string.format(\"%.3f,%s,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f\\n\",\n            record.time, record.entity,\n            record.x, record.y, record.z,\n            record.vx, record.vy, record.vz))\n    end\n\n    file:close()\n    print(string.format(\"Exported %d records to %s\", #self.data, filename))\nend\n</code></pre>"},{"location":"tutorials/lua-scripting/#debugging-tips","title":"Debugging Tips","text":""},{"location":"tutorials/lua-scripting/#debug-entity-state","title":"Debug Entity State","text":"<pre><code>function debug_entity(engine, entity_id, name)\n    local state = engine:get_entity_state(entity_id)\n    local env = engine:get_environment(entity_id)\n\n    print(string.format(\"\\n=== %s Debug Info ===\", name or \"Entity\"))\n    print(string.format(\"Position: (%.2f, %.2f, %.2f)\",\n        state.position.x, state.position.y, state.position.z))\n    print(string.format(\"Velocity: (%.2f, %.2f, %.2f)\",\n        state.velocity.x, state.velocity.y, state.velocity.z))\n    print(string.format(\"Speed: %.2f m/s\", state.velocity:length()))\n    print(string.format(\"Mass: %.1f kg\", state.mass))\n    print(string.format(\"Altitude: %.1f m\", env.altitude))\n    print(string.format(\"Temperature: %.1f K\", env.atmosphere.temperature))\n    print(string.format(\"Density: %.4f kg/m\u00b3\", env.atmosphere.density))\nend\n</code></pre>"},{"location":"tutorials/lua-scripting/#performance-measurement","title":"Performance Measurement","text":"<pre><code>function profile_simulation(engine, steps, dt)\n    local start = os.clock()\n\n    for i = 1, steps do\n        engine:step(dt)\n    end\n\n    local elapsed = os.clock() - start\n    local sim_time = steps * dt\n\n    print(string.format(\"Simulated %.1fs in %.3fs real time\", sim_time, elapsed))\n    print(string.format(\"Real-time factor: %.1fx\", sim_time / elapsed))\n    print(string.format(\"Steps/second: %.0f\", steps / elapsed))\nend\n</code></pre>"},{"location":"tutorials/lua-scripting/#next-steps","title":"Next Steps","text":"<ul> <li>Python Scripting Tutorial - Python scripting guide</li> <li>Examples Guide - More example code</li> <li>Lua API Reference - Complete API documentation</li> <li>Air Domain Tutorial - Aircraft simulation deep dive</li> </ul>"},{"location":"tutorials/multi-entity/","title":"Multi-Entity Tutorial","text":"<p>This tutorial demonstrates how to simulate multiple interacting entities using JaguarEngine.</p>"},{"location":"tutorials/multi-entity/#overview","title":"Overview","text":"<p>Multi-entity simulations involve:</p> <ul> <li>Managing multiple entities simultaneously</li> <li>Inter-entity interactions (weapons, sensors)</li> <li>Performance optimization for large scenarios</li> <li>Network distribution (DIS/HLA)</li> </ul>"},{"location":"tutorials/multi-entity/#tutorial-air-combat-scenario","title":"Tutorial: Air Combat Scenario","text":""},{"location":"tutorials/multi-entity/#creating-multiple-aircraft","title":"Creating Multiple Aircraft","text":"<pre><code>#include &lt;jaguar/jaguar.h&gt;\n\nusing namespace jaguar;\n\nint main() {\n    Engine engine;\n    engine.initialize();\n\n    // Create blue force (4 fighters)\n    std::vector&lt;EntityId&gt; blue_aircraft;\n    for (int i = 0; i &lt; 4; ++i) {\n        EntityId ac = engine.create_entity(\"Blue-\" + std::to_string(i+1),\n                                           Domain::Air);\n\n        physics::EntityState state;\n        state.position = Vec3{0.0, i * 500.0, -8000.0};  // Formation\n        state.velocity = Vec3{250.0, 0.0, 0.0};\n        state.mass = 12000.0;\n        engine.set_entity_state(ac, state);\n\n        blue_aircraft.push_back(ac);\n    }\n\n    // Create red force (4 fighters)\n    std::vector&lt;EntityId&gt; red_aircraft;\n    for (int i = 0; i &lt; 4; ++i) {\n        EntityId ac = engine.create_entity(\"Red-\" + std::to_string(i+1),\n                                           Domain::Air);\n\n        physics::EntityState state;\n        state.position = Vec3{50000.0, i * 500.0, -8000.0};  // Opposing\n        state.velocity = Vec3{-250.0, 0.0, 0.0};\n        state.mass = 12000.0;\n        engine.set_entity_state(ac, state);\n\n        red_aircraft.push_back(ac);\n    }\n\n    // Simulation loop\n    Real dt = 0.01;\n    Real duration = 120.0;\n\n    for (Real t = 0; t &lt; duration; t += dt) {\n        // Update all entities\n        for (EntityId ac : blue_aircraft) {\n            update_aircraft(engine, ac, dt);\n        }\n        for (EntityId ac : red_aircraft) {\n            update_aircraft(engine, ac, dt);\n        }\n\n        engine.step(dt);\n    }\n\n    engine.shutdown();\n    return 0;\n}\n</code></pre>"},{"location":"tutorials/multi-entity/#entity-interaction-detection","title":"Entity Interaction: Detection","text":"<pre><code>struct DetectionResult {\n    EntityId target;\n    Real range;\n    Real bearing;\n    Real elevation;\n};\n\nstd::vector&lt;DetectionResult&gt; detect_targets(\n    Engine&amp; engine,\n    EntityId sensor_entity,\n    const std::vector&lt;EntityId&gt;&amp; potential_targets,\n    Real max_range,\n    Real fov_deg)\n{\n    std::vector&lt;DetectionResult&gt; detections;\n    auto sensor_state = engine.get_entity_state(sensor_entity);\n\n    for (EntityId target : potential_targets) {\n        auto target_state = engine.get_entity_state(target);\n\n        // Range\n        Vec3 los = target_state.position - sensor_state.position;\n        Real range = los.norm();\n\n        if (range &gt; max_range) continue;\n\n        // Convert to body frame\n        Vec3 los_body = sensor_state.orientation.conjugate().rotate(los);\n\n        // Bearing and elevation\n        Real bearing = std::atan2(los_body.y, los_body.x);\n        Real elevation = std::asin(-los_body.z / range);\n\n        // FOV check\n        Real off_boresight = std::acos(los_body.x / range);\n        if (off_boresight * RAD_TO_DEG &gt; fov_deg / 2) continue;\n\n        // Detection\n        DetectionResult det;\n        det.target = target;\n        det.range = range;\n        det.bearing = bearing;\n        det.elevation = elevation;\n        detections.push_back(det);\n    }\n\n    return detections;\n}\n</code></pre>"},{"location":"tutorials/multi-entity/#entity-interaction-weapons","title":"Entity Interaction: Weapons","text":"<pre><code>EntityId launch_missile(Engine&amp; engine, EntityId launcher, EntityId target) {\n    auto launcher_state = engine.get_entity_state(launcher);\n\n    // Create missile\n    EntityId missile = engine.create_entity(\"AIM-120\", Domain::Air);\n\n    // Initial state from launcher\n    physics::EntityState state;\n    state.position = launcher_state.position;\n    state.velocity = launcher_state.velocity +\n        launcher_state.orientation.rotate(Vec3{50.0, 0.0, 0.0});\n    state.orientation = launcher_state.orientation;\n    state.mass = 150.0;\n    engine.set_entity_state(missile, state);\n\n    // Store target association (for guidance)\n    // ... implementation-specific ...\n\n    return missile;\n}\n\nvoid update_missile_guidance(Engine&amp; engine, EntityId missile, EntityId target) {\n    auto missile_state = engine.get_entity_state(missile);\n    auto target_state = engine.get_entity_state(target);\n\n    // Proportional navigation\n    Vec3 los = target_state.position - missile_state.position;\n    Vec3 rel_vel = target_state.velocity - missile_state.velocity;\n\n    Real range = los.norm();\n    Vec3 los_rate = los.cross(rel_vel) / (range * range);\n\n    // Acceleration command\n    Real N = 4.0;  // Navigation constant\n    Vec3 accel_cmd = missile_state.velocity.cross(los_rate) * N;\n\n    // Apply guidance command as force\n    physics::EntityForces forces;\n    forces.add_force(accel_cmd * missile_state.mass);\n    engine.apply_forces(missile, forces);\n}\n</code></pre>"},{"location":"tutorials/multi-entity/#tutorial-combined-arms-scenario","title":"Tutorial: Combined Arms Scenario","text":""},{"location":"tutorials/multi-entity/#mixed-domain-entities","title":"Mixed Domain Entities","text":"<pre><code>// Create ground forces\nEntityId tank1 = engine.create_entity(\"Tank-1\", Domain::Land);\nEntityId tank2 = engine.create_entity(\"Tank-2\", Domain::Land);\nEntityId apc1 = engine.create_entity(\"APC-1\", Domain::Land);\n\n// Create air support\nEntityId helo = engine.create_entity(\"Apache\", Domain::Air);\n\n// Create naval support\nEntityId ship = engine.create_entity(\"DDG-51\", Domain::Sea);\n\n// Simulation with different time steps\nReal fast_dt = 0.01;  // Aircraft\nReal slow_dt = 0.02;  // Ground/sea\n\nfor (Real t = 0; t &lt; duration; t += fast_dt) {\n    // Always update aircraft\n    update_aircraft(engine, helo, fast_dt);\n\n    // Update ground/sea at lower rate\n    if (std::fmod(t, slow_dt) &lt; fast_dt) {\n        update_ground_vehicle(engine, tank1, slow_dt);\n        update_ground_vehicle(engine, tank2, slow_dt);\n        update_ground_vehicle(engine, apc1, slow_dt);\n        update_ship(engine, ship, slow_dt);\n    }\n\n    engine.step(fast_dt);\n}\n</code></pre>"},{"location":"tutorials/multi-entity/#performance-optimization","title":"Performance Optimization","text":""},{"location":"tutorials/multi-entity/#spatial-partitioning","title":"Spatial Partitioning","text":"<pre><code>class SpatialGrid {\npublic:\n    SpatialGrid(Real cell_size) : cell_size_(cell_size) {}\n\n    void update(Engine&amp; engine, const std::vector&lt;EntityId&gt;&amp; entities) {\n        cells_.clear();\n        for (EntityId id : entities) {\n            auto state = engine.get_entity_state(id);\n            CellKey key = get_cell(state.position);\n            cells_[key].push_back(id);\n        }\n    }\n\n    std::vector&lt;EntityId&gt; get_nearby(const Vec3&amp; position, Real radius) {\n        std::vector&lt;EntityId&gt; result;\n        int cells_to_check = static_cast&lt;int&gt;(radius / cell_size_) + 1;\n\n        CellKey center = get_cell(position);\n        for (int dx = -cells_to_check; dx &lt;= cells_to_check; ++dx) {\n            for (int dy = -cells_to_check; dy &lt;= cells_to_check; ++dy) {\n                CellKey key{center.x + dx, center.y + dy};\n                if (cells_.count(key)) {\n                    for (EntityId id : cells_[key]) {\n                        result.push_back(id);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\nprivate:\n    struct CellKey {\n        int x, y;\n        bool operator&lt;(const CellKey&amp; other) const {\n            return std::tie(x, y) &lt; std::tie(other.x, other.y);\n        }\n    };\n\n    CellKey get_cell(const Vec3&amp; pos) {\n        return {static_cast&lt;int&gt;(pos.x / cell_size_),\n                static_cast&lt;int&gt;(pos.y / cell_size_)};\n    }\n\n    Real cell_size_;\n    std::map&lt;CellKey, std::vector&lt;EntityId&gt;&gt; cells_;\n};\n</code></pre>"},{"location":"tutorials/multi-entity/#parallel-processing","title":"Parallel Processing","text":"<pre><code>#include &lt;thread&gt;\n#include &lt;future&gt;\n\nvoid update_entities_parallel(Engine&amp; engine,\n                              std::vector&lt;EntityId&gt;&amp; entities,\n                              Real dt) {\n    // Split entities among threads\n    size_t num_threads = std::thread::hardware_concurrency();\n    size_t chunk_size = entities.size() / num_threads;\n\n    std::vector&lt;std::future&lt;void&gt;&gt; futures;\n    for (size_t i = 0; i &lt; num_threads; ++i) {\n        size_t start = i * chunk_size;\n        size_t end = (i == num_threads - 1) ? entities.size()\n                                            : (i + 1) * chunk_size;\n\n        futures.push_back(std::async(std::launch::async, [&amp;, start, end]() {\n            for (size_t j = start; j &lt; end; ++j) {\n                compute_forces(engine, entities[j], dt);\n            }\n        }));\n    }\n\n    // Wait for all threads\n    for (auto&amp; f : futures) {\n        f.get();\n    }\n\n    // Step engine (single-threaded)\n    engine.step(dt);\n}\n</code></pre>"},{"location":"tutorials/multi-entity/#network-distribution","title":"Network Distribution","text":""},{"location":"tutorials/multi-entity/#dis-integration","title":"DIS Integration","text":"<pre><code>#include &lt;jaguar/network/dis.h&gt;\n\n// Configure DIS\nnetwork::DISConfig dis_config;\ndis_config.port = 3000;\ndis_config.site_id = 1;\ndis_config.app_id = 1;\n\nnetwork::DISInterface dis;\ndis.initialize(dis_config);\n\n// Register entities for DIS\nfor (EntityId id : local_entities) {\n    dis.register_entity(id, get_dis_type(id));\n}\n\n// Simulation loop\nwhile (running) {\n    // Receive remote entity updates\n    dis.process_received_pdus();\n\n    // Update local entities\n    for (EntityId id : local_entities) {\n        update_entity(engine, id, dt);\n    }\n\n    // Publish local entity states\n    dis.publish_entity_states();\n\n    engine.step(dt);\n}\n</code></pre>"},{"location":"tutorials/multi-entity/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/multi-entity/#entity-management","title":"Entity Management","text":"<ol> <li>Group by domain: Process similar entities together</li> <li>Use spatial partitioning: For interaction queries</li> <li>Cull distant entities: Skip detailed physics for far entities</li> </ol>"},{"location":"tutorials/multi-entity/#performance","title":"Performance","text":"<ol> <li>Profile first: Identify actual bottlenecks</li> <li>Batch operations: Minimize per-entity overhead</li> <li>Consider multi-rate: Different update rates for different fidelity needs</li> </ol>"},{"location":"tutorials/multi-entity/#scalability","title":"Scalability","text":"<ul> <li>100s of entities: Single-threaded fine</li> <li>1000s of entities: Consider parallel processing</li> <li>10000+ entities: Use spatial partitioning, LOD, network distribution</li> </ul>"},{"location":"tutorials/multi-entity/#see-also","title":"See Also","text":"<ul> <li>Architecture - System architecture</li> <li>Network Integration - DIS/HLA</li> <li>API Reference - Complete API</li> </ul>"},{"location":"tutorials/python-scripting/","title":"Python Scripting Tutorial","text":"<p>This tutorial demonstrates how to use JaguarEngine's Python bindings for simulation scripting, scenario automation, and rapid prototyping.</p>"},{"location":"tutorials/python-scripting/#prerequisites","title":"Prerequisites","text":"<ul> <li>JaguarEngine built with Python bindings (<code>-DJAGUAR_BUILD_PYTHON=ON</code>)</li> <li>Python 3.8+</li> <li>NumPy installed (<code>pip install numpy</code>)</li> </ul>"},{"location":"tutorials/python-scripting/#installation","title":"Installation","text":""},{"location":"tutorials/python-scripting/#build-from-source","title":"Build from Source","text":"<pre><code>cd JaguarEngine\n\n# Configure with Python bindings enabled\ncmake -B build -DJAGUAR_BUILD_PYTHON=ON\n\n# Build\ncmake --build build --parallel\n\n# Install the module\npip install -e .\n</code></pre>"},{"location":"tutorials/python-scripting/#verify-installation","title":"Verify Installation","text":"<pre><code>import jaguar\nprint(f\"JaguarEngine version: {jaguar.__version__}\")\nprint(f\"Domains: {list(jaguar.Domain.__members__)}\")\n</code></pre>"},{"location":"tutorials/python-scripting/#tutorial-1-hello-world-minimal-simulation","title":"Tutorial 1: Hello World - Minimal Simulation","text":"<p>The simplest possible JaguarEngine Python program:</p> <pre><code>import jaguar\n\n# Create and initialize engine\nengine = jaguar.Engine()\nengine.initialize()\n\n# Create an entity\nentity = engine.create_entity(\"Test\", jaguar.Domain.Air)\n\n# Set initial state\nstate = jaguar.EntityState()\nstate.position = jaguar.Vec3(0, 0, -1000)  # 1 km altitude\nstate.velocity = jaguar.Vec3(100, 0, 0)    # 100 m/s forward\nstate.mass = 1000\nengine.set_entity_state(entity, state)\n\n# Run simulation\nfor _ in range(1000):  # 10 seconds at 100 Hz\n    engine.step(0.01)\n\n# Get final state\nfinal = engine.get_entity_state(entity)\nprint(f\"Final position: ({final.position.x:.1f}, {final.position.y:.1f}, {final.position.z:.1f})\")\n\nengine.shutdown()\n</code></pre>"},{"location":"tutorials/python-scripting/#tutorial-2-aircraft-simulation","title":"Tutorial 2: Aircraft Simulation","text":"<p>A complete aircraft simulation with aerodynamics and propulsion:</p> <pre><code>import jaguar\nfrom jaguar.domain import air\n\ndef main():\n    print(\"F-16 Flight Simulation (Python)\\n\")\n\n    # Initialize engine\n    engine = jaguar.Engine()\n    engine.initialize()\n\n    # Create aircraft entity\n    aircraft = engine.create_entity(\"F-16\", jaguar.Domain.Air)\n\n    # Configure aerodynamics\n    aero = air.AerodynamicsModel()\n    aero.set_reference_area(27.87)    # m\u00b2\n    aero.set_reference_chord(3.45)    # m\n    aero.set_reference_span(9.45)     # m\n\n    # Configure propulsion\n    propulsion = air.PropulsionModel()\n    propulsion.set_max_thrust(131000.0)  # N\n    propulsion.set_fuel_capacity(3200.0)  # kg\n    propulsion.set_specific_fuel_consumption(2.5e-5)\n    propulsion.start()\n    propulsion.set_throttle(0.85)  # 85% power\n\n    # Set initial state (10 km altitude, 250 m/s)\n    state = jaguar.EntityState()\n    state.position = jaguar.Vec3(0, 0, -10000)\n    state.velocity = jaguar.Vec3(250, 0, 0)\n    state.orientation = jaguar.Quaternion.from_euler(0, 0, 0)\n    state.mass = 12000\n    engine.set_entity_state(aircraft, state)\n\n    # Print header\n    print(f\"{'Time(s)':&gt;7} | {'Alt(m)':&gt;9} | {'Speed(m/s)':&gt;10} | {'Mach':&gt;5} | {'Fuel(kg)':&gt;8}\")\n    print(\"-\" * 55)\n\n    # Simulation loop\n    dt = 0.01  # 100 Hz\n    forces = jaguar.EntityForces()\n\n    for i in range(6000):  # 60 seconds\n        t = i * dt\n\n        # Get current state and environment\n        s = engine.get_entity_state(aircraft)\n        env = engine.get_environment(aircraft)\n\n        # Compute forces\n        forces.clear()\n        aero.compute_forces(s, env, dt, forces)\n        propulsion.compute_forces(s, env, dt, forces)\n\n        # Add gravity\n        forces.add_force(jaguar.Vec3(0, 0, s.mass * jaguar.G0))\n\n        # Apply and step\n        engine.apply_forces(aircraft, forces)\n        engine.step(dt)\n\n        # Print telemetry every 5 seconds\n        if i % 500 == 0:\n            print(f\"{t:7.1f} | {-s.position.z:9.0f} | {s.velocity.norm():10.1f} | \"\n                  f\"{aero.get_mach():5.2f} | {propulsion.get_fuel_remaining():8.1f}\")\n\n    engine.shutdown()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tutorials/python-scripting/#tutorial-3-numpy-integration","title":"Tutorial 3: NumPy Integration","text":"<p>Leverage NumPy for efficient batch operations and data analysis:</p> <pre><code>import jaguar\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef run_trajectory_simulation():\n    \"\"\"Simulate a ballistic trajectory and plot results.\"\"\"\n\n    engine = jaguar.Engine()\n    engine.initialize()\n\n    projectile = engine.create_entity(\"Projectile\", jaguar.Domain.Air)\n\n    # Initial conditions: 45\u00b0 launch at 500 m/s\n    v0 = 500.0\n    angle = 45.0 * jaguar.DEG_TO_RAD\n\n    state = jaguar.EntityState()\n    state.position = jaguar.Vec3(0, 0, 0)\n    state.velocity = jaguar.Vec3(v0 * np.cos(angle), 0, -v0 * np.sin(angle))\n    state.mass = 100.0\n    engine.set_entity_state(projectile, state)\n\n    # Data collection arrays\n    times = []\n    positions = []\n    velocities = []\n\n    dt = 0.01\n    t = 0.0\n    forces = jaguar.EntityForces()\n\n    while True:\n        s = engine.get_entity_state(projectile)\n        env = engine.get_environment(projectile)\n\n        # Store data\n        times.append(t)\n        positions.append(s.position.to_numpy())\n        velocities.append(s.velocity.to_numpy())\n\n        # Check if hit ground\n        if s.position.z &gt; 0 and t &gt; 0.1:\n            break\n\n        # Apply gravity only\n        forces.clear()\n        forces.add_force(jaguar.Vec3(0, 0, s.mass * jaguar.G0))\n\n        engine.apply_forces(projectile, forces)\n        engine.step(dt)\n        t += dt\n\n        if t &gt; 120:  # Safety limit\n            break\n\n    engine.shutdown()\n\n    # Convert to NumPy arrays\n    times = np.array(times)\n    positions = np.array(positions)\n    velocities = np.array(velocities)\n\n    # Analysis\n    max_height = -np.min(positions[:, 2])\n    range_dist = positions[-1, 0]\n    flight_time = times[-1]\n\n    print(f\"Trajectory Analysis:\")\n    print(f\"  Max height: {max_height:.1f} m\")\n    print(f\"  Range: {range_dist:.1f} m\")\n    print(f\"  Flight time: {flight_time:.2f} s\")\n\n    # Plot trajectory\n    plt.figure(figsize=(12, 5))\n\n    plt.subplot(1, 2, 1)\n    plt.plot(positions[:, 0], -positions[:, 2])\n    plt.xlabel('Distance (m)')\n    plt.ylabel('Height (m)')\n    plt.title('Ballistic Trajectory')\n    plt.grid(True)\n\n    plt.subplot(1, 2, 2)\n    speed = np.linalg.norm(velocities, axis=1)\n    plt.plot(times, speed)\n    plt.xlabel('Time (s)')\n    plt.ylabel('Speed (m/s)')\n    plt.title('Speed vs Time')\n    plt.grid(True)\n\n    plt.tight_layout()\n    plt.savefig('trajectory.png')\n    plt.show()\n\nif __name__ == \"__main__\":\n    run_trajectory_simulation()\n</code></pre>"},{"location":"tutorials/python-scripting/#tutorial-4-multi-entity-scenario","title":"Tutorial 4: Multi-Entity Scenario","text":"<p>Simulate multiple entities interacting in the same environment:</p> <pre><code>import jaguar\nimport numpy as np\n\ndef create_formation(engine, base_name, domain, count, spacing):\n    \"\"\"Create a formation of entities.\"\"\"\n    entities = []\n    for i in range(count):\n        name = f\"{base_name}-{i+1}\"\n        entity = engine.create_entity(name, domain)\n        entities.append(entity)\n    return entities\n\ndef main():\n    print(\"Multi-Domain Scenario Simulation\\n\")\n\n    engine = jaguar.Engine()\n    engine.initialize()\n\n    # Create blue force (4 aircraft)\n    blue_aircraft = create_formation(engine, \"Blue\", jaguar.Domain.Air, 4, 500)\n\n    # Create red force (4 aircraft)\n    red_aircraft = create_formation(engine, \"Red\", jaguar.Domain.Air, 4, 500)\n\n    # Set blue force initial states (from west)\n    for i, aircraft in enumerate(blue_aircraft):\n        state = jaguar.EntityState()\n        state.position = jaguar.Vec3(0, i * 500, -8000)\n        state.velocity = jaguar.Vec3(250, 0, 0)  # Heading east\n        state.mass = 12000\n        engine.set_entity_state(aircraft, state)\n\n    # Set red force initial states (from east)\n    for i, aircraft in enumerate(red_aircraft):\n        state = jaguar.EntityState()\n        state.position = jaguar.Vec3(50000, i * 500, -8000)\n        state.velocity = jaguar.Vec3(-250, 0, 0)  # Heading west\n        state.mass = 12000\n        engine.set_entity_state(aircraft, state)\n\n    print(f\"Created {len(blue_aircraft)} Blue aircraft and {len(red_aircraft)} Red aircraft\")\n    print(\"Starting simulation...\\n\")\n\n    # Simulation loop\n    dt = 0.01\n    duration = 120.0  # 2 minutes\n\n    for t in np.arange(0, duration, dt):\n        engine.step(dt)\n\n        # Log every 10 seconds\n        if abs(t % 10.0) &lt; dt:\n            print(f\"T = {t:.0f}s\")\n\n            # Calculate closest approach\n            min_dist = float('inf')\n            for blue in blue_aircraft:\n                blue_state = engine.get_entity_state(blue)\n                for red in red_aircraft:\n                    red_state = engine.get_entity_state(red)\n                    dist = (blue_state.position - red_state.position).norm()\n                    min_dist = min(min_dist, dist)\n\n            print(f\"  Closest blue-red distance: {min_dist:.0f} m\")\n\n    print(\"\\nSimulation complete!\")\n    engine.shutdown()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tutorials/python-scripting/#tutorial-5-custom-scenario-script","title":"Tutorial 5: Custom Scenario Script","text":"<p>Create a reusable scenario framework:</p> <pre><code>import jaguar\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport json\n\n@dataclass\nclass EntityConfig:\n    name: str\n    domain: str\n    position: List[float]\n    velocity: List[float]\n    mass: float\n\n@dataclass\nclass ScenarioConfig:\n    name: str\n    duration: float\n    time_step: float\n    entities: List[EntityConfig]\n\ndef load_scenario(filepath: str) -&gt; ScenarioConfig:\n    \"\"\"Load scenario from JSON file.\"\"\"\n    with open(filepath, 'r') as f:\n        data = json.load(f)\n\n    entities = [EntityConfig(**e) for e in data['entities']]\n    return ScenarioConfig(\n        name=data['name'],\n        duration=data['duration'],\n        time_step=data['time_step'],\n        entities=entities\n    )\n\ndef domain_from_string(domain_str: str) -&gt; jaguar.Domain:\n    \"\"\"Convert string to Domain enum.\"\"\"\n    domains = {\n        'air': jaguar.Domain.Air,\n        'land': jaguar.Domain.Land,\n        'sea': jaguar.Domain.Sea,\n        'space': jaguar.Domain.Space,\n    }\n    return domains.get(domain_str.lower(), jaguar.Domain.Generic)\n\nclass Scenario:\n    def __init__(self, config: ScenarioConfig):\n        self.config = config\n        self.engine = jaguar.Engine()\n        self.entities: Dict[str, int] = {}\n        self.time = 0.0\n        self.data: Dict[str, List] = {}\n\n    def setup(self):\n        \"\"\"Initialize scenario.\"\"\"\n        self.engine.initialize()\n\n        for entity_cfg in self.config.entities:\n            # Create entity\n            domain = domain_from_string(entity_cfg.domain)\n            entity_id = self.engine.create_entity(entity_cfg.name, domain)\n            self.entities[entity_cfg.name] = entity_id\n\n            # Set initial state\n            state = jaguar.EntityState()\n            state.position = jaguar.Vec3(*entity_cfg.position)\n            state.velocity = jaguar.Vec3(*entity_cfg.velocity)\n            state.mass = entity_cfg.mass\n            self.engine.set_entity_state(entity_id, state)\n\n            # Initialize data collection\n            self.data[entity_cfg.name] = []\n\n        print(f\"Scenario '{self.config.name}' initialized with {len(self.entities)} entities\")\n\n    def step(self):\n        \"\"\"Advance simulation by one time step.\"\"\"\n        self.engine.step(self.config.time_step)\n        self.time += self.config.time_step\n\n        # Collect data\n        for name, entity_id in self.entities.items():\n            state = self.engine.get_entity_state(entity_id)\n            self.data[name].append({\n                'time': self.time,\n                'position': state.position.to_numpy().tolist(),\n                'velocity': state.velocity.to_numpy().tolist(),\n            })\n\n    def run(self, callback=None):\n        \"\"\"Run complete scenario.\"\"\"\n        steps = int(self.config.duration / self.config.time_step)\n\n        for i in range(steps):\n            self.step()\n\n            if callback:\n                callback(self, i, steps)\n\n        print(f\"Scenario completed at T = {self.time:.2f}s\")\n\n    def cleanup(self):\n        \"\"\"Shutdown engine.\"\"\"\n        self.engine.shutdown()\n\n    def export_results(self, filepath: str):\n        \"\"\"Export collected data to JSON.\"\"\"\n        results = {\n            'scenario': self.config.name,\n            'duration': self.config.duration,\n            'time_step': self.config.time_step,\n            'entities': self.data\n        }\n\n        with open(filepath, 'w') as f:\n            json.dump(results, f, indent=2)\n\n        print(f\"Results exported to {filepath}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    # Create scenario configuration programmatically\n    config = ScenarioConfig(\n        name=\"Intercept Scenario\",\n        duration=60.0,\n        time_step=0.01,\n        entities=[\n            EntityConfig(\"Target\", \"air\", [0, 0, -8000], [200, 0, 0], 10000),\n            EntityConfig(\"Interceptor\", \"air\", [30000, 5000, -10000], [-300, -50, 20], 15000),\n        ]\n    )\n\n    # Run scenario\n    scenario = Scenario(config)\n    scenario.setup()\n\n    def progress_callback(sc, step, total):\n        if step % 1000 == 0:\n            print(f\"Progress: {100 * step / total:.0f}%\")\n\n    scenario.run(callback=progress_callback)\n    scenario.export_results(\"intercept_results.json\")\n    scenario.cleanup()\n</code></pre>"},{"location":"tutorials/python-scripting/#tutorial-6-coordinate-transforms","title":"Tutorial 6: Coordinate Transforms","text":"<p>Working with geodetic coordinates and reference frames:</p> <pre><code>import jaguar\nfrom jaguar import transforms\nimport numpy as np\n\ndef geodetic_to_simulation():\n    \"\"\"Convert geodetic (lat/lon/alt) to simulation coordinates.\"\"\"\n\n    # Example locations\n    locations = [\n        (\"New York\", 40.7128, -74.0060, 0),\n        (\"London\", 51.5074, -0.1278, 0),\n        (\"Tokyo\", 35.6762, 139.6503, 0),\n    ]\n\n    print(\"Geodetic to ECEF Conversion:\")\n    print(f\"{'Location':&lt;12} | {'Lat':&gt;10} | {'Lon':&gt;10} | {'ECEF X (km)':&gt;12} | {'ECEF Y (km)':&gt;12} | {'ECEF Z (km)':&gt;12}\")\n    print(\"-\" * 80)\n\n    for name, lat, lon, alt in locations:\n        lat_rad = lat * jaguar.DEG_TO_RAD\n        lon_rad = lon * jaguar.DEG_TO_RAD\n\n        ecef = transforms.geodetic_to_ecef(lat_rad, lon_rad, alt)\n\n        print(f\"{name:&lt;12} | {lat:&gt;10.4f} | {lon:&gt;10.4f} | {ecef.x/1000:&gt;12.1f} | {ecef.y/1000:&gt;12.1f} | {ecef.z/1000:&gt;12.1f}\")\n\ndef aircraft_at_location():\n    \"\"\"Simulate aircraft at a specific geodetic location.\"\"\"\n\n    engine = jaguar.Engine()\n    engine.initialize()\n\n    aircraft = engine.create_entity(\"Aircraft\", jaguar.Domain.Air)\n\n    # Aircraft over San Francisco at 10 km altitude\n    lat = 37.7749 * jaguar.DEG_TO_RAD\n    lon = -122.4194 * jaguar.DEG_TO_RAD\n    alt = 10000  # meters\n\n    # Convert to ECEF\n    position = transforms.geodetic_to_ecef(lat, lon, alt)\n\n    # Velocity: 250 m/s heading east (need to compute local east direction)\n    # Simplified: assume local east is roughly +Y in ECEF at this longitude\n    speed = 250.0\n    velocity = jaguar.Vec3(\n        -speed * np.sin(lon),  # East component\n        speed * np.cos(lon),\n        0\n    )\n\n    state = jaguar.EntityState()\n    state.position = position\n    state.velocity = velocity\n    state.mass = 12000\n    engine.set_entity_state(aircraft, state)\n\n    print(f\"\\nAircraft initialized over San Francisco:\")\n    print(f\"  Position (ECEF): ({position.x:.0f}, {position.y:.0f}, {position.z:.0f}) m\")\n    print(f\"  Altitude: {alt} m\")\n\n    # Simulate for 60 seconds\n    dt = 0.01\n    for _ in range(6000):\n        engine.step(dt)\n\n    # Get final position and convert back to geodetic\n    final_state = engine.get_entity_state(aircraft)\n    final_lat, final_lon, final_alt = transforms.ecef_to_geodetic(final_state.position)\n\n    print(f\"\\nAfter 60 seconds:\")\n    print(f\"  Latitude: {final_lat * jaguar.RAD_TO_DEG:.4f}\u00b0\")\n    print(f\"  Longitude: {final_lon * jaguar.RAD_TO_DEG:.4f}\u00b0\")\n    print(f\"  Altitude: {final_alt:.0f} m\")\n\n    engine.shutdown()\n\nif __name__ == \"__main__\":\n    geodetic_to_simulation()\n    aircraft_at_location()\n</code></pre>"},{"location":"tutorials/python-scripting/#common-patterns","title":"Common Patterns","text":""},{"location":"tutorials/python-scripting/#pattern-property-access","title":"Pattern: Property Access","text":"<pre><code># Get/set engine properties\ntime_scale = engine.get_property(\"time.scale\")\nengine.set_property(\"time.scale\", 2.0)  # 2x speed\n\n# Entity-specific properties\nthrottle = engine.get_property(aircraft, \"throttle\")\nengine.set_property(aircraft, \"throttle\", 0.9)\n</code></pre>"},{"location":"tutorials/python-scripting/#pattern-event-handling","title":"Pattern: Event Handling","text":"<pre><code># Query simulation state\nif engine.get_state() == jaguar.SimulationState.Running:\n    engine.pause()\n\n# Check entity existence\nif engine.entity_exists(entity_id):\n    state = engine.get_entity_state(entity_id)\n</code></pre>"},{"location":"tutorials/python-scripting/#pattern-error-handling","title":"Pattern: Error Handling","text":"<pre><code>try:\n    engine = jaguar.Engine()\n    if not engine.initialize():\n        raise RuntimeError(\"Engine initialization failed\")\n\n    # ... simulation code ...\n\nexcept Exception as e:\n    print(f\"Simulation error: {e}\")\nfinally:\n    engine.shutdown()\n</code></pre>"},{"location":"tutorials/python-scripting/#debugging-tips","title":"Debugging Tips","text":""},{"location":"tutorials/python-scripting/#check-entity-state","title":"Check Entity State","text":"<pre><code>def debug_entity(engine, entity_id, name=\"Entity\"):\n    \"\"\"Print detailed entity state for debugging.\"\"\"\n    state = engine.get_entity_state(entity_id)\n    env = engine.get_environment(entity_id)\n\n    print(f\"\\n=== {name} Debug Info ===\")\n    print(f\"Position: ({state.position.x:.2f}, {state.position.y:.2f}, {state.position.z:.2f})\")\n    print(f\"Velocity: ({state.velocity.x:.2f}, {state.velocity.y:.2f}, {state.velocity.z:.2f})\")\n    print(f\"Speed: {state.velocity.norm():.2f} m/s\")\n    print(f\"Mass: {state.mass:.1f} kg\")\n    print(f\"Altitude: {env.altitude:.1f} m\")\n    print(f\"Atmosphere: T={env.atmosphere.temperature:.1f}K, \u03c1={env.atmosphere.density:.4f} kg/m\u00b3\")\n</code></pre>"},{"location":"tutorials/python-scripting/#performance-profiling","title":"Performance Profiling","text":"<pre><code>import time\n\ndef profile_simulation(engine, steps, dt):\n    \"\"\"Measure simulation performance.\"\"\"\n    start = time.perf_counter()\n\n    for _ in range(steps):\n        engine.step(dt)\n\n    elapsed = time.perf_counter() - start\n    sim_time = steps * dt\n\n    print(f\"Simulated {sim_time:.1f}s in {elapsed:.3f}s real time\")\n    print(f\"Real-time factor: {sim_time / elapsed:.1f}x\")\n    print(f\"Steps/second: {steps / elapsed:.0f}\")\n</code></pre>"},{"location":"tutorials/python-scripting/#next-steps","title":"Next Steps","text":"<ul> <li>Lua Scripting Tutorial - Lua scripting guide</li> <li>Examples Guide - More example code</li> <li>Python API Reference - Complete API documentation</li> <li>Air Domain Tutorial - Aircraft simulation deep dive</li> </ul>"},{"location":"tutorials/sea-domain/","title":"Sea Domain Tutorial","text":"<p>This tutorial demonstrates how to simulate naval vessels using JaguarEngine's Sea domain.</p>"},{"location":"tutorials/sea-domain/#prerequisites","title":"Prerequisites","text":"<ul> <li>JaguarEngine installed and configured</li> <li>Basic understanding of ship dynamics</li> <li>C++ development environment</li> </ul>"},{"location":"tutorials/sea-domain/#tutorial-surface-ship-simulation","title":"Tutorial: Surface Ship Simulation","text":""},{"location":"tutorials/sea-domain/#step-1-create-the-engine","title":"Step 1: Create the Engine","text":"<pre><code>#include &lt;jaguar/jaguar.h&gt;\n\nusing namespace jaguar;\n\nint main() {\n    Engine engine;\n    if (!engine.initialize()) {\n        std::cerr &lt;&lt; \"Failed to initialize engine\\n\";\n        return 1;\n    }\n</code></pre>"},{"location":"tutorials/sea-domain/#step-2-create-a-ship-entity","title":"Step 2: Create a Ship Entity","text":"<pre><code>    // Create destroyer entity\n    EntityId ship = engine.create_entity(\"DDG51\", Domain::Sea);\n</code></pre>"},{"location":"tutorials/sea-domain/#step-3-set-initial-state","title":"Step 3: Set Initial State","text":"<pre><code>    // Configure initial state\n    physics::EntityState state;\n\n    // Position: At sea surface\n    state.position = Vec3{0.0, 0.0, 0.0};\n\n    // Velocity: 15 knots (7.7 m/s) heading North\n    state.velocity = Vec3{7.7, 0.0, 0.0};\n\n    // Orientation: Level, heading North\n    state.orientation = Quaternion::identity();\n\n    // Mass: 8,600 tonnes displacement\n    state.mass = 8600000.0;\n\n    // Inertia (simplified)\n    state.inertia = Mat3x3::identity();\n    state.inertia.data[0][0] = 1e10;   // Ixx (roll)\n    state.inertia.data[1][1] = 5e10;   // Iyy (pitch)\n    state.inertia.data[2][2] = 5e10;   // Izz (yaw)\n\n    engine.set_entity_state(ship, state);\n</code></pre>"},{"location":"tutorials/sea-domain/#step-4-create-physics-models","title":"Step 4: Create Physics Models","text":"<pre><code>    // Create buoyancy model\n    domain::sea::BuoyancyModel buoyancy;\n    buoyancy.set_displaced_volume(8390.0);      // m\u00b3 (at full load)\n    buoyancy.set_metacentric_height(2.5);       // GM = 2.5 m\n    buoyancy.set_center_of_buoyancy(Vec3{0.0, 0.0, -4.7});  // Below CG\n\n    // Create hydrodynamics model (MMG)\n    domain::sea::HydrodynamicsModel hydro;\n    hydro.set_hull_coefficients(\n        -0.04,  // X_vv\n        -0.01,  // X_rr\n        -0.4,   // Y_v\n        0.05,   // Y_r\n        -0.1,   // N_v\n        -0.05   // N_r\n    );\n    hydro.set_rudder_parameters(18.0, 1.6);     // Area (m\u00b2), aspect ratio\n    hydro.set_propeller_parameters(5.2, 1.0);   // Diameter (m), pitch ratio\n\n    // Create wave model\n    domain::sea::WaveModel waves;\n    waves.set_sea_state(domain::sea::SeaState::FromNATOSeaState(4));\n\n    // Create RAO model for ship motion response\n    domain::sea::RAOModel rao;\n    // Set heave RAO\n    rao.set_rao(2,  // DOF 2 = heave\n        {0.3, 0.5, 0.7, 1.0, 1.5},  // frequencies (rad/s)\n        {0.9, 1.0, 0.95, 0.7, 0.4}, // amplitudes\n        {0.0, 0.1, 0.2, 0.4, 0.6}); // phases (rad)\n</code></pre>"},{"location":"tutorials/sea-domain/#step-5-run-the-simulation","title":"Step 5: Run the Simulation","text":"<pre><code>    // Simulation parameters\n    Real dt = 0.05;       // 20 Hz\n    Real duration = 120.0; // 2 minutes\n    Real rudder_cmd = 0.0;\n    Real rpm_cmd = 100.0;\n\n    std::cout &lt;&lt; \"Time(s), Speed(kts), Heel(deg), Draft(m)\\n\";\n\n    for (Real t = 0; t &lt; duration; t += dt) {\n        auto state = engine.get_entity_state(ship);\n\n        // Build environment with wave data\n        environment::Environment env = engine.get_environment(ship);\n        env.over_water = true;\n        env.ocean.surface_elevation = waves.get_elevation(\n            state.position.x, state.position.y, t);\n\n        // Set controls\n        hydro.set_rudder_angle(rudder_cmd * 0.52);  // Max 30\u00b0\n        hydro.set_propeller_rpm(rpm_cmd);\n\n        // Compute forces\n        physics::EntityForces forces;\n        forces.clear();\n\n        buoyancy.compute_forces(state, env, dt, forces);\n        hydro.compute_forces(state, env, dt, forces);\n\n        // Add wave-induced motions via RAO\n        Vec3 wave_disp, wave_rot;\n        rao.calculate_response(waves, t, wave_disp, wave_rot);\n\n        // Gravity\n        forces.add_force(Vec3{0.0, 0.0, state.mass * constants::G0});\n\n        // Apply forces and step\n        engine.apply_forces(ship, forces);\n        engine.step(dt);\n\n        // Output telemetry every 5 seconds\n        if (std::fmod(t, 5.0) &lt; dt) {\n            Real speed_kts = state.velocity.norm() * 1.944;\n            Real heel_deg = buoyancy.get_heel() * constants::RAD_TO_DEG;\n            Real draft = buoyancy.get_draft();\n\n            std::cout &lt;&lt; t &lt;&lt; \", \"\n                      &lt;&lt; speed_kts &lt;&lt; \", \"\n                      &lt;&lt; heel_deg &lt;&lt; \", \"\n                      &lt;&lt; draft &lt;&lt; \"\\n\";\n        }\n    }\n\n    engine.shutdown();\n    return 0;\n}\n</code></pre>"},{"location":"tutorials/sea-domain/#tutorial-maneuvering","title":"Tutorial: Maneuvering","text":""},{"location":"tutorials/sea-domain/#turning-circle-test","title":"Turning Circle Test","text":"<pre><code>// Turning circle maneuver\nvoid turning_circle_test(Engine&amp; engine, EntityId ship,\n                         domain::sea::HydrodynamicsModel&amp; hydro) {\n    Real dt = 0.05;\n    Real duration = 600.0;  // 10 minutes\n\n    // Initial straight run\n    hydro.set_rudder_angle(0.0);\n    for (Real t = 0; t &lt; 30.0; t += dt) {\n        run_step(engine, ship, hydro, dt);\n    }\n\n    // Apply rudder\n    Real rudder_deg = 35.0;  // 35\u00b0 rudder\n    hydro.set_rudder_angle(rudder_deg * constants::DEG_TO_RAD);\n\n    // Record trajectory\n    std::vector&lt;Vec3&gt; trajectory;\n    Vec3 initial_pos = engine.get_entity_state(ship).position;\n\n    for (Real t = 0; t &lt; duration; t += dt) {\n        run_step(engine, ship, hydro, dt);\n\n        if (std::fmod(t, 1.0) &lt; dt) {\n            Vec3 pos = engine.get_entity_state(ship).position;\n            trajectory.push_back(pos - initial_pos);\n        }\n    }\n\n    // Analyze turning circle\n    // - Advance: Forward distance at 90\u00b0 heading change\n    // - Transfer: Lateral distance at 90\u00b0 heading change\n    // - Tactical diameter: Lateral distance at 180\u00b0 heading change\n    // - Turning radius: Radius of steady turn\n}\n</code></pre>"},{"location":"tutorials/sea-domain/#zig-zag-maneuver","title":"Zig-Zag Maneuver","text":"<pre><code>void zigzag_test(Engine&amp; engine, EntityId ship,\n                 domain::sea::HydrodynamicsModel&amp; hydro,\n                 Real rudder_angle_deg,\n                 Real heading_change_deg) {\n    Real dt = 0.05;\n    Real initial_heading = get_heading(engine.get_entity_state(ship));\n    Real target_heading = initial_heading;\n    int direction = 1;  // 1 = starboard, -1 = port\n\n    while (/* test not complete */) {\n        auto state = engine.get_entity_state(ship);\n        Real current_heading = get_heading(state);\n\n        // Check if heading change threshold reached\n        Real heading_error = current_heading - target_heading;\n        normalize_angle(heading_error);\n\n        if (direction * heading_error &gt; heading_change_deg * DEG_TO_RAD) {\n            // Reverse rudder\n            direction *= -1;\n            target_heading = initial_heading + direction * heading_change_deg * DEG_TO_RAD;\n        }\n\n        hydro.set_rudder_angle(direction * rudder_angle_deg * DEG_TO_RAD);\n        run_step(engine, ship, hydro, dt);\n    }\n}\n</code></pre>"},{"location":"tutorials/sea-domain/#tutorial-seakeeping","title":"Tutorial: Seakeeping","text":""},{"location":"tutorials/sea-domain/#wave-response-analysis","title":"Wave Response Analysis","text":"<pre><code>// Analyze ship motion in waves\nvoid seakeeping_analysis(Engine&amp; engine, EntityId ship,\n                         domain::sea::WaveModel&amp; waves,\n                         domain::sea::RAOModel&amp; rao) {\n    Real dt = 0.05;\n    Real duration = 300.0;  // 5 minutes\n\n    // Data collection\n    std::vector&lt;Real&gt; heave_data, roll_data, pitch_data;\n\n    for (Real t = 0; t &lt; duration; t += dt) {\n        auto state = engine.get_entity_state(ship);\n\n        // Get wave-induced motions\n        Vec3 disp, rot;\n        rao.calculate_response(waves, t, disp, rot);\n\n        heave_data.push_back(disp.z);\n        roll_data.push_back(rot.x);\n        pitch_data.push_back(rot.y);\n\n        engine.step(dt);\n    }\n\n    // Statistical analysis\n    Real heave_rms = compute_rms(heave_data);\n    Real roll_rms = compute_rms(roll_data);\n    Real pitch_rms = compute_rms(pitch_data);\n\n    std::cout &lt;&lt; \"Heave RMS: \" &lt;&lt; heave_rms &lt;&lt; \" m\\n\";\n    std::cout &lt;&lt; \"Roll RMS: \" &lt;&lt; roll_rms * RAD_TO_DEG &lt;&lt; \" deg\\n\";\n    std::cout &lt;&lt; \"Pitch RMS: \" &lt;&lt; pitch_rms * RAD_TO_DEG &lt;&lt; \" deg\\n\";\n}\n</code></pre>"},{"location":"tutorials/sea-domain/#xml-configuration","title":"XML Configuration","text":""},{"location":"tutorials/sea-domain/#ship-definition","title":"Ship Definition","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;entity type=\"surface_ship\" name=\"DDG51\"&gt;\n    &lt;metrics&gt;\n        &lt;length unit=\"m\"&gt;154.0&lt;/length&gt;\n        &lt;beam unit=\"m\"&gt;20.0&lt;/beam&gt;\n        &lt;draft unit=\"m\"&gt;9.4&lt;/draft&gt;\n    &lt;/metrics&gt;\n\n    &lt;mass_balance&gt;\n        &lt;displacement unit=\"tonnes\"&gt;8600&lt;/displacement&gt;\n        &lt;metacentric_height unit=\"m\"&gt;2.5&lt;/metacentric_height&gt;\n    &lt;/mass_balance&gt;\n\n    &lt;hydrodynamics&gt;\n        &lt;hull_coefficients&gt;\n            &lt;x_vv&gt;-0.04&lt;/x_vv&gt;\n            &lt;y_v&gt;-0.4&lt;/y_v&gt;\n            &lt;n_v&gt;-0.1&lt;/n_v&gt;\n            &lt;n_r&gt;-0.05&lt;/n_r&gt;\n        &lt;/hull_coefficients&gt;\n\n        &lt;rudder&gt;\n            &lt;area unit=\"m2\"&gt;18.0&lt;/area&gt;\n            &lt;max_angle unit=\"deg\"&gt;35&lt;/max_angle&gt;\n        &lt;/rudder&gt;\n\n        &lt;propeller&gt;\n            &lt;diameter unit=\"m\"&gt;5.2&lt;/diameter&gt;\n            &lt;max_rpm&gt;180&lt;/max_rpm&gt;\n        &lt;/propeller&gt;\n    &lt;/hydrodynamics&gt;\n&lt;/entity&gt;\n</code></pre>"},{"location":"tutorials/sea-domain/#common-issues","title":"Common Issues","text":""},{"location":"tutorials/sea-domain/#capsizing","title":"Capsizing","text":"<p>Symptoms: Ship rolls over</p> <p>Solutions: - Increase metacentric height (GM) - Check displacement volume - Verify mass distribution</p>"},{"location":"tutorials/sea-domain/#unrealistic-speed","title":"Unrealistic Speed","text":"<p>Symptoms: Ship accelerates too fast/slow</p> <p>Solutions: - Check propeller parameters - Verify hull resistance coefficients - Check thrust deduction factor</p>"},{"location":"tutorials/sea-domain/#next-steps","title":"Next Steps","text":"<ul> <li>Air Domain Tutorial - Aircraft simulation</li> <li>Land Domain Tutorial - Ground vehicle simulation</li> <li>Multi-Entity Tutorial - Multiple ship simulation</li> <li>API Reference - Sea domain API</li> </ul>"},{"location":"tutorials/space-domain/","title":"Space Domain Tutorial","text":"<p>This tutorial demonstrates how to simulate satellites using JaguarEngine's Space domain.</p>"},{"location":"tutorials/space-domain/#prerequisites","title":"Prerequisites","text":"<ul> <li>JaguarEngine installed and configured</li> <li>Basic understanding of orbital mechanics</li> <li>C++ development environment</li> </ul>"},{"location":"tutorials/space-domain/#tutorial-satellite-simulation","title":"Tutorial: Satellite Simulation","text":""},{"location":"tutorials/space-domain/#step-1-create-the-engine","title":"Step 1: Create the Engine","text":"<pre><code>#include &lt;jaguar/jaguar.h&gt;\n\nusing namespace jaguar;\n\nint main() {\n    Engine engine;\n    if (!engine.initialize()) {\n        std::cerr &lt;&lt; \"Failed to initialize engine\\n\";\n        return 1;\n    }\n</code></pre>"},{"location":"tutorials/space-domain/#step-2-create-a-satellite-entity","title":"Step 2: Create a Satellite Entity","text":"<pre><code>    // Create satellite entity\n    EntityId satellite = engine.create_entity(\"ISS\", Domain::Space);\n</code></pre>"},{"location":"tutorials/space-domain/#step-3-define-the-orbit","title":"Step 3: Define the Orbit","text":"<pre><code>    // Define orbital elements (ISS-like orbit)\n    domain::space::OrbitalElements orbit;\n    orbit.semi_major_axis = constants::EARTH_RADIUS + 420000.0; // 420 km altitude\n    orbit.eccentricity = 0.0001;        // Nearly circular\n    orbit.inclination = 51.6 * constants::DEG_TO_RAD;\n    orbit.raan = 0.0;\n    orbit.arg_of_perigee = 0.0;\n    orbit.true_anomaly = 0.0;\n\n    // Convert to state vectors\n    Vec3 pos_eci, vel_eci;\n    orbit.to_state_vector(pos_eci, vel_eci);\n\n    // Set initial state\n    physics::EntityState state;\n    state.position = pos_eci;\n    state.velocity = vel_eci;\n    state.mass = 420000.0;  // ISS mass (kg)\n\n    // Inertia tensor\n    state.inertia = Mat3x3::identity();\n    state.inertia.data[0][0] = 1e8;\n    state.inertia.data[1][1] = 1e8;\n    state.inertia.data[2][2] = 1e8;\n\n    engine.set_entity_state(satellite, state);\n</code></pre>"},{"location":"tutorials/space-domain/#step-4-create-physics-models","title":"Step 4: Create Physics Models","text":"<pre><code>    // Create gravity model (J2 perturbation)\n    domain::space::GravityModel gravity;\n    gravity.set_fidelity(1);  // J2 level\n\n    // Create atmospheric drag model\n    domain::space::AtmosphericDragModel drag;\n    drag.set_cd(2.2);\n    drag.set_area(2500.0);  // ISS cross-section (m\u00b2)\n\n    // Create atmosphere model\n    domain::space::JB08AtmosphereModel atm;\n    atm.set_space_weather(150.0, 145.0, 15.0);  // Moderate solar activity\n</code></pre>"},{"location":"tutorials/space-domain/#step-5-run-the-simulation","title":"Step 5: Run the Simulation","text":"<pre><code>    // Simulation parameters\n    Real dt = 60.0;                    // 1 minute steps\n    Real duration = orbit.period();   // One orbital period\n\n    std::cout &lt;&lt; \"Time(min), Altitude(km), Lat(deg), Lon(deg)\\n\";\n\n    for (Real t = 0; t &lt; duration; t += dt) {\n        auto state = engine.get_entity_state(satellite);\n\n        // Build environment\n        environment::Environment env;\n        env.altitude = state.position.norm() - constants::EARTH_RADIUS;\n\n        // Compute forces\n        physics::EntityForces forces;\n        forces.clear();\n\n        gravity.compute_forces(state, env, dt, forces);\n\n        // Apply drag only in lower atmosphere\n        if (env.altitude &lt; 800000.0) {\n            drag.compute_forces(state, env, dt, forces);\n        }\n\n        // Apply forces and step\n        engine.apply_forces(satellite, forces);\n        engine.step(dt);\n\n        // Output telemetry every 5 minutes\n        if (std::fmod(t, 300.0) &lt; dt) {\n            state = engine.get_entity_state(satellite);\n\n            // Convert to geodetic\n            using namespace transforms;\n            Vec3 pos_ecef = eci_to_ecef(state.position, t);\n            Real lat, lon, alt;\n            ecef_to_geodetic(pos_ecef, lat, lon, alt);\n\n            std::cout &lt;&lt; t / 60.0 &lt;&lt; \", \"\n                      &lt;&lt; alt / 1000.0 &lt;&lt; \", \"\n                      &lt;&lt; lat * constants::RAD_TO_DEG &lt;&lt; \", \"\n                      &lt;&lt; lon * constants::RAD_TO_DEG &lt;&lt; \"\\n\";\n        }\n    }\n\n    engine.shutdown();\n    return 0;\n}\n</code></pre>"},{"location":"tutorials/space-domain/#tutorial-tle-propagation","title":"Tutorial: TLE Propagation","text":""},{"location":"tutorials/space-domain/#using-sgp4-with-tle-data","title":"Using SGP4 with TLE Data","text":"<pre><code>// Parse TLE\nstd::string line1 = \"1 25544U 98067A   21275.52422453  .00001234  00000-0  28888-4 0  9990\";\nstd::string line2 = \"2 25544  51.6442  27.4345 0003542 211.7212 148.3510 15.48919914305213\";\n\ndomain::space::TLE tle;\nif (!tle.parse(line1, line2)) {\n    std::cerr &lt;&lt; \"Failed to parse TLE\\n\";\n    return 1;\n}\n\n// Initialize SGP4 propagator\ndomain::space::SGP4Propagator sgp4;\nif (!sgp4.initialize(tle)) {\n    std::cerr &lt;&lt; \"Failed to initialize SGP4\\n\";\n    return 1;\n}\n\n// Propagate for 24 hours\nfor (Real minutes = 0; minutes &lt; 24 * 60; minutes += 1.0) {\n    Vec3 pos_km, vel_kms;\n    sgp4.propagate(minutes, pos_km, vel_kms);\n\n    // Convert to SI\n    Vec3 pos_m = pos_km * 1000.0;\n    Vec3 vel_ms = vel_kms * 1000.0;\n\n    // Use position/velocity...\n}\n</code></pre>"},{"location":"tutorials/space-domain/#tutorial-ground-station-visibility","title":"Tutorial: Ground Station Visibility","text":""},{"location":"tutorials/space-domain/#computing-satellite-passes","title":"Computing Satellite Passes","text":"<pre><code>struct Pass {\n    Real start_time;\n    Real end_time;\n    Real max_elevation;\n};\n\nstd::vector&lt;Pass&gt; find_passes(\n    domain::space::SGP4Propagator&amp; sgp4,\n    const Vec3&amp; station_ecef,\n    Real start_jd,\n    Real duration_days,\n    Real min_elevation_deg)\n{\n    std::vector&lt;Pass&gt; passes;\n    Real min_elev_rad = min_elevation_deg * constants::DEG_TO_RAD;\n\n    Real dt = 1.0;  // 1 minute steps\n    bool in_pass = false;\n    Pass current_pass;\n\n    for (Real minutes = 0; minutes &lt; duration_days * 24 * 60; minutes += dt) {\n        // Get satellite position\n        Vec3 pos_km, vel_kms;\n        sgp4.propagate(minutes, pos_km, vel_kms);\n        Vec3 pos_eci = pos_km * 1000.0;\n\n        // Convert to ECEF\n        Real jd = start_jd + minutes / (24 * 60);\n        Vec3 sat_ecef = transforms::eci_to_ecef(pos_eci, jd);\n\n        // Compute elevation angle\n        Vec3 range = sat_ecef - station_ecef;\n        Vec3 up = station_ecef.normalized();\n        Real elevation = std::asin(range.dot(up) / range.norm());\n\n        if (elevation &gt; min_elev_rad) {\n            if (!in_pass) {\n                // Start of pass\n                in_pass = true;\n                current_pass.start_time = minutes;\n                current_pass.max_elevation = elevation;\n            } else {\n                // During pass\n                if (elevation &gt; current_pass.max_elevation) {\n                    current_pass.max_elevation = elevation;\n                }\n            }\n        } else {\n            if (in_pass) {\n                // End of pass\n                current_pass.end_time = minutes;\n                passes.push_back(current_pass);\n                in_pass = false;\n            }\n        }\n    }\n\n    return passes;\n}\n</code></pre>"},{"location":"tutorials/space-domain/#tutorial-constellation-simulation","title":"Tutorial: Constellation Simulation","text":""},{"location":"tutorials/space-domain/#gps-constellation","title":"GPS Constellation","text":"<pre><code>// Create GPS constellation (24 satellites, 6 orbital planes)\nstd::vector&lt;EntityId&gt; gps_satellites;\n\nfor (int plane = 0; plane &lt; 6; ++plane) {\n    for (int slot = 0; slot &lt; 4; ++slot) {\n        std::string name = \"GPS-\" + std::to_string(plane * 4 + slot + 1);\n        EntityId sat = engine.create_entity(name, Domain::Space);\n\n        // GPS orbit parameters\n        domain::space::OrbitalElements orbit;\n        orbit.semi_major_axis = 26560000.0;  // GPS altitude\n        orbit.eccentricity = 0.0;\n        orbit.inclination = 55.0 * DEG_TO_RAD;\n        orbit.raan = plane * 60.0 * DEG_TO_RAD;  // 60\u00b0 separation\n        orbit.arg_of_perigee = 0.0;\n        orbit.true_anomaly = slot * 90.0 * DEG_TO_RAD;  // 90\u00b0 spacing\n\n        Vec3 pos, vel;\n        orbit.to_state_vector(pos, vel);\n\n        physics::EntityState state;\n        state.position = pos;\n        state.velocity = vel;\n        state.mass = 1080.0;  // GPS Block IIR mass\n        engine.set_entity_state(sat, state);\n\n        gps_satellites.push_back(sat);\n    }\n}\n</code></pre>"},{"location":"tutorials/space-domain/#xml-configuration","title":"XML Configuration","text":""},{"location":"tutorials/space-domain/#spacecraft-definition","title":"Spacecraft Definition","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;entity type=\"spacecraft\" name=\"GPS-IIR\"&gt;\n    &lt;mass_balance&gt;\n        &lt;dry_mass unit=\"kg\"&gt;1080&lt;/dry_mass&gt;\n        &lt;fuel_mass unit=\"kg\"&gt;350&lt;/fuel_mass&gt;\n    &lt;/mass_balance&gt;\n\n    &lt;aerodynamics&gt;\n        &lt;drag_coefficient&gt;2.2&lt;/drag_coefficient&gt;\n        &lt;cross_section unit=\"m2\"&gt;10.0&lt;/cross_section&gt;\n    &lt;/aerodynamics&gt;\n\n    &lt;srp&gt;\n        &lt;reflectivity&gt;0.8&lt;/reflectivity&gt;\n        &lt;area unit=\"m2\"&gt;15.0&lt;/area&gt;\n    &lt;/srp&gt;\n\n    &lt;orbit&gt;\n        &lt;semi_major_axis unit=\"km\"&gt;26560&lt;/semi_major_axis&gt;\n        &lt;eccentricity&gt;0.0&lt;/eccentricity&gt;\n        &lt;inclination unit=\"deg\"&gt;55.0&lt;/inclination&gt;\n    &lt;/orbit&gt;\n&lt;/entity&gt;\n</code></pre>"},{"location":"tutorials/space-domain/#common-issues","title":"Common Issues","text":""},{"location":"tutorials/space-domain/#tle-accuracy","title":"TLE Accuracy","text":"<p>Problem: Position errors grow over time</p> <p>Solution: TLE accuracy degrades; use recent TLEs (&lt; 1-2 weeks old)</p>"},{"location":"tutorials/space-domain/#atmospheric-drag-variations","title":"Atmospheric Drag Variations","text":"<p>Problem: Orbit decay rate varies unexpectedly</p> <p>Solution: Update space weather parameters (F10.7, Ap)</p>"},{"location":"tutorials/space-domain/#next-steps","title":"Next Steps","text":"<ul> <li>Air Domain Tutorial - Aircraft simulation</li> <li>Land Domain Tutorial - Ground vehicle simulation</li> <li>Sea Domain Tutorial - Naval simulation</li> <li>API Reference - Space domain API</li> </ul>"},{"location":"tutorials/terrain/","title":"Terrain Tutorial","text":"<p>This tutorial demonstrates how to work with terrain data in JaguarEngine.</p>"},{"location":"tutorials/terrain/#overview","title":"Overview","text":"<p>JaguarEngine's terrain system supports:</p> <ul> <li>DTED: Digital Terrain Elevation Data (Levels 0-2)</li> <li>SRTM: Shuttle Radar Topography Mission</li> <li>GeoTIFF: General raster elevation data</li> <li>Quadtree LOD: Level-of-detail for performance</li> </ul>"},{"location":"tutorials/terrain/#terrain-configuration","title":"Terrain Configuration","text":""},{"location":"tutorials/terrain/#engine-setup","title":"Engine Setup","text":"<pre><code>&lt;engine_config&gt;\n    &lt;terrain enabled=\"true\"&gt;\n        &lt;cache_mb&gt;2048&lt;/cache_mb&gt;\n        &lt;tile_size&gt;256&lt;/tile_size&gt;\n        &lt;data_path&gt;/data/terrain/dted/&lt;/data_path&gt;\n        &lt;data_path&gt;/data/terrain/srtm/&lt;/data_path&gt;\n    &lt;/terrain&gt;\n&lt;/engine_config&gt;\n</code></pre>"},{"location":"tutorials/terrain/#programmatic-configuration","title":"Programmatic Configuration","text":"<pre><code>config::EngineConfig cfg;\ncfg.terrain_enabled = true;\ncfg.terrain_cache_mb = 4096;  // 4 GB cache\ncfg.terrain_data_paths.push_back(\"/data/dted/\");\ncfg.terrain_data_paths.push_back(\"/data/srtm/\");\n\nEngine engine;\nengine.initialize(cfg);\n</code></pre>"},{"location":"tutorials/terrain/#basic-terrain-queries","title":"Basic Terrain Queries","text":""},{"location":"tutorials/terrain/#elevation-query","title":"Elevation Query","text":"<pre><code>auto&amp; terrain = engine.get_environment_service().terrain();\n\n// Query elevation at position\nReal lat = 37.0 * DEG_TO_RAD;\nReal lon = -122.0 * DEG_TO_RAD;\nReal elevation = terrain.get_elevation(lat, lon);\n\nstd::cout &lt;&lt; \"Elevation: \" &lt;&lt; elevation &lt;&lt; \" m\\n\";\n</code></pre>"},{"location":"tutorials/terrain/#surface-normal","title":"Surface Normal","text":"<pre><code>// Get surface normal (for vehicle orientation)\nVec3 normal = terrain.get_surface_normal(lat, lon);\n\n// Compute slope\nReal slope_angle = terrain.get_slope_angle(lat, lon);\nstd::cout &lt;&lt; \"Slope: \" &lt;&lt; slope_angle * RAD_TO_DEG &lt;&lt; \" degrees\\n\";\n</code></pre>"},{"location":"tutorials/terrain/#full-query","title":"Full Query","text":"<pre><code>TerrainQuery query = terrain.query(lat, lon);\nif (query.valid) {\n    std::cout &lt;&lt; \"Elevation: \" &lt;&lt; query.elevation &lt;&lt; \" m\\n\";\n    std::cout &lt;&lt; \"Normal: \" &lt;&lt; query.normal &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Slope: \" &lt;&lt; query.slope_angle * RAD_TO_DEG &lt;&lt; \" deg\\n\";\n    std::cout &lt;&lt; \"Material: \" &lt;&lt; query.material.name &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"tutorials/terrain/#working-with-materials","title":"Working with Materials","text":""},{"location":"tutorials/terrain/#soil-types","title":"Soil Types","text":"<pre><code>// Get terrain material\nTerrainMaterial material = terrain.get_material(lat, lon);\n\n// Get soil properties for terramechanics\ndomain::land::SoilProperties soil;\n\nswitch (material.type) {\n    case MaterialType::Sand:\n        soil = domain::land::SoilProperties::DrySand();\n        break;\n    case MaterialType::Clay:\n        soil = domain::land::SoilProperties::Clay();\n        break;\n    case MaterialType::Rock:\n        soil = domain::land::SoilProperties::Asphalt();\n        break;\n    case MaterialType::Water:\n        // Handle water body\n        break;\n    default:\n        soil = domain::land::SoilProperties::DrySand();\n}\n</code></pre>"},{"location":"tutorials/terrain/#material-database","title":"Material Database","text":"<pre><code>&lt;!-- materials/terrain_materials.xml --&gt;\n&lt;material_database&gt;\n    &lt;material id=\"1\" name=\"sand\"&gt;\n        &lt;friction&gt;0.6&lt;/friction&gt;\n        &lt;soil_type&gt;dry_sand&lt;/soil_type&gt;\n    &lt;/material&gt;\n\n    &lt;material id=\"2\" name=\"forest\"&gt;\n        &lt;friction&gt;0.7&lt;/friction&gt;\n        &lt;soil_type&gt;clay&lt;/soil_type&gt;\n        &lt;vegetation_density&gt;0.8&lt;/vegetation_density&gt;\n    &lt;/material&gt;\n\n    &lt;material id=\"3\" name=\"urban\"&gt;\n        &lt;friction&gt;0.85&lt;/friction&gt;\n        &lt;soil_type&gt;asphalt&lt;/soil_type&gt;\n    &lt;/material&gt;\n&lt;/material_database&gt;\n</code></pre>"},{"location":"tutorials/terrain/#lod-and-performance","title":"LOD and Performance","text":""},{"location":"tutorials/terrain/#focus-point","title":"Focus Point","text":"<pre><code>// Set terrain detail center (e.g., player position)\nVec3 focus_ecef = current_entity_position;\nterrain.set_focus_point(focus_ecef);\n\n// Set radius of high detail\nterrain.set_detail_radius(50000.0);  // 50 km high detail\n</code></pre>"},{"location":"tutorials/terrain/#cache-management","title":"Cache Management","text":"<pre><code>// Monitor cache usage\nSizeT loaded_tiles = terrain.loaded_tile_count();\nSizeT cache_bytes = terrain.cache_usage_bytes();\n\nstd::cout &lt;&lt; \"Loaded tiles: \" &lt;&lt; loaded_tiles &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Cache usage: \" &lt;&lt; cache_bytes / 1024 / 1024 &lt;&lt; \" MB\\n\";\n\n// Force cache update\nterrain.update();\n</code></pre>"},{"location":"tutorials/terrain/#ground-vehicle-integration","title":"Ground Vehicle Integration","text":""},{"location":"tutorials/terrain/#height-above-terrain","title":"Height Above Terrain","text":"<pre><code>void update_vehicle_on_terrain(Engine&amp; engine, EntityId vehicle) {\n    auto state = engine.get_entity_state(vehicle);\n    auto env = engine.get_environment(vehicle);\n\n    // Height above terrain\n    Real hat = env.altitude - env.terrain_elevation;\n\n    if (hat &lt; 0.1) {\n        // Vehicle on ground - apply terrain normal\n        Vec3 up = env.terrain.normal;\n\n        // Project velocity onto terrain plane\n        Vec3 vel = state.velocity;\n        Real normal_vel = vel.dot(up);\n        if (normal_vel &lt; 0) {\n            // Remove downward velocity component\n            vel -= up * normal_vel;\n            state.velocity = vel;\n        }\n\n        // Align vehicle to terrain\n        // ... orientation adjustment ...\n    }\n}\n</code></pre>"},{"location":"tutorials/terrain/#terrain-following","title":"Terrain Following","text":"<pre><code>class TerrainFollower {\npublic:\n    void set_target_agl(Real agl) { target_agl_ = agl; }\n\n    void update(Engine&amp; engine, EntityId aircraft, Real dt) {\n        auto state = engine.get_entity_state(aircraft);\n        auto env = engine.get_environment(aircraft);\n\n        // Current height above terrain\n        Real current_agl = env.altitude - env.terrain_elevation;\n\n        // Look-ahead terrain query\n        Vec3 ahead = state.velocity.normalized() * lookahead_dist_;\n        Real lat_ahead, lon_ahead, alt_ahead;\n        transforms::ecef_to_geodetic(\n            state.position + ahead, lat_ahead, lon_ahead, alt_ahead);\n\n        auto&amp; terrain = engine.get_environment_service().terrain();\n        Real terrain_ahead = terrain.get_elevation(lat_ahead, lon_ahead);\n\n        // Required altitude\n        Real required_alt = terrain_ahead + target_agl_;\n\n        // Compute climb/dive command\n        Real alt_error = required_alt - env.altitude;\n        pitch_cmd_ = kp_ * alt_error;\n        pitch_cmd_ = std::clamp(pitch_cmd_, -max_pitch_, max_pitch_);\n    }\n\n    Real get_pitch_command() const { return pitch_cmd_; }\n\nprivate:\n    Real target_agl_{100.0};\n    Real lookahead_dist_{1000.0};\n    Real kp_{0.01};\n    Real max_pitch_{0.5};\n    Real pitch_cmd_{0.0};\n};\n</code></pre>"},{"location":"tutorials/terrain/#terrain-data-sources","title":"Terrain Data Sources","text":""},{"location":"tutorials/terrain/#dted-levels","title":"DTED Levels","text":"Level Resolution Coverage Use Case 0 ~900 m Global Strategic planning 1 ~90 m Most land Tactical simulation 2 ~30 m Select areas High-fidelity"},{"location":"tutorials/terrain/#data-organization","title":"Data Organization","text":"<pre><code>/data/terrain/\n\u251c\u2500\u2500 dted/\n\u2502   \u251c\u2500\u2500 w123/\n\u2502   \u2502   \u251c\u2500\u2500 n36.dt1\n\u2502   \u2502   \u251c\u2500\u2500 n37.dt1\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 w122/\n\u2502       \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 srtm/\n\u2502   \u251c\u2500\u2500 n36_w123_1arc_v3.tif\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 custom/\n    \u2514\u2500\u2500 local_dem.tif\n</code></pre>"},{"location":"tutorials/terrain/#advanced-topics","title":"Advanced Topics","text":""},{"location":"tutorials/terrain/#custom-terrain-provider","title":"Custom Terrain Provider","text":"<pre><code>class CustomTerrainProvider : public ITerrainProvider {\npublic:\n    Real get_elevation(Real lat, Real lon) override {\n        // Custom elevation source\n        return lookup_custom_data(lat, lon);\n    }\n\n    Vec3 get_normal(Real lat, Real lon) override {\n        // Compute normal from neighboring elevations\n        Real h0 = get_elevation(lat, lon);\n        Real hx = get_elevation(lat, lon + dlat);\n        Real hy = get_elevation(lat + dlat, lon);\n\n        Vec3 dx{dlat * R_EARTH, 0, hx - h0};\n        Vec3 dy{0, dlat * R_EARTH, hy - h0};\n        return dx.cross(dy).normalized();\n    }\n\nprivate:\n    Real lookup_custom_data(Real lat, Real lon);\n};\n</code></pre>"},{"location":"tutorials/terrain/#procedural-terrain","title":"Procedural Terrain","text":"<pre><code>Real procedural_elevation(Real lat, Real lon) {\n    // Perlin noise-based terrain\n    Real scale = 0.0001;\n    Real x = lon / scale;\n    Real y = lat / scale;\n\n    Real h = 0.0;\n    Real amplitude = 1000.0;  // Base amplitude in meters\n\n    // Multiple octaves\n    for (int octave = 0; octave &lt; 4; ++octave) {\n        h += amplitude * perlin_noise(x, y);\n        amplitude *= 0.5;\n        x *= 2.0;\n        y *= 2.0;\n    }\n\n    return h;\n}\n</code></pre>"},{"location":"tutorials/terrain/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/terrain/#performance","title":"Performance","text":"<ol> <li>Cache appropriately: Set cache size based on area of operation</li> <li>Use focus point: Prioritize detail where needed</li> <li>Batch queries: Group terrain queries when possible</li> </ol>"},{"location":"tutorials/terrain/#data-management","title":"Data Management","text":"<ol> <li>Organize by region: Structure data directories logically</li> <li>Use appropriate resolution: Higher isn't always better</li> <li>Verify coverage: Ensure data covers simulation area</li> </ol>"},{"location":"tutorials/terrain/#common-issues","title":"Common Issues","text":"<p>Missing terrain data: Verify data paths and file formats</p> <p>Performance spikes: Increase cache size or reduce detail radius</p> <p>Discontinuities: Check for data gaps between tiles</p>"},{"location":"tutorials/terrain/#see-also","title":"See Also","text":"<ul> <li>Environment - Environment system</li> <li>Land Domain - Ground vehicle simulation</li> <li>Configuration - Configuration options</li> </ul>"}]}